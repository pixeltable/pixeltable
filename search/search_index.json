{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pixeltable API Reference","text":"<p>API Cheat Sheet</p>"},{"location":"#content","title":"Content","text":"<ul> <li>pixeltable: Core package with table operations and     type system</li> <li>pixeltable.io: Data import/export utilities</li> <li>pixeltable.iterators: Built-in     iterators for data transformation</li> <li>pixeltable.functions: Pre-built functions for     common operations</li> <li>Configuration Options: Most options can be specified either     as an environment variable or in <code>config.toml</code></li> </ul>"},{"location":"#resources","title":"Resources","text":"<ul> <li>Main Documentation</li> <li>GitHub</li> <li>Discord</li> <li>Website</li> </ul>"},{"location":"api-cheat-sheet/","title":"API Cheat Sheet","text":"<p>Import conventions:</p> <pre><code>import pixeltable as pxt\nimport pixeltable.functions as pxtf\n</code></pre>"},{"location":"api-cheat-sheet/#operations-summary","title":"Operations summary","text":"Task Code Create a (mutable) table t = <code>pxt.create_table</code>('table_name', {'col_1': pxt.String, 'col_2': pxt.Int, ...}) Create a view t = <code>pxt.create_view</code>('view_name', base_tbl.where(base_tbl.col &gt; 10)) Create a view with iterator t = <code>pxt.create_view</code>('view_name', base_tbl, iterator=FrameIterator.create(video=base_tbl.col, fps=0)) Create a snapshot t = <code>pxt.create_snapshot</code>('snapshot_name', base_tbl) <p>The following functions apply to tables, views, and snapshots.</p> Task Code Use an existing table t = <code>pxt.get_table</code>('video_data') Rename a table <code>pxt.move</code>('video_data', 'vd') Move a table <code>pxt.move</code>('video_data', 'experiments.video_data') List tables <code>pxt.list_tables</code>() Delete a table <code>pxt.drop_table</code>('video_data') Delete a table and all its views <code>pxt.drop_table</code>('video_data', force=True)"},{"location":"api-cheat-sheet/#directories","title":"Directories","text":"Task Code Create a directory <code>pxt.create_dir</code>('experiments') Rename or move a directory <code>pxt.move</code>('experiments', 'project_x.experiments') Delete a directory <code>pxt.drop_dir</code>('experiments') Delete a directory and all its contents <code>pxt.drop_dir</code>('experiments', force=True) List directories <code>pxt.list_dirs</code>('project_x')"},{"location":"api-cheat-sheet/#frame-extraction-for-video-data","title":"Frame extraction for video data","text":"<p>Create a table with video data and view for the frames:</p> <pre><code>import pixeltable as pxt\nfrom pixeltable.iterators import FrameIterator\nt = pxt.create_table('tbl_name', {'video': pxt.Video})\nf = pxt.create_view('frame_view_name', t, iterator=FrameIterator.create(video=t.video, fps=0))\n</code></pre> <p><code>fps=0</code> extracts frames at the original frame rate.</p>"},{"location":"api-cheat-sheet/#audio-extraction-from-video-data-and-audio-chunking","title":"Audio extraction from video data and audio chunking","text":"<p>Extract audio from video data</p> <pre><code>import pixeltable as pxt\nfrom pixeltable.iterators import AudioSplitter\nvideo_t = pxt.create_table('tbl_name', {'video': pxt.Video})\nvideo_t.add_computed_column(audio=video_t.video.extract_audio(format='mp3'))\naudio_chunk_view = pxt.create_view(\"audio_chunks\", video_t, iterator=AudioSplitter.create(audio=video_t.audio, chunk_duration_sec=5.0))\n</code></pre> <p><code>chunk_duration_sec</code> is the time duration of an audio chunk in seconds</p>"},{"location":"api-cheat-sheet/#pixeltable-types","title":"Pixeltable types","text":"Pixeltable type Corresponding Python type <code>pxt.String</code> <code>str</code> <code>pxt.Int</code> <code>int</code> <code>pxt.Float</code> <code>float</code> <code>pxt.Bool</code> <code>bool</code> <code>pxt.Timestamp</code> <code>datetime.datetime</code> <code>pxt.Json</code> <code>list</code> or <code>dict</code> <code>pxt.Array</code> <code>numpy.ndarray</code> <code>pxt.Image</code> <code>PIL.Image.Image</code> <code>pxt.Video</code> <code>str</code> (the file path or URL) <code>pxt.Audio</code> <code>str</code> (the file path or URL) <code>pxt.Document</code> <code>str</code> (the file path or URL)"},{"location":"api-cheat-sheet/#table-operations-summary","title":"Table operations summary","text":"Action Code Print table schema t.<code>describe</code>() Query a table t.<code>select</code>(t.col2, t.col3 + 5).show() Query a table with a filter t.<code>where</code>(t.col1 == 'green').<code>select</code>(t.col2).show() Insert a single row into a table t.<code>insert</code>(col1='green', ...) Insert multiple rows into a table t.<code>insert</code>([{'col1': 'green', ...}, {'col1': 'red', ...}, ...]) Add a column t.<code>add_column</code>(new_col_name=pxt.Int) Add a column (alternate form) t[new_col_name] = pxt.Int Rename a column t.<code>rename_column</code>('col_name', 'new_col_name') Drop a column t.<code>drop_column</code>('col_name') Undo the last update operation (add/rename/drop column or insert) t.<code>revert</code>()"},{"location":"api-cheat-sheet/#querying-a-table","title":"Querying a table","text":"Action Code Look at 10 rows t.<code>collect</code>(10) Look at the oldest 10 rows t.<code>head</code>(10) Look at the most recently added 10 rows t.<code>tail</code>(10) Look at all rows t.<code>collect</code>() Iterate over all rows as dictionaries for row in t.<code>collect</code>(): ... Look at row for frame 15 t.<code>where</code>(t.pos  == 15).show() Look at rows before index 15 t.<code>where</code>(t.pos &lt; 15).show() Look at rows before index 15 with RGB frames t.<code>where</code>((t.pos &lt; 15) &amp; (t.frame.mode == 'RGB')).collect() <p>Pixeltable supports the standard comparison operators (<code>&gt;=</code>, <code>&gt;</code>, <code>==</code>, <code>&lt;=</code>, <code>&lt;</code>). <code>== None</code> is the equivalent of <code>isna()/isnull()</code> in Pandas.</p> <p>Boolean operators are the same as in Pandas: <code>&amp;</code> for <code>and</code>, <code>|</code> for <code>or</code>, <code>~</code> for <code>not</code>. They also require parentheses, for example: <code>(t.pos &lt; 15) &amp; (t.frame.mode == 'RGB')</code> or <code>~(t.frame.mode == 'RGB')</code>.</p>"},{"location":"api-cheat-sheet/#selecting-and-transforming-columns","title":"Selecting and transforming columns","text":"Action Code Only retrieve the frame index and frame t.<code>select</code>(t.frame_idx, t.frame).collect() Look at frames rotated 90 degrees t.<code>select</code>(t.frame.rotate(90)).collect() Overlay frame with itself rotated 90 degrees t.<code>select</code>(pxt.functions.pil.image.blend(t.frame, t.frame.rotate(90))).collect()"},{"location":"api-cheat-sheet/#computed-columns","title":"Computed columns","text":"<p>The values in a computed column are automatically filled when data is added:</p> <pre><code>t.add_column(c_added=t.frame.rotate(30))\n</code></pre> <p>Alternatively:</p> <pre><code>t['c_added'] = t.frame.rotate(30)\n</code></pre> <p>Computed columns and media columns (video, image, audio) have attributes <code>errortype</code> and <code>errormsg</code>, which contain the exception type and string in rows where the computation expression or media type validation results in an exception (the column value itself will be <code>None</code>).</p> <p>Example:</p> <pre><code>t.where(t.c_added.errortype != None).select(t.c_added.errortype, t.c_added.errormsg).show()\n</code></pre> <p>returns the exception type and message for rows with an exception.</p>"},{"location":"api-cheat-sheet/#inserting-data-into-a-table","title":"Inserting data into a table","text":"<pre><code>t.insert([{'video': '/path/to/video1.mp4'}, {'video': '/path/to/video2.mp4'}])\n</code></pre> <p>Each row is a dictionary mapping column names to column values (do not provide values for computed columns).</p>"},{"location":"api-cheat-sheet/#attributes-and-methods-on-image-data","title":"Attributes and methods on image data","text":"<p>Images are represented as <code>PIL.Image.Image</code> instances in memory and support a lot of the attributes and methods documented here.</p> <p>Available attributes are: <code>mode</code>, <code>height</code>, <code>width</code>.</p> <p>Available methods are: <code>convert</code>, <code>crop</code>, <code>effect_spread</code>, <code>entropy</code>, <code>filter</code>, <code>getbands</code>, <code>getbbox</code>, <code>getchannel</code>, <code>getcolors</code>, <code>getextrema</code>, <code>getpalette</code>, <code>getpixel</code>, <code>getprojection</code>, <code>histogram</code>, <code>point</code>, <code>quantize</code>, <code>reduce</code>, <code>remap_palette</code>, <code>resize</code>, <code>rotate</code>, <code>transform</code>, <code>transpose</code>.</p> <p>Methods can be chained, for example: <code>t.frame.resize((224, 224)).rotate(90).convert('L')</code></p>"},{"location":"pixeltable/data-frame/","title":"DataFrame","text":"<p><code>DataFrame</code> represents a query against a specific table. Unlike computation container frameworks like pandas or Dask, Pixeltable dataframes do not hold data or allow you to update data (use insert/update/delete for that purpose). Another difference to pandas is that query execution needs to be initiated explicitly in order to return results.</p>"},{"location":"pixeltable/data-frame/#overview","title":"Overview","text":"Query Construction <code>select</code> Select output expressions <code>join</code> Join to another table <code>where</code> Filter table rows <code>group_by</code> Group table rows in order to apply aggregate functions <code>order_by</code> Order output rows <code>limit</code> Limit the number of output rows <code>distinct</code> Remove duplicate rows <code>sample</code> Select shuffled sample of rows Query Execution <code>collect</code> Return all output rows <code>show</code> Return a number of output rows <code>head</code> Return the oldest rows <code>tail</code> Return the most recently added rows Data Export <code>to_pytorch_dataset</code> Return the query result as a pytorch <code>IterableDataset</code> <code>to_coco_dataset</code> Return the query result as a COCO dataset"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame","title":"pixeltable.DataFrame","text":"<pre><code>DataFrame(\n    from_clause: Optional[FromClause] = None,\n    select_list: Optional[list[tuple[Expr, Optional[str]]]] = None,\n    where_clause: Optional[Expr] = None,\n    group_by_clause: Optional[list[Expr]] = None,\n    grouping_tbl: Optional[TableVersion] = None,\n    order_by_clause: Optional[list[tuple[Expr, bool]]] = None,\n    limit: Optional[Expr] = None,\n    sample_clause: Optional[SampleClause] = None,\n)\n</code></pre>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.collect","title":"collect","text":"<pre><code>collect() -&gt; DataFrameResultSet\n</code></pre>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.group_by","title":"group_by","text":"<pre><code>group_by(*grouping_items: Any) -&gt; DataFrame\n</code></pre> <p>Add a group-by clause to this DataFrame.</p> <p>Variants: - group_by(): group a component view by their respective base table rows - group_by(, ...): group by the given expressions <p>Note, that grouping will be applied to the rows and take effect when used with an aggregation function like sum(), count() etc.</p> <p>Parameters:</p> <ul> <li> <code>grouping_items</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>expressions to group by</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A new DataFrame with the specified group-by clause.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the group-by clause is already specified, or if the specified expression is invalid, or refer to tables not in the DataFrame, or if the DataFrame is a result of a join.</p> </li> </ul> <p>Examples:</p> <p>Given the DataFrame book from a table t with all its columns and rows:</p> <pre><code>&gt;&gt;&gt; book = t.select()\n</code></pre> <p>Group the above DataFrame book by the 'genre' column (referenced in table t):</p> <pre><code>&gt;&gt;&gt; df = book.group_by(t.genre)\n</code></pre> <p>Use the above DataFrame df grouped by genre to count the number of books for each 'genre':</p> <pre><code>&gt;&gt;&gt; df = book.group_by(t.genre).select(t.genre, count=count(t.genre)).show()\n</code></pre> <p>Use the above DataFrame df grouped by genre to the total price of books for each 'genre':</p> <pre><code>&gt;&gt;&gt; df = book.group_by(t.genre).select(t.genre, total=sum(t.price)).show()\n</code></pre>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.head","title":"head","text":"<pre><code>head(n: int = 10) -&gt; DataFrameResultSet\n</code></pre> <p>Return the first n rows of the DataFrame, in insertion order of the underlying Table.</p> <p>head() is not supported for joins.</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of rows to select. Default is 10.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrameResultSet</code>           \u2013            <p>A DataFrameResultSet with the first n rows of the DataFrame.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the DataFrame is the result of a join or if the DataFrame has an order_by clause.</p> </li> </ul>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.limit","title":"limit","text":"<pre><code>limit(n: int) -&gt; DataFrame\n</code></pre> <p>Limit the number of rows in the DataFrame.</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>)           \u2013            <p>Number of rows to select.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A new DataFrame with the specified limited rows.</p> </li> </ul>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.order_by","title":"order_by","text":"<pre><code>order_by(*expr_list: Expr, asc: bool = True) -&gt; DataFrame\n</code></pre> <p>Add an order-by clause to this DataFrame.</p> <p>Parameters:</p> <ul> <li> <code>expr_list</code>               (<code>Expr</code>, default:                   <code>()</code> )           \u2013            <p>expressions to order by</p> </li> <li> <code>asc</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to order in ascending order (True) or descending order (False). Default is True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A new DataFrame with the specified order-by clause.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the order-by clause is already specified, or if the specified expression is invalid, or refer to tables not in the DataFrame.</p> </li> </ul> <p>Examples:</p> <p>Given the DataFrame book from a table t with all its columns and rows:</p> <pre><code>&gt;&gt;&gt; book = t.select()\n</code></pre> <p>Order the above DataFrame book by two columns (price, pages) in descending order:</p> <pre><code>&gt;&gt;&gt; df = book.order_by(t.price, t.pages, asc=False)\n</code></pre> <p>Order the above DataFrame book by price in descending order, but order the pages in ascending order:</p> <pre><code>&gt;&gt;&gt; df = book.order_by(t.price, asc=False).order_by(t.pages)\n</code></pre>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.select","title":"select","text":"<pre><code>select(*items: Any, **named_items: Any) -&gt; DataFrame\n</code></pre> <p>Select columns or expressions from the DataFrame.</p> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>expressions to be selected</p> </li> <li> <code>named_items</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>named expressions to be selected</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A new DataFrame with the specified select list.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the select list is already specified, or if any of the specified expressions are invalid, or refer to tables not in the DataFrame.</p> </li> </ul> <p>Examples:</p> <p>Given the DataFrame person from a table t with all its columns and rows:</p> <pre><code>&gt;&gt;&gt; person = t.select()\n</code></pre> <p>Select the columns 'name' and 'age' (referenced in table t) from the DataFrame person:</p> <pre><code>&gt;&gt;&gt; df = person.select(t.name, t.age)\n</code></pre> <p>Select the columns 'name' (referenced in table t) from the DataFrame person, and a named column 'is_adult' from the expression <code>age &gt;= 18</code> where 'age' is another column in table t:</p> <pre><code>&gt;&gt;&gt; df = person.select(t.name, is_adult=(t.age &gt;= 18))\n</code></pre>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.join","title":"join","text":"<pre><code>join(\n    other: Table,\n    on: Optional[Union[Expr, Sequence[ColumnRef]]] = None,\n    how: LiteralType = \"inner\",\n) -&gt; DataFrame\n</code></pre> <p>Join this DataFrame with a table.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>Table</code>)           \u2013            <p>the table to join with</p> </li> <li> <code>on</code>               (<code>Optional[Union[Expr, Sequence[ColumnRef]]]</code>, default:                   <code>None</code> )           \u2013            <p>the join condition, which can be either a) references to one or more columns or b) a boolean expression.</p> <ul> <li> <p>column references: implies an equality predicate that matches columns in both this     DataFrame and <code>other</code> by name.</p> <ul> <li>column in <code>other</code>: A column with that same name must be present in this DataFrame, and it must     be unique (otherwise the join is ambiguous).</li> <li>column in this DataFrame: A column with that same name must be present in <code>other</code>.</li> </ul> </li> <li> <p>boolean expression: The expressions must be valid in the context of the joined tables.</p> </li> </ul> </li> <li> <code>how</code>               (<code>LiteralType</code>, default:                   <code>'inner'</code> )           \u2013            <p>the type of join to perform.</p> <ul> <li><code>'inner'</code>: only keep rows that have a match in both</li> <li><code>'left'</code>: keep all rows from this DataFrame and only matching rows from the other table</li> <li><code>'right'</code>: keep all rows from the other table and only matching rows from this DataFrame</li> <li><code>'full_outer'</code>: keep all rows from both this DataFrame and the other table</li> <li><code>'cross'</code>: Cartesian product; no <code>on</code> condition allowed</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A new DataFrame.</p> </li> </ul> <p>Examples:</p> <p>Perform an inner join between t1 and t2 on the column id:</p> <pre><code>&gt;&gt;&gt; join1 = t1.join(t2, on=t2.id)\n</code></pre> <p>Perform a left outer join of join1 with t3, also on id (note that we can't specify <code>on=t3.id</code> here, because that would be ambiguous, since both t1 and t2 have a column named id):</p> <pre><code>&gt;&gt;&gt; join2 = join1.join(t3, on=t2.id, how='left')\n</code></pre> <p>Do the same, but now with an explicit join predicate:</p> <pre><code>&gt;&gt;&gt; join2 = join1.join(t3, on=t2.id == t3.id, how='left')\n</code></pre> <p>Join t with d, which has a composite primary key (columns pk1 and pk2, with corresponding foreign key columns d1 and d2 in t):</p> <pre><code>&gt;&gt;&gt; df = t.join(d, on=(t.d1 == d.pk1) &amp; (t.d2 == d.pk2), how='left')\n</code></pre>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.show","title":"show","text":"<pre><code>show(n: int = 20) -&gt; DataFrameResultSet\n</code></pre>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.tail","title":"tail","text":"<pre><code>tail(n: int = 10) -&gt; DataFrameResultSet\n</code></pre> <p>Return the last n rows of the DataFrame, in insertion order of the underlying Table.</p> <p>tail() is not supported for joins.</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of rows to select. Default is 10.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrameResultSet</code>           \u2013            <p>A DataFrameResultSet with the last n rows of the DataFrame.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the DataFrame is the result of a join or if the DataFrame has an order_by clause.</p> </li> </ul>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.to_pytorch_dataset","title":"to_pytorch_dataset","text":"<pre><code>to_pytorch_dataset(\n    image_format: str = \"pt\",\n) -&gt; \"torch.utils.data.IterableDataset\"\n</code></pre> <p>Convert the dataframe to a pytorch IterableDataset suitable for parallel loading with torch.utils.data.DataLoader.</p> <p>This method requires pyarrow &gt;= 13, torch and torchvision to work.</p> <p>This method serializes data so it can be read from disk efficiently and repeatedly without re-executing the query. This data is cached to disk for future re-use.</p> <p>Parameters:</p> <ul> <li> <code>image_format</code>               (<code>str</code>, default:                   <code>'pt'</code> )           \u2013            <p>format of the images. Can be 'pt' (pytorch tensor) or 'np' (numpy array).     'np' means image columns return as an RGB uint8 array of shape HxWxC.     'pt' means image columns return as a CxHxW tensor with values in [0,1] and type torch.float32.         (the format output by torchvision.transforms.ToTensor())</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>'torch.utils.data.IterableDataset'</code>           \u2013            <p>A pytorch IterableDataset: Columns become fields of the dataset, where rows are returned as a dictionary compatible with torch.utils.data.DataLoader default collation.</p> </li> </ul> Constraints <p>The default collate_fn for torch.data.util.DataLoader cannot represent null values as part of a pytorch tensor when forming batches. These values will raise an exception while running the dataloader.</p> <p>If you have them, you can work around None values by providing your custom collate_fn to the DataLoader (and have your model handle it). Or, if these are not meaningful values within a minibtach, you can modify or remove any such values through selections and filters prior to calling to_pytorch_dataset().</p>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.to_coco_dataset","title":"to_coco_dataset","text":"<pre><code>to_coco_dataset() -&gt; Path\n</code></pre> <p>Convert the dataframe to a COCO dataset. This dataframe must return a single json-typed output column in the following format: {     'image': PIL.Image.Image,     'annotations': [         {             'bbox': [x: int, y: int, w: int, h: int],             'category': str | int,         },         ...     ], }</p> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>Path to the COCO dataset file.</p> </li> </ul>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.where","title":"where","text":"<pre><code>where(pred: Expr) -&gt; DataFrame\n</code></pre> <p>Filter rows based on a predicate.</p> <p>Parameters:</p> <ul> <li> <code>pred</code>               (<code>Expr</code>)           \u2013            <p>the predicate to filter rows</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A new DataFrame with the specified predicates replacing the where-clause.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the predicate is not a Pixeltable expression, or if it does not return a boolean value, or refers to tables not in the DataFrame.</p> </li> </ul> <p>Examples:</p> <p>Given the DataFrame person from a table t with all its columns and rows:</p> <pre><code>&gt;&gt;&gt; person = t.select()\n</code></pre> <p>Filter the above DataFrame person to only include rows where the column 'age' (referenced in table t) is greater than 30:</p> <pre><code>&gt;&gt;&gt; df = person.where(t.age &gt; 30)\n</code></pre>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.distinct","title":"distinct","text":"<pre><code>distinct() -&gt; DataFrame\n</code></pre> <p>Remove duplicate rows from this DataFrame.</p> <p>Note that grouping will be applied to the rows based on the select clause of this Dataframe. In the absence of a select clause, by default, all columns are selected in the grouping.</p> <p>Examples:</p> <p>Select unique addresses from table <code>addresses</code>.</p> <pre><code>&gt;&gt;&gt; results = addresses.distinct()\n</code></pre> <p>Select unique cities in table <code>addresses</code></p> <pre><code>&gt;&gt;&gt; results = addresses.city.distinct()\n</code></pre> <p>Select unique locations (street, city) in the state of <code>CA</code></p> <pre><code>&gt;&gt;&gt; results = addresses.select(addresses.street, addresses.city).where(addresses.state == 'CA').distinct()\n</code></pre>"},{"location":"pixeltable/data-frame/#pixeltable.DataFrame.sample","title":"sample","text":"<pre><code>sample(\n    n: Optional[int] = None,\n    n_per_stratum: Optional[int] = None,\n    fraction: Optional[float] = None,\n    seed: Optional[int] = None,\n    stratify_by: Any = None,\n) -&gt; DataFrame\n</code></pre> <p>Return a new DataFrame specifying a sample of rows from the DataFrame, considered in a shuffled order.</p> <p>The size of the sample can be specified in three ways:</p> <ul> <li><code>n</code>: the total number of rows to produce as a sample</li> <li><code>n_per_stratum</code>: the number of rows to produce per stratum as a sample</li> <li><code>fraction</code>: the fraction of available rows to produce as a sample</li> </ul> <p>The sample can be stratified by one or more columns, which means that the sample will be selected from each stratum separately.</p> <p>The data is shuffled before creating the sample.</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Total number of rows to produce as a sample.</p> </li> <li> <code>n_per_stratum</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Number of rows to produce per stratum as a sample. This parameter is only valid if <code>stratify_by</code> is specified. Only one of <code>n</code> or <code>n_per_stratum</code> can be specified.</p> </li> <li> <code>fraction</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Fraction of available rows to produce as a sample. This parameter is not usable with <code>n</code> or <code>n_per_stratum</code>. The fraction must be between 0.0 and 1.0.</p> </li> <li> <code>seed</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Random seed for reproducible shuffling</p> </li> <li> <code>stratify_by</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>If specified, the sample will be stratified by these values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A new DataFrame which specifies the sampled rows</p> </li> </ul> <p>Examples:</p> <p>Given the Table <code>person</code> containing the field 'age', we can create samples of the table in various ways:</p> <p>Sample 100 rows from the above Table:</p> <pre><code>&gt;&gt;&gt; df = person.sample(n=100)\n</code></pre> <p>Sample 10% of the rows from the above Table:</p> <pre><code>&gt;&gt;&gt; df = person.sample(fraction=0.1)\n</code></pre> <p>Sample 10% of the rows from the above Table, stratified by the column 'age':</p> <pre><code>&gt;&gt;&gt; df = person.sample(fraction=0.1, stratify_by=t.age)\n</code></pre> <p>Equal allocation sampling: Sample 2 rows from each age present in the above Table:</p> <pre><code>&gt;&gt;&gt; df = person.sample(n_per_stratum=2, stratify_by=t.age)\n</code></pre> <p>Sampling is compatible with the where clause, so we can also sample from a filtered DataFrame:</p> <pre><code>&gt;&gt;&gt; df = person.where(t.age &gt; 30).sample(n=100)\n</code></pre>"},{"location":"pixeltable/io/","title":"pixeltable.io","text":""},{"location":"pixeltable/io/#pixeltable.io","title":"pixeltable.io","text":""},{"location":"pixeltable/io/#pixeltable.io.create_label_studio_project","title":"create_label_studio_project","text":"<pre><code>create_label_studio_project(\n    t: Table,\n    label_config: str,\n    name: Optional[str] = None,\n    title: Optional[str] = None,\n    media_import_method: Literal[\"post\", \"file\", \"url\"] = \"post\",\n    col_mapping: Optional[dict[str, str]] = None,\n    sync_immediately: bool = True,\n    s3_configuration: Optional[dict[str, Any]] = None,\n    **kwargs: Any\n) -&gt; SyncStatus\n</code></pre> <p>Create a new Label Studio project and link it to the specified <code>Table</code>.</p> <ul> <li>A tutorial notebook with fully worked examples can be found here:   Using Label Studio for Annotations with Pixeltable</li> </ul> <p>The required parameter <code>label_config</code> specifies the Label Studio project configuration, in XML format, as described in the Label Studio documentation. The linked project will have one column for each data field in the configuration; for example, if the configuration has an entry</p> <pre><code>&lt;Image name=\"image_obj\" value=\"$image\"/&gt;\n</code></pre> <p>then the linked project will have a column named <code>image</code>. In addition, the linked project will always have a JSON-typed column <code>annotations</code> representing the output.</p> <p>By default, Pixeltable will link each of these columns to a column of the specified <code>Table</code> with the same name. If any of the data fields are missing, an exception will be raised. If the <code>annotations</code> column is missing, it will be created. The default names can be overridden by specifying an optional <code>col_mapping</code>, with Pixeltable column names as keys and Label Studio field names as values. In all cases, the Pixeltable columns must have types that are consistent with their corresponding Label Studio fields; otherwise, an exception will be raised.</p> <p>The API key and URL for a valid Label Studio server must be specified in Pixeltable config. Either:</p> <ul> <li>Set the <code>LABEL_STUDIO_API_KEY</code> and <code>LABEL_STUDIO_URL</code> environment variables; or</li> <li>Specify <code>api_key</code> and <code>url</code> fields in the <code>label-studio</code> section of <code>$PIXELTABLE_HOME/config.toml</code>.</li> </ul> <p>Requirements:</p> <ul> <li><code>pip install label-studio-sdk</code></li> <li><code>pip install boto3</code> (if using S3 import storage)</li> </ul> <p>Parameters:</p> <ul> <li> <code>t</code>               (<code>Table</code>)           \u2013            <p>The table to link to.</p> </li> <li> <code>label_config</code>               (<code>str</code>)           \u2013            <p>The Label Studio project configuration, in XML format.</p> </li> <li> <code>name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the new project in Pixeltable. If specified, must be a valid Pixeltable identifier and must not be the name of any other external data store linked to <code>t</code>. If not specified, a default name will be used of the form <code>ls_project_0</code>, <code>ls_project_1</code>, etc.</p> </li> <li> <code>title</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>An optional title for the Label Studio project. This is the title that annotators will see inside Label Studio. Unlike <code>name</code>, it does not need to be an identifier and does not need to be unique. If not specified, the table name <code>t.name</code> will be used.</p> </li> <li> <code>media_import_method</code>               (<code>Literal['post', 'file', 'url']</code>, default:                   <code>'post'</code> )           \u2013            <p>The method to use when transferring media files to Label Studio:</p> <ul> <li><code>post</code>: Media will be sent to Label Studio via HTTP post. This should generally only be used for     prototyping; due to restrictions in Label Studio, it can only be used with projects that have     just one data field, and does not scale well.</li> <li><code>file</code>: Media will be sent to Label Studio as a file on the local filesystem. This method can be     used if Pixeltable and Label Studio are running on the same host.</li> <li><code>url</code>: Media will be sent to Label Studio as externally accessible URLs. This method cannot be     used with local media files or with media generated by computed columns. The default is <code>post</code>.</li> </ul> </li> <li> <code>col_mapping</code>               (<code>Optional[dict[str, str]]</code>, default:                   <code>None</code> )           \u2013            <p>An optional mapping of local column names to Label Studio fields.</p> </li> <li> <code>sync_immediately</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, immediately perform an initial synchronization by exporting all rows of the table as Label Studio tasks.</p> </li> <li> <code>s3_configuration</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, S3 import storage will be configured for the new project. This can only be used with <code>media_import_method='url'</code>, and if <code>media_import_method='url'</code> and any of the media data is referenced by <code>s3://</code> URLs, then it must be specified in order for such media to display correctly in the Label Studio interface.</p> <p>The items in the <code>s3_configuration</code> dictionary correspond to kwarg parameters of the Label Studio <code>connect_s3_import_storage</code> method, as described in the Label Studio connect_s3_import_storage docs. <code>bucket</code> must be specified; all other parameters are optional. If credentials are not specified explicitly, Pixeltable will attempt to retrieve them from the environment (such as from <code>~/.aws/credentials</code>). If a title is not specified, Pixeltable will use the default <code>'Pixeltable-S3-Import-Storage'</code>. All other parameters use their Label Studio defaults.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments are passed to the <code>start_project</code> method in the Label Studio SDK, as described in the Label Studio start_project docs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SyncStatus</code>           \u2013            <p>A <code>SyncStatus</code> representing the status of any synchronization operations that occurred.</p> </li> </ul> <p>Examples:</p> <p>Create a Label Studio project whose tasks correspond to videos stored in the <code>video_col</code> column of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; config = \"\"\"\n    &lt;View&gt;\n        &lt;Video name=\"video_obj\" value=\"$video_col\"/&gt;\n        &lt;Choices name=\"video-category\" toName=\"video\" showInLine=\"true\"&gt;\n            &lt;Choice value=\"city\"/&gt;\n            &lt;Choice value=\"food\"/&gt;\n            &lt;Choice value=\"sports\"/&gt;\n        &lt;/Choices&gt;\n    &lt;/View&gt;\"\"\"\n    create_label_studio_project(tbl, config)\n</code></pre> <p>Create a Label Studio project with the same configuration, using <code>media_import_method='url'</code>, whose media are stored in an S3 bucket:</p> <pre><code>&gt;&gt;&gt; create_label_studio_project(\n        tbl,\n        config,\n        media_import_method='url',\n        s3_configuration={'bucket': 'my-bucket', 'region_name': 'us-east-2'}\n    )\n</code></pre>"},{"location":"pixeltable/io/#pixeltable.io.export_parquet","title":"export_parquet","text":"<pre><code>export_parquet(\n    table_or_df: Union[Table, DataFrame],\n    parquet_path: Path,\n    partition_size_bytes: int = 100000000,\n    inline_images: bool = False,\n) -&gt; None\n</code></pre> <p>Exports a dataframe's data to one or more Parquet files. Requires pyarrow to be installed.</p> <p>It additionally writes the pixeltable metadata in a json file, which would otherwise not be available in the parquet format.</p> <p>Parameters:</p> <ul> <li> <code>table_or_df</code>           \u2013            <p>Table or Dataframe to export.</p> </li> <li> <code>parquet_path</code>           \u2013            <p>Path to directory to write the parquet files to.</p> </li> <li> <code>partition_size_bytes</code>           \u2013            <p>The maximum target size for each chunk. Default 100_000_000 bytes.</p> </li> <li> <code>inline_images</code>           \u2013            <p>If True, images are stored inline in the parquet file. This is useful             for small images, to be imported as pytorch dataset. But can be inefficient             for large images, and cannot be imported into pixeltable.             If False, will raise an error if the Dataframe has any image column.             Default False.</p> </li> </ul>"},{"location":"pixeltable/io/#pixeltable.io.import_csv","title":"import_csv","text":"<pre><code>import_csv(\n    tbl_name: str,\n    filepath_or_buffer: Union[str, PathLike],\n    schema_overrides: Optional[dict[str, Any]] = None,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\",\n    **kwargs: Any\n) -&gt; Table\n</code></pre> <p>Creates a new base table from a csv file. This is a convenience method and is equivalent to calling <code>import_pandas(table_path, pd.read_csv(filepath_or_buffer, **kwargs), schema=schema)</code>. See the Pandas documentation for <code>read_csv</code> for more details.</p> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A handle to the newly created <code>Table</code>.</p> </li> </ul>"},{"location":"pixeltable/io/#pixeltable.io.import_excel","title":"import_excel","text":"<pre><code>import_excel(\n    tbl_name: str,\n    io: Union[str, PathLike],\n    *,\n    schema_overrides: Optional[dict[str, Any]] = None,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\",\n    **kwargs: Any\n) -&gt; Table\n</code></pre> <p>Creates a new base table from an Excel (.xlsx) file. This is a convenience method and is equivalent to calling <code>import_pandas(table_path, pd.read_excel(io, *args, **kwargs), schema=schema)</code>. See the Pandas documentation for <code>read_excel</code> for more details.</p> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A handle to the newly created <code>Table</code>.</p> </li> </ul>"},{"location":"pixeltable/io/#pixeltable.io.import_huggingface_dataset","title":"import_huggingface_dataset","text":"<pre><code>import_huggingface_dataset(\n    table_path: str,\n    dataset: Union[Dataset, DatasetDict],\n    *,\n    schema_overrides: Optional[dict[str, Any]] = None,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    **kwargs: Any\n) -&gt; Table\n</code></pre> <p>Create a new base table from a Huggingface dataset, or dataset dict with multiple splits.     Requires <code>datasets</code> library to be installed.</p> <p>Parameters:</p> <ul> <li> <code>table_path</code>               (<code>str</code>)           \u2013            <p>Path to the table.</p> </li> <li> <code>dataset</code>               (<code>Union[Dataset, DatasetDict]</code>)           \u2013            <p>Huggingface <code>datasets.Dataset</code> or <code>datasets.DatasetDict</code> to insert into the table.</p> </li> <li> <code>schema_overrides</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, then for each (name, type) pair in <code>schema_overrides</code>, the column with name <code>name</code> will be given type <code>type</code>, instead of being inferred from the <code>Dataset</code> or <code>DatasetDict</code>. The keys in <code>schema_overrides</code> should be the column names of the <code>Dataset</code> or <code>DatasetDict</code> (whether or not they are valid Pixeltable identifiers).</p> </li> <li> <code>primary_key</code>               (<code>Optional[Union[str, list[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>The primary key of the table (see <code>create_table()</code>).</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments to pass to <code>create_table</code>. An argument of <code>column_name_for_split</code> must be provided if the source is a DatasetDict. This column name will contain the split information. If None, no split information will be stored.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A handle to the newly created <code>Table</code>.</p> </li> </ul>"},{"location":"pixeltable/io/#pixeltable.io.import_json","title":"import_json","text":"<pre><code>import_json(\n    tbl_path: str,\n    filepath_or_url: str,\n    *,\n    schema_overrides: Optional[dict[str, Any]] = None,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\",\n    **kwargs: Any\n) -&gt; Table\n</code></pre> <p>Creates a new base table from a JSON file. This is a convenience method and is equivalent to calling <code>import_data(table_path, json.loads(file_contents, **kwargs), ...)</code>, where <code>file_contents</code> is the contents of the specified <code>filepath_or_url</code>.</p> <p>Parameters:</p> <ul> <li> <code>tbl_path</code>               (<code>str</code>)           \u2013            <p>The name of the table to create.</p> </li> <li> <code>filepath_or_url</code>               (<code>str</code>)           \u2013            <p>The path or URL of the JSON file.</p> </li> <li> <code>schema_overrides</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, then columns in <code>schema_overrides</code> will be given the specified types (see <code>import_rows()</code>).</p> </li> <li> <code>primary_key</code>               (<code>Optional[Union[str, list[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>The primary key of the table (see <code>create_table()</code>).</p> </li> <li> <code>num_retained_versions</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of retained versions of the table (see <code>create_table()</code>).</p> </li> <li> <code>comment</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>A comment to attach to the table (see <code>create_table()</code>).</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to <code>json.loads</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A handle to the newly created <code>Table</code>.</p> </li> </ul>"},{"location":"pixeltable/io/#pixeltable.io.import_pandas","title":"import_pandas","text":"<pre><code>import_pandas(\n    tbl_name: str,\n    df: DataFrame,\n    *,\n    schema_overrides: Optional[dict[str, Any]] = None,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\"\n) -&gt; Table\n</code></pre> <p>Creates a new base table from a Pandas <code>DataFrame</code>, with the specified name. The schema of the table will be inferred from the DataFrame.</p> <p>The column names of the new table will be identical to those in the DataFrame, as long as they are valid Pixeltable identifiers. If a column name is not a valid Pixeltable identifier, it will be normalized according to the following procedure: - first replace any non-alphanumeric characters with underscores; - then, preface the result with the letter 'c' if it begins with a number or an underscore; - then, if there are any duplicate column names, suffix the duplicates with '_2', '_3', etc., in column order.</p> <p>Parameters:</p> <ul> <li> <code>tbl_name</code>               (<code>str</code>)           \u2013            <p>The name of the table to create.</p> </li> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>The Pandas <code>DataFrame</code>.</p> </li> <li> <code>schema_overrides</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, then for each (name, type) pair in <code>schema_overrides</code>, the column with name <code>name</code> will be given type <code>type</code>, instead of being inferred from the <code>DataFrame</code>. The keys in <code>schema_overrides</code> should be the column names of the <code>DataFrame</code> (whether or not they are valid Pixeltable identifiers).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A handle to the newly created <code>Table</code>.</p> </li> </ul>"},{"location":"pixeltable/io/#pixeltable.io.import_parquet","title":"import_parquet","text":"<pre><code>import_parquet(\n    table: str,\n    *,\n    parquet_path: str,\n    schema_overrides: Optional[dict[str, Any]] = None,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    **kwargs: Any\n) -&gt; Table\n</code></pre> <p>Creates a new base table from a Parquet file or set of files. Requires pyarrow to be installed.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>str</code>)           \u2013            <p>Fully qualified name of the table to import the data into.</p> </li> <li> <code>parquet_path</code>               (<code>str</code>)           \u2013            <p>Path to an individual Parquet file or directory of Parquet files.</p> </li> <li> <code>schema_overrides</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, then for each (name, type) pair in <code>schema_overrides</code>, the column with name <code>name</code> will be given type <code>type</code>, instead of being inferred from the Parquet dataset. The keys in <code>schema_overrides</code> should be the column names of the Parquet dataset (whether or not they are valid Pixeltable identifiers).</p> </li> <li> <code>primary_key</code>               (<code>Optional[Union[str, list[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>The primary key of the table (see <code>create_table()</code>).</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments to pass to <code>create_table</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A handle to the newly created table.</p> </li> </ul>"},{"location":"pixeltable/io/#pixeltable.io.import_rows","title":"import_rows","text":"<pre><code>import_rows(\n    tbl_path: str,\n    rows: list[dict[str, Any]],\n    *,\n    schema_overrides: Optional[dict[str, Any]] = None,\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\"\n) -&gt; Table\n</code></pre> <p>Creates a new base table from a list of dictionaries. The dictionaries must be of the form <code>{column_name: value, ...}</code>. Pixeltable will attempt to infer the schema of the table from the supplied data, using the most specific type that can represent all the values in a column.</p> <p>If <code>schema_overrides</code> is specified, then for each entry <code>(column_name, type)</code> in <code>schema_overrides</code>, Pixeltable will force the specified column to the specified type (and will not attempt any type inference for that column).</p> <p>All column types of the new table will be nullable unless explicitly specified as non-nullable in <code>schema_overrides</code>.</p> <p>Parameters:</p> <ul> <li> <code>tbl_path</code>               (<code>str</code>)           \u2013            <p>The qualified name of the table to create.</p> </li> <li> <code>rows</code>               (<code>list[dict[str, Any]]</code>)           \u2013            <p>The list of dictionaries to import.</p> </li> <li> <code>schema_overrides</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, then columns in <code>schema_overrides</code> will be given the specified types as described above.</p> </li> <li> <code>primary_key</code>               (<code>Optional[Union[str, list[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>The primary key of the table (see <code>create_table()</code>).</p> </li> <li> <code>num_retained_versions</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The number of retained versions of the table (see <code>create_table()</code>).</p> </li> <li> <code>comment</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>A comment to attach to the table (see <code>create_table()</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A handle to the newly created <code>Table</code>.</p> </li> </ul>"},{"location":"pixeltable/pixeltable/","title":"Pixeltable","text":"<p>Import conventions:</p> <pre><code>import pixeltable as pxt\n</code></pre> <p>Insertable tables, views, and snapshots all have a tabular interface and are generically referred to as \"tables\" below.</p>"},{"location":"pixeltable/pixeltable/#overview","title":"Overview","text":"Table Operations <code>pxt.create_table</code> Create a new (insertable) table <code>pxt.create_view</code> Create a new view <code>pxt.create_snapshot</code> Create a new snapshot <code>pxt.drop_table</code> Delete a table <code>pxt.get_table</code> Get a handle to a table <code>pxt.list_tables</code> List the tables in a directory Directory Operations <code>pxt.create_dir</code> Create a directory <code>pxt.list_dirs</code> List the directories in a directory <code>pxt.drop_dir</code> Remove a directory Misc <code>pxt.configure_logging</code> Configure logging <code>pxt.init</code> Initialize Pixeltable runtime now (if not already initialized) <code>pxt.move</code> Move a schema object to a new directory and/or rename a schema object"},{"location":"pixeltable/pixeltable/#pixeltable","title":"pixeltable","text":""},{"location":"pixeltable/pixeltable/#pixeltable.configure_logging","title":"configure_logging","text":"<pre><code>configure_logging(\n    *,\n    to_stdout: Optional[bool] = None,\n    level: Optional[int] = None,\n    add: Optional[str] = None,\n    remove: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Configure logging.</p> <p>Parameters:</p> <ul> <li> <code>to_stdout</code>               (<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>if True, also log to stdout</p> </li> <li> <code>level</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>default log level</p> </li> <li> <code>add</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>comma-separated list of 'module name:log level' pairs; ex.: add='video:10'</p> </li> <li> <code>remove</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>comma-separated list of module names</p> </li> </ul>"},{"location":"pixeltable/pixeltable/#pixeltable.create_dir","title":"create_dir","text":"<pre><code>create_dir(\n    path: str,\n    if_exists: Literal[\"error\", \"ignore\", \"replace\", \"replace_force\"] = \"error\",\n    parents: bool = False,\n) -&gt; Optional[Dir]\n</code></pre> <p>Create a directory.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the directory.</p> </li> <li> <code>if_exists</code>               (<code>Literal['error', 'ignore', 'replace', 'replace_force']</code>, default:                   <code>'error'</code> )           \u2013            <p>Directive regarding how to handle if the path already exists. Must be one of the following:</p> <ul> <li><code>'error'</code>: raise an error</li> <li><code>'ignore'</code>: do nothing and return the existing directory handle</li> <li><code>'replace'</code>: if the existing directory is empty, drop it and create a new one</li> <li><code>'replace_force'</code>: drop the existing directory and all its children, and create a new one</li> </ul> </li> <li> <code>parents</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create missing parent directories.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Dir]</code>           \u2013            <p>A handle to the newly created directory, or to an already existing directory at the path when <code>if_exists='ignore'</code>. Please note the existing directory may not be empty.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If</p> <ul> <li>the path is invalid, or</li> <li>the path already exists and <code>if_exists='error'</code>, or</li> <li>the path already exists and is not a directory, or</li> <li>an error occurs while attempting to create the directory.</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pxt.create_dir('my_dir')\n</code></pre> <p>Create a subdirectory:</p> <pre><code>&gt;&gt;&gt; pxt.create_dir('my_dir.sub_dir')\n</code></pre> <p>Create a subdirectory only if it does not already exist, otherwise do nothing:</p> <pre><code>&gt;&gt;&gt; pxt.create_dir('my_dir.sub_dir', if_exists='ignore')\n</code></pre> <p>Create a directory and replace if it already exists:</p> <pre><code>&gt;&gt;&gt; pxt.create_dir('my_dir', if_exists='replace_force')\n</code></pre> <p>Create a subdirectory along with its ancestors:</p> <pre><code>&gt;&gt;&gt; pxt.create_dir('parent1.parent2.sub_dir', parents=True)\n</code></pre>"},{"location":"pixeltable/pixeltable/#pixeltable.create_snapshot","title":"create_snapshot","text":"<pre><code>create_snapshot(\n    path_str: str,\n    base: Union[Table, DataFrame],\n    *,\n    additional_columns: Optional[dict[str, Any]] = None,\n    iterator: Optional[tuple[type[ComponentIterator], dict[str, Any]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\",\n    media_validation: Literal[\"on_read\", \"on_write\"] = \"on_write\",\n    if_exists: Literal[\"error\", \"ignore\", \"replace\", \"replace_force\"] = \"error\"\n) -&gt; Optional[Table]\n</code></pre> <p>Create a snapshot of an existing table object (which itself can be a view or a snapshot or a base table).</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>A name for the snapshot; can be either a simple name such as <code>my_snapshot</code>, or a pathname such as <code>dir1.my_snapshot</code>.</p> </li> <li> <code>base</code>               (<code>Union[Table, DataFrame]</code>)           \u2013            <p><code>Table</code> (i.e., table or view or snapshot) or <code>DataFrame</code> to base the snapshot on.</p> </li> <li> <code>additional_columns</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, will add these columns to the snapshot once it is created. The format of the <code>additional_columns</code> parameter is identical to the format of the <code>schema_or_df</code> parameter in <code>create_table</code>.</p> </li> <li> <code>iterator</code>               (<code>Optional[tuple[type[ComponentIterator], dict[str, Any]]]</code>, default:                   <code>None</code> )           \u2013            <p>The iterator to use for this snapshot. If specified, then this snapshot will be a one-to-many view of the base table.</p> </li> <li> <code>num_retained_versions</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of versions of the view to retain.</p> </li> <li> <code>comment</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Optional comment for the snapshot.</p> </li> <li> <code>media_validation</code>               (<code>Literal['on_read', 'on_write']</code>, default:                   <code>'on_write'</code> )           \u2013            <p>Media validation policy for the snapshot.</p> <ul> <li><code>'on_read'</code>: validate media files at query time</li> <li><code>'on_write'</code>: validate media files during insert/update operations</li> </ul> </li> <li> <code>if_exists</code>               (<code>Literal['error', 'ignore', 'replace', 'replace_force']</code>, default:                   <code>'error'</code> )           \u2013            <p>Directive regarding how to handle if the path already exists. Must be one of the following:</p> <ul> <li><code>'error'</code>: raise an error</li> <li><code>'ignore'</code>: do nothing and return the existing snapshot handle</li> <li><code>'replace'</code>: if the existing snapshot has no dependents, drop and replace it with a new one</li> <li><code>'replace_force'</code>: drop the existing snapshot and all its dependents, and create a new one</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Table]</code>           \u2013            <p>A handle to the <code>Table</code> representing the newly created snapshot. Please note the schema or base of the existing snapshot may not match those provided in the call.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>if</p> <ul> <li>the path is invalid, or</li> <li>the path already exists and <code>if_exists='error'</code>, or</li> <li>the path already exists and is not a snapshot, or</li> <li>an error occurs while attempting to create the snapshot.</li> </ul> </li> </ul> <p>Examples:</p> <p>Create a snapshot <code>my_snapshot</code> of a table <code>my_table</code>:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... snapshot = pxt.create_snapshot('my_snapshot', tbl)\n</code></pre> <p>Create a snapshot <code>my_snapshot</code> of a view <code>my_view</code> with additional int column <code>col3</code>, if <code>my_snapshot</code> does not already exist:</p> <pre><code>&gt;&gt;&gt; view = pxt.get_table('my_view')\n... snapshot = pxt.create_snapshot(\n...     'my_snapshot', view, additional_columns={'col3': pxt.Int}, if_exists='ignore'\n... )\n</code></pre> <p>Create a snapshot <code>my_snapshot</code> on a table <code>my_table</code>, and replace any existing snapshot named <code>my_snapshot</code>:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... snapshot = pxt.create_snapshot('my_snapshot', tbl, if_exists='replace_force')\n</code></pre>"},{"location":"pixeltable/pixeltable/#pixeltable.create_table","title":"create_table","text":"<pre><code>create_table(\n    path_str: str,\n    schema: Optional[dict[str, Any]] = None,\n    *,\n    source: Optional[TableDataSource] = None,\n    source_format: Optional[Literal[\"csv\", \"excel\", \"parquet\", \"json\"]] = None,\n    schema_overrides: Optional[dict[str, Any]] = None,\n    on_error: Literal[\"abort\", \"ignore\"] = \"abort\",\n    primary_key: Optional[Union[str, list[str]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\",\n    media_validation: Literal[\"on_read\", \"on_write\"] = \"on_write\",\n    if_exists: Literal[\"error\", \"ignore\", \"replace\", \"replace_force\"] = \"error\",\n    extra_args: Optional[dict[str, Any]] = None\n) -&gt; Table\n</code></pre> <p>Create a new base table.</p> <p>Parameters:</p> <ul> <li> <code>path_str</code>               (<code>str</code>)           \u2013            <p>Path to the table.</p> </li> <li> <code>schema</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary that maps column names to column types</p> </li> <li> <code>source</code>               (<code>Optional[TableDataSource]</code>, default:                   <code>None</code> )           \u2013            <p>A data source from which a table schema can be inferred and data imported</p> </li> <li> <code>source_format</code>               (<code>Optional[Literal['csv', 'excel', 'parquet', 'json']]</code>, default:                   <code>None</code> )           \u2013            <p>A hint to the format of the source data</p> </li> <li> <code>schema_overrides</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, then columns in <code>schema_overrides</code> will be given the specified types</p> </li> <li> <code>on_error</code>               (<code>Literal['abort', 'ignore']</code>, default:                   <code>'abort'</code> )           \u2013            <p>Determines the behavior if an error occurs while evaluating a computed column or detecting an invalid media file (such as a corrupt image) for one of the inserted rows.</p> <ul> <li>If <code>on_error='abort'</code>, then an exception will be raised and the rows will not be inserted.</li> <li>If <code>on_error='ignore'</code>, then execution will continue and the rows will be inserted. Any cells     with errors will have a <code>None</code> value for that cell, with information about the error stored in the     corresponding <code>tbl.col_name.errortype</code> and <code>tbl.col_name.errormsg</code> fields.</li> </ul> </li> <li> <code>primary_key</code>               (<code>Optional[Union[str, list[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>An optional column name or list of column names to use as the primary key(s) of the table.</p> </li> <li> <code>num_retained_versions</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of versions of the table to retain.</p> </li> <li> <code>comment</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>An optional comment; its meaning is user-defined.</p> </li> <li> <code>media_validation</code>               (<code>Literal['on_read', 'on_write']</code>, default:                   <code>'on_write'</code> )           \u2013            <p>Media validation policy for the table.</p> <ul> <li><code>'on_read'</code>: validate media files at query time</li> <li><code>'on_write'</code>: validate media files during insert/update operations</li> </ul> </li> <li> <code>if_exists</code>               (<code>Literal['error', 'ignore', 'replace', 'replace_force']</code>, default:                   <code>'error'</code> )           \u2013            <p>Directive regarding how to handle if the path already exists. Must be one of the following:</p> <ul> <li><code>'error'</code>: raise an error</li> <li><code>'ignore'</code>: do nothing and return the existing table handle</li> <li><code>'replace'</code>: if the existing table has no views, drop and replace it with a new one</li> <li><code>'replace_force'</code>: drop the existing table and all its views, and create a new one</li> </ul> </li> <li> <code>extra_args</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Additional arguments to pass to the source data provider</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A handle to the newly created table, or to an already existing table at the path when <code>if_exists='ignore'</code>. Please note the schema of the existing table may not match the schema provided in the call.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>if</p> <ul> <li>the path is invalid, or</li> <li>the path already exists and <code>if_exists='error'</code>, or</li> <li>the path already exists and is not a table, or</li> <li>an error occurs while attempting to create the table, or</li> <li>an error occurs while attempting to import data from the source.</li> </ul> </li> </ul> <p>Examples:</p> <p>Create a table with an int and a string column:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.create_table('my_table', schema={'col1': pxt.Int, 'col2': pxt.String})\n</code></pre> <p>Create a table from a select statement over an existing table <code>orig_table</code> (this will create a new table containing the exact contents of the query):</p> <pre><code>&gt;&gt;&gt; tbl1 = pxt.get_table('orig_table')\n... tbl2 = pxt.create_table('new_table', tbl1.where(tbl1.col1 &lt; 10).select(tbl1.col2))\n</code></pre> <p>Create a table if does not already exist, otherwise get the existing table:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.create_table('my_table', schema={'col1': pxt.Int, 'col2': pxt.String}, if_exists='ignore')\n</code></pre> <p>Create a table with an int and a float column, and replace any existing table:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.create_table('my_table', schema={'col1': pxt.Int, 'col2': pxt.Float}, if_exists='replace')\n</code></pre> <p>Create a table from a CSV file:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.create_table('my_table', source='data.csv')\n</code></pre>"},{"location":"pixeltable/pixeltable/#pixeltable.create_view","title":"create_view","text":"<pre><code>create_view(\n    path: str,\n    base: Union[Table, DataFrame],\n    *,\n    additional_columns: Optional[dict[str, Any]] = None,\n    is_snapshot: bool = False,\n    iterator: Optional[tuple[type[ComponentIterator], dict[str, Any]]] = None,\n    num_retained_versions: int = 10,\n    comment: str = \"\",\n    media_validation: Literal[\"on_read\", \"on_write\"] = \"on_write\",\n    if_exists: Literal[\"error\", \"ignore\", \"replace\", \"replace_force\"] = \"error\"\n) -&gt; Optional[Table]\n</code></pre> <p>Create a view of an existing table object (which itself can be a view or a snapshot or a base table).</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>A name for the view; can be either a simple name such as <code>my_view</code>, or a pathname such as <code>dir1.my_view</code>.</p> </li> <li> <code>base</code>               (<code>Union[Table, DataFrame]</code>)           \u2013            <p><code>Table</code> (i.e., table or view or snapshot) or <code>DataFrame</code> to base the view on.</p> </li> <li> <code>additional_columns</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, will add these columns to the view once it is created. The format of the <code>additional_columns</code> parameter is identical to the format of the <code>schema_or_df</code> parameter in <code>create_table</code>.</p> </li> <li> <code>is_snapshot</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the view is a snapshot. Setting this to <code>True</code> is equivalent to calling <code>create_snapshot</code>.</p> </li> <li> <code>iterator</code>               (<code>Optional[tuple[type[ComponentIterator], dict[str, Any]]]</code>, default:                   <code>None</code> )           \u2013            <p>The iterator to use for this view. If specified, then this view will be a one-to-many view of the base table.</p> </li> <li> <code>num_retained_versions</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of versions of the view to retain.</p> </li> <li> <code>comment</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Optional comment for the view.</p> </li> <li> <code>media_validation</code>               (<code>Literal['on_read', 'on_write']</code>, default:                   <code>'on_write'</code> )           \u2013            <p>Media validation policy for the view.</p> <ul> <li><code>'on_read'</code>: validate media files at query time</li> <li><code>'on_write'</code>: validate media files during insert/update operations</li> </ul> </li> <li> <code>if_exists</code>               (<code>Literal['error', 'ignore', 'replace', 'replace_force']</code>, default:                   <code>'error'</code> )           \u2013            <p>Directive regarding how to handle if the path already exists. Must be one of the following:</p> <ul> <li><code>'error'</code>: raise an error</li> <li><code>'ignore'</code>: do nothing and return the existing view handle</li> <li><code>'replace'</code>: if the existing view has no dependents, drop and replace it with a new one</li> <li><code>'replace_force'</code>: drop the existing view and all its dependents, and create a new one</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Table]</code>           \u2013            <p>A handle to the <code>Table</code> representing the newly created view. If the path already exists and <code>if_exists='ignore'</code>, returns a handle to the existing view. Please note the schema or the base of the existing view may not match those provided in the call.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>if</p> <ul> <li>the path is invalid, or</li> <li>the path already exists and <code>if_exists='error'</code>, or</li> <li>the path already exists and is not a view, or</li> <li>an error occurs while attempting to create the view.</li> </ul> </li> </ul> <p>Examples:</p> <p>Create a view <code>my_view</code> of an existing table <code>my_table</code>, filtering on rows where <code>col1</code> is greater than 10:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... view = pxt.create_view('my_view', tbl.where(tbl.col1 &gt; 10))\n</code></pre> <p>Create a view <code>my_view</code> of an existing table <code>my_table</code>, filtering on rows where <code>col1</code> is greater than 10, and if it not already exist. Otherwise, get the existing view named <code>my_view</code>:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... view = pxt.create_view('my_view', tbl.where(tbl.col1 &gt; 10), if_exists='ignore')\n</code></pre> <p>Create a view <code>my_view</code> of an existing table <code>my_table</code>, filtering on rows where <code>col1</code> is greater than 100, and replace any existing view named <code>my_view</code>:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... view = pxt.create_view('my_view', tbl.where(tbl.col1 &gt; 100), if_exists='replace_force')\n</code></pre>"},{"location":"pixeltable/pixeltable/#pixeltable.drop_table","title":"drop_table","text":"<pre><code>drop_table(\n    table: Union[str, Table],\n    force: bool = False,\n    if_not_exists: Literal[\"error\", \"ignore\"] = \"error\",\n) -&gt; None\n</code></pre> <p>Drop a table, view, or snapshot.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>Union[str, Table]</code>)           \u2013            <p>Fully qualified name, or handle, of the table to be dropped.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, will also drop all views and sub-views of this table.</p> </li> <li> <code>if_not_exists</code>               (<code>Literal['error', 'ignore']</code>, default:                   <code>'error'</code> )           \u2013            <p>Directive regarding how to handle if the path does not exist. Must be one of the following:</p> <ul> <li><code>'error'</code>: raise an error</li> <li><code>'ignore'</code>: do nothing and return</li> </ul> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>if the qualified name</p> <ul> <li>is invalid, or</li> <li>does not exist and <code>if_not_exists='error'</code>, or</li> <li>does not designate a table object, or</li> <li>designates a table object but has dependents and <code>force=False</code>.</li> </ul> </li> </ul> <p>Examples:</p> <p>Drop a table by its fully qualified name:</p> <pre><code>&gt;&gt;&gt; pxt.drop_table('subdir.my_table')\n</code></pre> <p>Drop a table by its handle:</p> <pre><code>&gt;&gt;&gt; t = pxt.get_table('subdir.my_table')\n... pxt.drop_table(t)\n</code></pre> <p>Drop a table if it exists, otherwise do nothing:</p> <pre><code>&gt;&gt;&gt; pxt.drop_table('subdir.my_table', if_not_exists='ignore')\n</code></pre> <p>Drop a table and all its dependents:</p> <pre><code>&gt;&gt;&gt; pxt.drop_table('subdir.my_table', force=True)\n</code></pre>"},{"location":"pixeltable/pixeltable/#pixeltable.get_table","title":"get_table","text":"<pre><code>get_table(path: str) -&gt; Table\n</code></pre> <p>Get a handle to an existing table, view, or snapshot.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>A handle to the <code>Table</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a table object.</p> </li> </ul> <p>Examples:</p> <p>Get handle for a table in the top-level directory:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n</code></pre> <p>For a table in a subdirectory:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('subdir.my_table')\n</code></pre> <p>Handles to views and snapshots are retrieved in the same way:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_snapshot')\n</code></pre>"},{"location":"pixeltable/pixeltable/#pixeltable.init","title":"init","text":"<pre><code>init() -&gt; None\n</code></pre> <p>Initializes the Pixeltable environment.</p>"},{"location":"pixeltable/pixeltable/#pixeltable.list_tables","title":"list_tables","text":"<pre><code>list_tables(dir_path: str = '', recursive: bool = True) -&gt; list[str]\n</code></pre> <p>List the <code>Table</code>s in a directory.</p> <p>Parameters:</p> <ul> <li> <code>dir_path</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Path to the directory. Defaults to the root directory.</p> </li> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>False</code>, returns only those tables that are directly contained in specified directory; if <code>True</code>, returns all tables that are descendants of the specified directory, recursively.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list of <code>Table</code> paths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path does not exist or does not designate a directory.</p> </li> </ul> <p>Examples:</p> <p>List tables in top-level directory:</p> <pre><code>&gt;&gt;&gt; pxt.list_tables()\n</code></pre> <p>List tables in 'dir1':</p> <pre><code>&gt;&gt;&gt; pxt.list_tables('dir1')\n</code></pre>"},{"location":"pixeltable/pixeltable/#pixeltable.list_dirs","title":"list_dirs","text":"<pre><code>list_dirs(path: str = '', recursive: bool = True) -&gt; list[str]\n</code></pre> <p>List the directories in a directory.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Name or path of the directory.</p> </li> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, lists all descendants of this directory recursively.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of directory paths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If <code>path_str</code> does not exist or does not designate a directory.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cl.list_dirs('my_dir', recursive=True)\n['my_dir', 'my_dir.sub_dir1']\n</code></pre>"},{"location":"pixeltable/pixeltable/#pixeltable.move","title":"move","text":"<pre><code>move(path: str, new_path: str) -&gt; None\n</code></pre> <p>Move a schema object to a new directory and/or rename a schema object.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>absolute path to the existing schema object.</p> </li> <li> <code>new_path</code>               (<code>str</code>)           \u2013            <p>absolute new path for the schema object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If path does not exist or new_path already exists.</p> </li> </ul> <p>Examples:</p> <p>Move a table to a different directory:</p> <pre><code>&gt;&gt;&gt;&gt; pxt.move('dir1.my_table', 'dir2.my_table')\n</code></pre> <p>Rename a table:</p> <pre><code>&gt;&gt;&gt;&gt; pxt.move('dir1.my_table', 'dir1.new_name')\n</code></pre>"},{"location":"pixeltable/pixeltable/#pixeltable.drop_dir","title":"drop_dir","text":"<pre><code>drop_dir(\n    path: str,\n    force: bool = False,\n    if_not_exists: Literal[\"error\", \"ignore\"] = \"error\",\n) -&gt; None\n</code></pre> <p>Remove a directory.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Name or path of the directory.</p> </li> <li> <code>force</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, will also drop all tables and subdirectories of this directory, recursively, along with any views or snapshots that depend on any of the dropped tables.</p> </li> <li> <code>if_not_exists</code>               (<code>Literal['error', 'ignore']</code>, default:                   <code>'error'</code> )           \u2013            <p>Directive regarding how to handle if the path does not exist. Must be one of the following:</p> <ul> <li><code>'error'</code>: raise an error</li> <li><code>'ignore'</code>: do nothing and return</li> </ul> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the path</p> <ul> <li>is invalid, or</li> <li>does not exist and <code>if_not_exists='error'</code>, or</li> <li>is not designate a directory, or</li> <li>is a direcotory but is not empty and <code>force=False</code>.</li> </ul> </li> </ul> <p>Examples:</p> <p>Remove a directory, if it exists and is empty:</p> <pre><code>&gt;&gt;&gt; pxt.drop_dir('my_dir')\n</code></pre> <p>Remove a subdirectory:</p> <pre><code>&gt;&gt;&gt; pxt.drop_dir('my_dir.sub_dir')\n</code></pre> <p>Remove an existing directory if it is empty, but do nothing if it does not exist:</p> <pre><code>&gt;&gt;&gt; pxt.drop_dir('my_dir.sub_dir', if_not_exists='ignore')\n</code></pre> <p>Remove an existing directory and all its contents:</p> <pre><code>&gt;&gt;&gt; pxt.drop_dir('my_dir', force=True)\n</code></pre>"},{"location":"pixeltable/table/","title":"Table","text":"<p>Instances of class <code>Table</code> are handles to Pixeltable tables and views/snapshots.</p> <p>Use this handle to query and update the table and to add and drop columns.</p> <p>Tables are created by calling <code>pxt.create_table</code>. Views are created by calling <code>pxt.create_view</code>, and snapshots by calling <code>pxt.create_snapshot</code>.</p> <p>To get a handle to an existing table/view/snapshot, call <code>pxt.get_table</code>.</p>"},{"location":"pixeltable/table/#overview","title":"Overview","text":"Column Operations <code>add_column</code> Add a column to the table or view <code>drop_column</code> Remove a column from the table or view <code>rename_column</code> Rename a column Data Operations <code>insert</code> Insert rows into table <code>update</code> Update rows in table or view <code>delete</code> Delete rows from table Indexing Operations <code>add_embedding_index</code> Add embedding index on column <code>drop_embedding_index</code> Drop embedding index from column <code>drop_index</code> Drop index from column Versioning <code>revert</code> Revert the last change"},{"location":"pixeltable/table/#pixeltable.Table","title":"pixeltable.Table","text":"<pre><code>Table(id: UUID, dir_id: UUID, name: str, tbl_version_path: TableVersionPath)\n</code></pre> <p>A handle to a table, view, or snapshot. This class is the primary interface through which table operations (queries, insertions, updates, etc.) are performed in Pixeltable.</p> <p>Every user-invoked operation that runs an ExecNode tree (directly or indirectly) needs to call FileCache.emit_eviction_warnings() at the end of the operation.</p>"},{"location":"pixeltable/table/#pixeltable.Table.add_column","title":"add_column","text":"<pre><code>add_column(\n    *,\n    if_exists: Literal[\"error\", \"ignore\", \"replace\", \"replace_force\"] = \"error\",\n    **kwargs: Union[ColumnType, type, _GenericAlias, Expr]\n) -&gt; UpdateStatus\n</code></pre> <p>Adds an ordinary (non-computed) column to the table.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Union[ColumnType, type, _GenericAlias, Expr]</code>, default:                   <code>{}</code> )           \u2013            <p>Exactly one keyword argument of the form <code>col_name=col_type</code>.</p> </li> <li> <code>if_exists</code>               (<code>Literal['error', 'ignore', 'replace', 'replace_force']</code>, default:                   <code>'error'</code> )           \u2013            <p>Determines the behavior if the column already exists. Must be one of the following:</p> <ul> <li><code>'error'</code>: an exception will be raised.</li> <li><code>'ignore'</code>: do nothing and return.</li> <li><code>'replace' or 'replace_force'</code>: drop the existing column and add the new column, if it has     no dependents.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>           \u2013            <p>Information about the execution status of the operation.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column name is invalid, or already exists and <code>if_exists='erorr'</code>, or <code>if_exists='replace*'</code> but the column has dependents or is a basetable column.</p> </li> </ul> <p>Examples:</p> <p>Add an int column:</p> <pre><code>&gt;&gt;&gt; tbl.add_column(new_col=pxt.Int)\n</code></pre> <p>Alternatively, this can also be expressed as:</p> <pre><code>&gt;&gt;&gt; tbl.add_columns({'new_col': pxt.Int})\n</code></pre>"},{"location":"pixeltable/table/#pixeltable.Table.add_columns","title":"add_columns","text":"<pre><code>add_columns(\n    schema: dict[str, Union[ColumnType, type, _GenericAlias]],\n    if_exists: Literal[\"error\", \"ignore\", \"replace\", \"replace_force\"] = \"error\",\n) -&gt; UpdateStatus\n</code></pre> <p>Adds multiple columns to the table. The columns must be concrete (non-computed) columns; to add computed columns, use <code>add_computed_column()</code> instead.</p> <p>The format of the <code>schema</code> argument is identical to the format of the schema in a call to <code>create_table()</code>.</p> <p>Parameters:</p> <ul> <li> <code>schema</code>               (<code>dict[str, Union[ColumnType, type, _GenericAlias]]</code>)           \u2013            <p>A dictionary mapping column names to types.</p> </li> <li> <code>if_exists</code>               (<code>Literal['error', 'ignore', 'replace', 'replace_force']</code>, default:                   <code>'error'</code> )           \u2013            <p>Determines the behavior if a column already exists. Must be one of the following:</p> <ul> <li><code>'error'</code>: an exception will be raised.</li> <li><code>'ignore'</code>: do nothing and return.</li> <li><code>'replace' or 'replace_force'</code>: drop the existing column and add the new column, if it has no     dependents.</li> </ul> <p>Note that the <code>if_exists</code> parameter is applied to all columns in the schema. To apply different behaviors to different columns, please use <code>add_column()</code> for each column.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>           \u2013            <p>Information about the execution status of the operation.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If any column name is invalid, or already exists and <code>if_exists='error'</code>, or <code>if_exists='replace*'</code> but the column has dependents or is a basetable column.</p> </li> </ul> <p>Examples:</p> <p>Add multiple columns to the table <code>my_table</code>:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... schema = {\n...     'new_col_1': pxt.Int,\n...     'new_col_2': pxt.String,\n... }\n... tbl.add_columns(schema)\n</code></pre>"},{"location":"pixeltable/table/#pixeltable.Table.add_computed_column","title":"add_computed_column","text":"<pre><code>add_computed_column(\n    *,\n    stored: Optional[bool] = None,\n    print_stats: bool = False,\n    on_error: Literal[\"abort\", \"ignore\"] = \"abort\",\n    if_exists: Literal[\"error\", \"ignore\", \"replace\"] = \"error\",\n    **kwargs: Expr\n) -&gt; UpdateStatus\n</code></pre> <p>Adds a computed column to the table.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>Expr</code>, default:                   <code>{}</code> )           \u2013            <p>Exactly one keyword argument of the form <code>col_name=expression</code>.</p> </li> <li> <code>stored</code>               (<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>Whether the column is materialized and stored or computed on demand.</p> </li> <li> <code>print_stats</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, print execution metrics during evaluation.</p> </li> <li> <code>on_error</code>               (<code>Literal['abort', 'ignore']</code>, default:                   <code>'abort'</code> )           \u2013            <p>Determines the behavior if an error occurs while evaluating the column expression for at least one row.</p> <ul> <li><code>'abort'</code>: an exception will be raised and the column will not be added.</li> <li><code>'ignore'</code>: execution will continue and the column will be added. Any rows     with errors will have a <code>None</code> value for the column, with information about the error stored in the     corresponding <code>tbl.col_name.errortype</code> and <code>tbl.col_name.errormsg</code> fields.</li> </ul> </li> <li> <code>if_exists</code>               (<code>Literal['error', 'ignore', 'replace']</code>, default:                   <code>'error'</code> )           \u2013            <p>Determines the behavior if the column already exists. Must be one of the following:</p> <ul> <li><code>'error'</code>: an exception will be raised.</li> <li><code>'ignore'</code>: do nothing and return.</li> <li><code>'replace' or 'replace_force'</code>: drop the existing column and add the new column, iff it has     no dependents.</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>           \u2013            <p>Information about the execution status of the operation.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column name is invalid or already exists and <code>if_exists='error'</code>, or <code>if_exists='replace*'</code> but the column has dependents or is a basetable column.</p> </li> </ul> <p>Examples:</p> <p>For a table with an image column <code>frame</code>, add an image column <code>rotated</code> that rotates the image by 90 degrees:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(rotated=tbl.frame.rotate(90))\n</code></pre> <p>Do the same, but now the column is unstored:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(rotated=tbl.frame.rotate(90), stored=False)\n</code></pre>"},{"location":"pixeltable/table/#pixeltable.Table.add_embedding_index","title":"add_embedding_index","text":"<pre><code>add_embedding_index(\n    column: Union[str, ColumnRef],\n    *,\n    idx_name: Optional[str] = None,\n    embedding: Optional[Function] = None,\n    string_embed: Optional[Function] = None,\n    image_embed: Optional[Function] = None,\n    metric: str = \"cosine\",\n    if_exists: Literal[\"error\", \"ignore\", \"replace\", \"replace_force\"] = \"error\"\n) -&gt; None\n</code></pre> <p>Add an embedding index to the table. Once the index is created, it will be automatically kept up-to-date as new rows are inserted into the table.</p> <p>To add an embedding index, one must specify, at minimum, the column to be indexed and an embedding UDF. Only <code>String</code> and <code>Image</code> columns are currently supported. Here's an example that uses a CLIP embedding to index an image column:</p> <p>from pixeltable.functions.huggingface import clip ... embedding_fn = clip.using(model_id='openai/clip-vit-base-patch32') ... tbl.add_embedding_index(tbl.img, embedding=embedding_fn)</p> <p>Once the index is created, similiarity lookups can be performed using the <code>similarity</code> pseudo-function.</p> <p>reference_img = PIL.Image.open('my_image.jpg') ... sim = tbl.img.similarity(reference_img) ... tbl.select(tbl.img, sim).order_by(sim, asc=False).limit(5)</p> <p>If the embedding UDF is a multimodal embedding (supporting more than one data type), then lookups may be performed using any of its supported types. In our example, CLIP supports both text and images, so we can also search for images using a text description:</p> <p>sim = tbl.img.similarity('a picture of a train') ... tbl.select(tbl.img, sim).order_by(sim, asc=False).limit(5)</p> <p>Parameters:</p> <ul> <li> <code>column</code>               (<code>Union[str, ColumnRef]</code>)           \u2013            <p>The name of, or reference to, the column to be indexed; must be a <code>String</code> or <code>Image</code> column.</p> </li> <li> <code>idx_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>An optional name for the index. If not specified, a name such as <code>'idx0'</code> will be generated automatically. If specified, the name must be unique for this table and a valid pixeltable column name.</p> </li> <li> <code>embedding</code>               (<code>Optional[Function]</code>, default:                   <code>None</code> )           \u2013            <p>The UDF to use for the embedding. Must be a UDF that accepts a single argument of type <code>String</code> or <code>Image</code> (as appropriate for the column being indexed) and returns a fixed-size 1-dimensional array of floats.</p> </li> <li> <code>string_embed</code>               (<code>Optional[Function]</code>, default:                   <code>None</code> )           \u2013            <p>An optional UDF to use for the string embedding component of this index. Can be used in conjunction with <code>image_embed</code> to construct multimodal embeddings manually, by specifying different embedding functions for different data types.</p> </li> <li> <code>image_embed</code>               (<code>Optional[Function]</code>, default:                   <code>None</code> )           \u2013            <p>An optional UDF to use for the image embedding component of this index. Can be used in conjunction with <code>string_embed</code> to construct multimodal embeddings manually, by specifying different embedding functions for different data types.</p> </li> <li> <code>metric</code>               (<code>str</code>, default:                   <code>'cosine'</code> )           \u2013            <p>Distance metric to use for the index; one of <code>'cosine'</code>, <code>'ip'</code>, or <code>'l2'</code>. The default is <code>'cosine'</code>.</p> </li> <li> <code>if_exists</code>               (<code>Literal['error', 'ignore', 'replace', 'replace_force']</code>, default:                   <code>'error'</code> )           \u2013            <p>Directive for handling an existing index with the same name. Must be one of the following:</p> <ul> <li><code>'error'</code>: raise an error if an index with the same name already exists.</li> <li><code>'ignore'</code>: do nothing if an index with the same name already exists.</li> <li><code>'replace'</code> or <code>'replace_force'</code>: replace the existing index with the new one.</li> </ul> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If an index with the specified name already exists for the table and <code>if_exists='error'</code>, or if the specified column does not exist.</p> </li> </ul> <p>Examples:</p> <p>Add an index to the <code>img</code> column of the table <code>my_table</code>:</p> <pre><code>&gt;&gt;&gt; from pixeltable.functions.huggingface import clip\n... tbl = pxt.get_table('my_table')\n... embedding_fn = clip.using(model_id='openai/clip-vit-base-patch32')\n... tbl.add_embedding_index(tbl.img, embedding=embedding_fn)\n</code></pre> <p>Alternatively, the <code>img</code> column may be specified by name:</p> <pre><code>&gt;&gt;&gt; tbl.add_embedding_index('img', embedding=embedding_fn)\n</code></pre> <p>Add a second index to the <code>img</code> column, using the inner product as the distance metric, and with a specific name:</p> <pre><code>&gt;&gt;&gt; tbl.add_embedding_index(\n...     tbl.img,\n...     idx_name='ip_idx',\n...     embedding=embedding_fn,\n...     metric='ip'\n... )\n</code></pre> <p>Add an index using separately specified string and image embeddings:</p> <pre><code>&gt;&gt;&gt; tbl.add_embedding_index(\n...     tbl.img,\n...     string_embed=string_embedding_fn,\n...     image_embed=image_embedding_fn\n... )\n</code></pre>"},{"location":"pixeltable/table/#pixeltable.Table.batch_update","title":"batch_update","text":"<pre><code>batch_update(\n    rows: Iterable[dict[str, Any]],\n    cascade: bool = True,\n    if_not_exists: Literal[\"error\", \"ignore\", \"insert\"] = \"error\",\n) -&gt; UpdateStatus\n</code></pre> <p>Update rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>rows</code>               (<code>Iterable[dict[str, Any]]</code>)           \u2013            <p>an Iterable of dictionaries containing values for the updated columns plus values for the primary key   columns.</p> </li> <li> <code>cascade</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, also update all computed columns that transitively depend on the updated columns.</p> </li> <li> <code>if_not_exists</code>               (<code>Literal['error', 'ignore', 'insert']</code>, default:                   <code>'error'</code> )           \u2013            <p>Specifies the behavior if a row to update does not exist:</p> <ul> <li><code>'error'</code>: Raise an error.</li> <li><code>'ignore'</code>: Skip the row silently.</li> <li><code>'insert'</code>: Insert the row.</li> </ul> </li> </ul> <p>Examples:</p> <p>Update the <code>name</code> and <code>age</code> columns for the rows with ids 1 and 2 (assuming <code>id</code> is the primary key). If either row does not exist, this raises an error:</p> <pre><code>&gt;&gt;&gt; tbl.update([{'id': 1, 'name': 'Alice', 'age': 30}, {'id': 2, 'name': 'Bob', 'age': 40}])\n</code></pre> <p>Update the <code>name</code> and <code>age</code> columns for the row with <code>id</code> 1 (assuming <code>id</code> is the primary key) and insert the row with new <code>id</code> 3 (assuming this key does not exist):</p> <pre><code>&gt;&gt;&gt; tbl.update(\n    [{'id': 1, 'name': 'Alice', 'age': 30}, {'id': 3, 'name': 'Bob', 'age': 40}],\n    if_not_exists='insert')\n</code></pre>"},{"location":"pixeltable/table/#pixeltable.Table.collect","title":"collect","text":"<pre><code>collect() -&gt; 'pxt.dataframe.DataFrameResultSet'\n</code></pre> <p>Return rows from this table.</p>"},{"location":"pixeltable/table/#pixeltable.Table.columns","title":"columns","text":"<pre><code>columns() -&gt; list[str]\n</code></pre> <p>Return the names of the columns in this table.</p>"},{"location":"pixeltable/table/#pixeltable.Table.count","title":"count","text":"<pre><code>count() -&gt; int\n</code></pre> <p>Return the number of rows in this table.</p>"},{"location":"pixeltable/table/#pixeltable.Table.delete","title":"delete","text":"<pre><code>delete(where: Optional['exprs.Expr'] = None) -&gt; UpdateStatus\n</code></pre> <p>Delete rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>where</code>               (<code>Optional['exprs.Expr']</code>, default:                   <code>None</code> )           \u2013            <p>a predicate to filter rows to delete.</p> </li> </ul> <p>Examples:</p> <p>Delete all rows in a table:</p> <pre><code>&gt;&gt;&gt; tbl.delete()\n</code></pre> <p>Delete all rows in a table where column <code>a</code> is greater than 5:</p> <pre><code>&gt;&gt;&gt; tbl.delete(tbl.a &gt; 5)\n</code></pre>"},{"location":"pixeltable/table/#pixeltable.Table.describe","title":"describe","text":"<pre><code>describe() -&gt; None\n</code></pre> <p>Print the table schema.</p>"},{"location":"pixeltable/table/#pixeltable.Table.distinct","title":"distinct","text":"<pre><code>distinct() -&gt; 'pxt.DataFrame'\n</code></pre> <p>Remove duplicate rows from table.</p>"},{"location":"pixeltable/table/#pixeltable.Table.drop_column","title":"drop_column","text":"<pre><code>drop_column(\n    column: Union[str, ColumnRef],\n    if_not_exists: Literal[\"error\", \"ignore\"] = \"error\",\n) -&gt; None\n</code></pre> <p>Drop a column from the table.</p> <p>Parameters:</p> <ul> <li> <code>column</code>               (<code>Union[str, ColumnRef]</code>)           \u2013            <p>The name or reference of the column to drop.</p> </li> <li> <code>if_not_exists</code>               (<code>Literal['error', 'ignore']</code>, default:                   <code>'error'</code> )           \u2013            <p>Directive for handling a non-existent column. Must be one of the following:</p> <ul> <li><code>'error'</code>: raise an error if the column does not exist.</li> <li><code>'ignore'</code>: do nothing if the column does not exist.</li> </ul> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column does not exist and <code>if_exists='error'</code>, or if it is referenced by a dependent computed column.</p> </li> </ul> <p>Examples:</p> <p>Drop the column <code>col</code> from the table <code>my_table</code> by column name:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... tbl.drop_column('col')\n</code></pre> <p>Drop the column <code>col</code> from the table <code>my_table</code> by column reference:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... tbl.drop_column(tbl.col)\n</code></pre> <p>Drop the column <code>col</code> from the table <code>my_table</code> if it exists, otherwise do nothing:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... tbl.drop_col(tbl.col, if_not_exists='ignore')\n</code></pre>"},{"location":"pixeltable/table/#pixeltable.Table.drop_embedding_index","title":"drop_embedding_index","text":"<pre><code>drop_embedding_index(\n    *,\n    column: Union[str, ColumnRef, None] = None,\n    idx_name: Optional[str] = None,\n    if_not_exists: Literal[\"error\", \"ignore\"] = \"error\"\n) -&gt; None\n</code></pre> <p>Drop an embedding index from the table. Either a column name or an index name (but not both) must be specified. If a column name or reference is specified, it must be a column containing exactly one embedding index; otherwise the specific index name must be provided instead.</p> <p>Parameters:</p> <ul> <li> <code>column</code>               (<code>Union[str, ColumnRef, None]</code>, default:                   <code>None</code> )           \u2013            <p>The name of, or reference to, the column from which to drop the index.     The column must have only one embedding index.</p> </li> <li> <code>idx_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the index to drop.</p> </li> <li> <code>if_not_exists</code>               (<code>Literal['error', 'ignore']</code>, default:                   <code>'error'</code> )           \u2013            <p>Directive for handling a non-existent index. Must be one of the following:</p> <ul> <li><code>'error'</code>: raise an error if the index does not exist.</li> <li><code>'ignore'</code>: do nothing if the index does not exist.</li> </ul> <p>Note that <code>if_not_exists</code> parameter is only applicable when an <code>idx_name</code> is specified and it does not exist, or when <code>column</code> is specified and it has no index. <code>if_not_exists</code> does not apply to non-exisitng column.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If <code>column</code> is specified, but the column does not exist, or it contains no embedding indices and <code>if_not_exists='error'</code>, or the column has multiple embedding indices.</p> </li> <li> <code>Error</code>             \u2013            <p>If <code>idx_name</code> is specified, but the index is not an embedding index, or the index does not exist and <code>if_not_exists='error'</code>.</p> </li> </ul> <p>Examples:</p> <p>Drop the embedding index on the <code>img</code> column of the table <code>my_table</code> by column name:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... tbl.drop_embedding_index(column='img')\n</code></pre> <p>Drop the embedding index on the <code>img</code> column of the table <code>my_table</code> by column reference:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... tbl.drop_embedding_index(column=tbl.img)\n</code></pre> <p>Drop the embedding index <code>idx1</code> of the table <code>my_table</code> by index name:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... tbl.drop_embedding_index(idx_name='idx1')\n</code></pre> <p>Drop the embedding index <code>idx1</code> of the table <code>my_table</code> by index name, if it exists, otherwise do nothing:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... tbl.drop_embedding_index(idx_name='idx1', if_not_exists='ignore')\n</code></pre>"},{"location":"pixeltable/table/#pixeltable.Table.drop_index","title":"drop_index","text":"<pre><code>drop_index(\n    *,\n    column: Union[str, ColumnRef, None] = None,\n    idx_name: Optional[str] = None,\n    if_not_exists: Literal[\"error\", \"ignore\"] = \"error\"\n) -&gt; None\n</code></pre> <p>Drop an index from the table. Either a column name or an index name (but not both) must be specified. If a column name or reference is specified, it must be a column containing exactly one index; otherwise the specific index name must be provided instead.</p> <p>Parameters:</p> <ul> <li> <code>column</code>               (<code>Union[str, ColumnRef, None]</code>, default:                   <code>None</code> )           \u2013            <p>The name of, or reference to, the column from which to drop the index.     The column must have only one embedding index.</p> </li> <li> <code>idx_name</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The name of the index to drop.</p> </li> <li> <code>if_not_exists</code>               (<code>Literal['error', 'ignore']</code>, default:                   <code>'error'</code> )           \u2013            <p>Directive for handling a non-existent index. Must be one of the following:</p> <ul> <li><code>'error'</code>: raise an error if the index does not exist.</li> <li><code>'ignore'</code>: do nothing if the index does not exist.</li> </ul> <p>Note that <code>if_not_exists</code> parameter is only applicable when an <code>idx_name</code> is specified and it does not exist, or when <code>column</code> is specified and it has no index. <code>if_not_exists</code> does not apply to non-exisitng column.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If <code>column</code> is specified, but the column does not exist, or it contains no indices or multiple indices.</p> </li> <li> <code>Error</code>             \u2013            <p>If <code>idx_name</code> is specified, but the index does not exist.</p> </li> </ul> <p>Examples:</p> <p>Drop the index on the <code>img</code> column of the table <code>my_table</code> by column name:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... tbl.drop_index(column_name='img')\n</code></pre> <p>Drop the index on the <code>img</code> column of the table <code>my_table</code> by column reference:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... tbl.drop_index(tbl.img)\n</code></pre> <p>Drop the index <code>idx1</code> of the table <code>my_table</code> by index name:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... tbl.drop_index(idx_name='idx1')\n</code></pre> <p>Drop the index <code>idx1</code> of the table <code>my_table</code> by index name, if it exists, otherwise do nothing:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... tbl.drop_index(idx_name='idx1', if_not_exists='ignore')\n</code></pre>"},{"location":"pixeltable/table/#pixeltable.Table.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata() -&gt; dict[str, Any]\n</code></pre> <p>Retrieves metadata associated with this table.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A dictionary containing the metadata, in the following format:</p> <pre><code>{\n    'base': None,  # If this is a view or snapshot, will contain the name of its base table\n    'schema': {\n        'col1': StringType(),\n        'col2': IntType(),\n    },\n    'is_replica': False,\n    'version': 22,\n    'schema_version': 1,\n    'comment': '',\n    'num_retained_versions': 10,\n    'is_view': False,\n    'is_snapshot': False,\n    'media_validation': 'on_write',\n}\n</code></pre> </li> </ul>"},{"location":"pixeltable/table/#pixeltable.Table.group_by","title":"group_by","text":"<pre><code>group_by(*items: 'exprs.Expr') -&gt; 'pxt.DataFrame'\n</code></pre> <p>Group the rows of this table based on the expression.</p> <p>See <code>DataFrame.group_by</code> for more details.</p>"},{"location":"pixeltable/table/#pixeltable.Table.head","title":"head","text":"<pre><code>head(*args: Any, **kwargs: Any) -&gt; 'pxt.dataframe.DataFrameResultSet'\n</code></pre> <p>Return the first n rows inserted into this table.</p>"},{"location":"pixeltable/table/#pixeltable.Table.insert","title":"insert  <code>abstractmethod</code>","text":"<pre><code>insert(\n    source: Optional[TableDataSource] = None,\n    /,\n    *,\n    source_format: Optional[Literal[\"csv\", \"excel\", \"parquet\", \"json\"]] = None,\n    schema_overrides: Optional[dict[str, ColumnType]] = None,\n    on_error: Literal[\"abort\", \"ignore\"] = \"abort\",\n    print_stats: bool = False,\n    **kwargs: Any,\n) -&gt; UpdateStatus\n</code></pre> <p>Inserts rows into this table. There are two mutually exclusive call patterns:</p> <p>To insert multiple rows at a time:</p> <p><code>python insert(     source: TableSourceDataType,     /,     *,     on_error: Literal['abort', 'ignore'] = 'abort',     print_stats: bool = False,     **kwargs: Any, )</code></p> <p>To insert just a single row, you can use the more concise syntax:</p> <p><code>python insert(     *,     on_error: Literal['abort', 'ignore'] = 'abort',     print_stats: bool = False,     **kwargs: Any )</code></p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>Optional[TableDataSource]</code>, default:                   <code>None</code> )           \u2013            <p>A data source from which data can be imported.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>(if inserting a single row) Keyword-argument pairs representing column names and values. (if inserting multiple rows) Additional keyword arguments are passed to the data source.</p> </li> <li> <code>source_format</code>               (<code>Optional[Literal['csv', 'excel', 'parquet', 'json']]</code>, default:                   <code>None</code> )           \u2013            <p>A hint about the format of the source data</p> </li> <li> <code>schema_overrides</code>               (<code>Optional[dict[str, ColumnType]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, then columns in <code>schema_overrides</code> will be given the specified types</p> </li> <li> <code>on_error</code>               (<code>Literal['abort', 'ignore']</code>, default:                   <code>'abort'</code> )           \u2013            <p>Determines the behavior if an error occurs while evaluating a computed column or detecting an invalid media file (such as a corrupt image) for one of the inserted rows.</p> <ul> <li>If <code>on_error='abort'</code>, then an exception will be raised and the rows will not be inserted.</li> <li>If <code>on_error='ignore'</code>, then execution will continue and the rows will be inserted. Any cells     with errors will have a <code>None</code> value for that cell, with information about the error stored in the     corresponding <code>tbl.col_name.errortype</code> and <code>tbl.col_name.errormsg</code> fields.</li> </ul> </li> <li> <code>print_stats</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, print statistics about the cost of computed columns.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>UpdateStatus</code>           \u2013            <p>An <code>UpdateStatus</code> object containing information about the update.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If one of the following conditions occurs:</p> <ul> <li>The table is a view or snapshot.</li> <li>The table has been dropped.</li> <li>One of the rows being inserted does not conform to the table schema.</li> <li>An error occurs during processing of computed columns, and <code>on_error='ignore'</code>.</li> <li>An error occurs while importing data from a source, and <code>on_error='abort'</code>.</li> </ul> </li> </ul> <p>Examples:</p> <p>Insert two rows into the table <code>my_table</code> with three int columns <code>a</code>, <code>b</code>, and <code>c</code>. Column <code>c</code> is nullable:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... tbl.insert([{'a': 1, 'b': 1, 'c': 1}, {'a': 2, 'b': 2}])\n</code></pre> <p>Insert a single row using the alternative syntax:</p> <pre><code>&gt;&gt;&gt; tbl.insert(a=3, b=3, c=3)\n</code></pre> <p>Insert rows from a CSV file:</p> <pre><code>&gt;&gt;&gt; tbl.insert(source='path/to/file.csv')\n</code></pre>"},{"location":"pixeltable/table/#pixeltable.Table.join","title":"join","text":"<pre><code>join(\n    other: \"Table\",\n    *,\n    on: Optional[\"exprs.Expr\"] = None,\n    how: \"pixeltable.plan.JoinType.LiteralType\" = \"inner\"\n) -&gt; \"pxt.DataFrame\"\n</code></pre> <p>Join this table with another table.</p>"},{"location":"pixeltable/table/#pixeltable.Table.list_views","title":"list_views","text":"<pre><code>list_views(*, recursive: bool = True) -&gt; list[str]\n</code></pre> <p>Returns a list of all views and snapshots of this <code>Table</code>.</p> <p>Parameters:</p> <ul> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>False</code>, returns only the immediate successor views of this <code>Table</code>. If <code>True</code>, returns all sub-views (including views of views, etc.)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>A list of view paths.</p> </li> </ul>"},{"location":"pixeltable/table/#pixeltable.Table.order_by","title":"order_by","text":"<pre><code>order_by(*items: 'exprs.Expr', asc: bool = True) -&gt; 'pxt.DataFrame'\n</code></pre> <p>Order the rows of this table based on the expression.</p> <p>See <code>DataFrame.order_by</code> for more details.</p>"},{"location":"pixeltable/table/#pixeltable.Table.rename_column","title":"rename_column","text":"<pre><code>rename_column(old_name: str, new_name: str) -&gt; None\n</code></pre> <p>Rename a column.</p> <p>Parameters:</p> <ul> <li> <code>old_name</code>               (<code>str</code>)           \u2013            <p>The current name of the column.</p> </li> <li> <code>new_name</code>               (<code>str</code>)           \u2013            <p>The new name of the column.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Error</code>             \u2013            <p>If the column does not exist, or if the new name is invalid or already exists.</p> </li> </ul> <p>Examples:</p> <p>Rename the column <code>col1</code> to <code>col2</code> of the table <code>my_table</code>:</p> <pre><code>&gt;&gt;&gt; tbl = pxt.get_table('my_table')\n... tbl.rename_column('col1', 'col2')\n</code></pre>"},{"location":"pixeltable/table/#pixeltable.Table.revert","title":"revert","text":"<pre><code>revert() -&gt; None\n</code></pre> <p>Reverts the table to the previous version.</p> <p>.. warning::     This operation is irreversible.</p>"},{"location":"pixeltable/table/#pixeltable.Table.sample","title":"sample","text":"<pre><code>sample(\n    n: Optional[int] = None,\n    n_per_stratum: Optional[int] = None,\n    fraction: Optional[float] = None,\n    seed: Optional[int] = None,\n    stratify_by: Any = None,\n) -&gt; DataFrame\n</code></pre> <p>Choose a shuffled sample of rows</p> <p>See <code>DataFrame.sample</code> for more details.</p>"},{"location":"pixeltable/table/#pixeltable.Table.select","title":"select","text":"<pre><code>select(*items: Any, **named_items: Any) -&gt; 'pxt.DataFrame'\n</code></pre> <p>Select columns or expressions from this table.</p> <p>See <code>DataFrame.select</code> for more details.</p>"},{"location":"pixeltable/table/#pixeltable.Table.show","title":"show","text":"<pre><code>show(*args: Any, **kwargs: Any) -&gt; 'pxt.dataframe.DataFrameResultSet'\n</code></pre> <p>Return rows from this table.</p>"},{"location":"pixeltable/table/#pixeltable.Table.sync","title":"sync","text":"<pre><code>sync(\n    stores: Optional[str | list[str]] = None,\n    *,\n    export_data: bool = True,\n    import_data: bool = True\n) -&gt; \"pxt.io.SyncStatus\"\n</code></pre> <p>Synchronizes this table with its linked external stores.</p> <p>Parameters:</p> <ul> <li> <code>stores</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, will synchronize only the specified named store or list of stores. If not specified, will synchronize all of this table's external stores.</p> </li> <li> <code>export_data</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, data from this table will be exported to the external stores during synchronization.</p> </li> <li> <code>import_data</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, data from the external stores will be imported to this table during synchronization.</p> </li> </ul>"},{"location":"pixeltable/table/#pixeltable.Table.tail","title":"tail","text":"<pre><code>tail(*args: Any, **kwargs: Any) -&gt; 'pxt.dataframe.DataFrameResultSet'\n</code></pre> <p>Return the last n rows inserted into this table.</p>"},{"location":"pixeltable/table/#pixeltable.Table.to_coco_dataset","title":"to_coco_dataset","text":"<pre><code>to_coco_dataset() -&gt; Path\n</code></pre> <p>Return the path to a COCO json file for this table. See DataFrame.to_coco_dataset()</p>"},{"location":"pixeltable/table/#pixeltable.Table.to_pytorch_dataset","title":"to_pytorch_dataset","text":"<pre><code>to_pytorch_dataset(\n    image_format: str = \"pt\",\n) -&gt; \"torch.utils.data.IterableDataset\"\n</code></pre> <p>Return a PyTorch Dataset for this table. See DataFrame.to_pytorch_dataset()</p>"},{"location":"pixeltable/table/#pixeltable.Table.unlink_external_stores","title":"unlink_external_stores","text":"<pre><code>unlink_external_stores(\n    stores: Optional[str | list[str]] = None,\n    *,\n    delete_external_data: bool = False,\n    ignore_errors: bool = False\n) -&gt; None\n</code></pre> <p>Unlinks this table's external stores.</p> <p>Parameters:</p> <ul> <li> <code>stores</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, will unlink only the specified named store or list of stores. If not specified, will unlink all of this table's external stores.</p> </li> <li> <code>ignore_errors</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, no exception will be thrown if a specified store is not linked to this table.</p> </li> <li> <code>delete_external_data</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, then the external data store will also be deleted. WARNING: This is a destructive operation that will delete data outside Pixeltable, and cannot be undone.</p> </li> </ul>"},{"location":"pixeltable/table/#pixeltable.Table.update","title":"update","text":"<pre><code>update(\n    value_spec: dict[str, Any],\n    where: Optional[\"exprs.Expr\"] = None,\n    cascade: bool = True,\n) -&gt; UpdateStatus\n</code></pre> <p>Update rows in this table.</p> <p>Parameters:</p> <ul> <li> <code>value_spec</code>               (<code>dict[str, Any]</code>)           \u2013            <p>a dictionary mapping column names to literal values or Pixeltable expressions.</p> </li> <li> <code>where</code>               (<code>Optional['exprs.Expr']</code>, default:                   <code>None</code> )           \u2013            <p>a predicate to filter rows to update.</p> </li> <li> <code>cascade</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, also update all computed columns that transitively depend on the updated columns.</p> </li> </ul> <p>Examples:</p> <p>Set column <code>int_col</code> to 1 for all rows:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1})\n</code></pre> <p>Set column <code>int_col</code> to 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': 1}, where=tbl.int_col == 0)\n</code></pre> <p>Set <code>int_col</code> to the value of <code>other_int_col</code> + 1:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.other_int_col + 1})\n</code></pre> <p>Increment <code>int_col</code> by 1 for all rows where <code>int_col</code> is 0:</p> <pre><code>&gt;&gt;&gt; tbl.update({'int_col': tbl.int_col + 1}, where=tbl.int_col == 0)\n</code></pre>"},{"location":"pixeltable/table/#pixeltable.Table.validate_column_name","title":"validate_column_name  <code>classmethod</code>","text":"<pre><code>validate_column_name(name: str) -&gt; None\n</code></pre> <p>Check that a name is usable as a pixeltalbe column name</p>"},{"location":"pixeltable/table/#pixeltable.Table.where","title":"where","text":"<pre><code>where(pred: 'exprs.Expr') -&gt; 'pxt.DataFrame'\n</code></pre> <p>Filter rows from this table based on the expression.</p> <p>See <code>DataFrame.where</code> for more details.</p>"},{"location":"pixeltable/update-status/","title":"UpdateStatus","text":""},{"location":"pixeltable/update-status/#pixeltable.UpdateStatus","title":"pixeltable.UpdateStatus  <code>dataclass</code>","text":"<pre><code>UpdateStatus(\n    num_rows: int = 0,\n    num_computed_values: int = 0,\n    num_excs: int = 0,\n    updated_cols: list[str] = list(),\n    cols_with_excs: list[str] = list(),\n)\n</code></pre> <p>Information about updates that resulted from a table operation.</p>"},{"location":"pixeltable/update-status/#pixeltable.UpdateStatus.insert_msg","title":"insert_msg  <code>property</code>","text":"<pre><code>insert_msg: str\n</code></pre> <p>Return a message describing the results of an insert operation.</p>"},{"location":"pixeltable/ext/functions/whisperx/","title":"whisperx","text":""},{"location":"pixeltable/ext/functions/whisperx/#pixeltable.ext.functions.whisperx","title":"pixeltable.ext.functions.whisperx","text":""},{"location":"pixeltable/ext/functions/whisperx/#pixeltable.ext.functions.whisperx.transcribe","title":"transcribe","text":"<pre><code>transcribe(\n    audio: Audio,\n    *,\n    model: String,\n    compute_type: Optional[String] = None,\n    language: Optional[String] = None,\n    chunk_size: Int = 30\n) -&gt; Json\n</code></pre> <p>Transcribe an audio file using WhisperX.</p> <p>This UDF runs a transcription model locally using the WhisperX library, equivalent to the WhisperX <code>transcribe</code> function, as described in the WhisperX library documentation.</p> <p>WhisperX is part of the <code>pixeltable.ext</code> package: long-term support in Pixeltable is not guaranteed.</p> <p>Requirements:</p> <ul> <li><code>pip install whisperx</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>audio</code>               (<code>Audio</code>)           \u2013            <p>The audio file to transcribe.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The name of the model to use for transcription.</p> </li> </ul> <p>See the WhisperX library documentation for details on the remaining parameters.</p> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the transcription and various other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>tiny.en</code> to an existing Pixeltable column <code>tbl.audio</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(result=transcribe(tbl.audio, model='tiny.en'))\n</code></pre>"},{"location":"pixeltable/ext/functions/yolox/","title":"yolox","text":""},{"location":"pixeltable/ext/functions/yolox/#pixeltable.ext.functions.yolox","title":"pixeltable.ext.functions.yolox","text":""},{"location":"pixeltable/ext/functions/yolox/#pixeltable.ext.functions.yolox.yolo_to_coco","title":"yolo_to_coco","text":"<pre><code>yolo_to_coco(detections: Json) -&gt; Json\n</code></pre> <p>Converts the output of a YOLOX object detection model to COCO format.</p> <p>YOLOX is part of the <code>pixeltable.ext</code> package: long-term support in Pixeltable is not guaranteed.</p> <p>Parameters:</p> <ul> <li> <code>detections</code>               (<code>Json</code>)           \u2013            <p>The output of a YOLOX object detection model, as returned by <code>yolox</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the data from <code>detections</code>, converted to COCO format.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that converts the output <code>tbl.detections</code> to COCO format, where <code>tbl.image</code> is the image for which detections were computed:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(detections=yolox(tbl.image, model_id='yolox_m', threshold=0.8))\n... tbl.add_computed_column(detections_coco=yolo_to_coco(tbl.detections))\n</code></pre>"},{"location":"pixeltable/ext/functions/yolox/#pixeltable.ext.functions.yolox.yolox","title":"yolox","text":"<pre><code>yolox(images: Image, *, model_id: String, threshold: Float = 0.5) -&gt; Json\n</code></pre> <p>Computes YOLOX object detections for the specified image. <code>model_id</code> should reference one of the models defined in the YOLOX documentation.</p> <p>YOLOX is part of the <code>pixeltable.ext</code> package: long-term support in Pixeltable is not guaranteed.</p> <p>Requirements:</p> <ul> <li><code>pip install pixeltable-yolox</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>model_id</code>               (<code>String</code>)           \u2013            <p>one of: <code>yolox_nano</code>, <code>yolox_tiny</code>, <code>yolox_s</code>, <code>yolox_m</code>, <code>yolox_l</code>, <code>yolox_x</code></p> </li> <li> <code>threshold</code>               (<code>Float</code>, default:                   <code>0.5</code> )           \u2013            <p>the threshold for object detection</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the output of the object detection model.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>yolox_m</code> to an existing Pixeltable column <code>tbl.image</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(detections=yolox(tbl.image, model_id='yolox_m', threshold=0.8))\n</code></pre>"},{"location":"pixeltable/functions/anthropic/","title":"anthropic","text":""},{"location":"pixeltable/functions/anthropic/#pixeltable.functions.anthropic","title":"pixeltable.functions.anthropic","text":"<p>Pixeltable UDFs that wrap various endpoints from the Anthropic API. In order to use them, you must first <code>pip install anthropic</code> and configure your Anthropic credentials, as described in the Working with Anthropic tutorial.</p>"},{"location":"pixeltable/functions/anthropic/#pixeltable.functions.anthropic.invoke_tools","title":"invoke_tools","text":"<pre><code>invoke_tools(tools: Tools, response: Expr) -&gt; InlineDict\n</code></pre> <p>Converts an Anthropic response dict to Pixeltable tool invocation format and calls <code>tools._invoke()</code>.</p>"},{"location":"pixeltable/functions/anthropic/#pixeltable.functions.anthropic.messages","title":"messages  <code>async</code>","text":"<pre><code>messages(\n    messages: Json,\n    *,\n    model: String,\n    max_tokens: Int,\n    model_kwargs: Optional[Json] = None,\n    tools: Optional[Json] = None,\n    tool_choice: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Create a Message.</p> <p>Equivalent to the Anthropic <code>messages</code> API endpoint. For additional details, see: https://docs.anthropic.com/en/api/messages</p> <p>Request throttling: Uses the rate limit-related headers returned by the API to throttle requests adaptively, based on available request and token capacity. No configuration is necessary.</p> <p>Requirements:</p> <ul> <li><code>pip install anthropic</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>Json</code>)           \u2013            <p>Input messages.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model that will complete your prompt.</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the Anthropic <code>messages</code> API. For details on the available parameters, see: https://docs.anthropic.com/en/api/messages</p> </li> <li> <code>tools</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>An optional list of Pixeltable tools to use for the request.</p> </li> <li> <code>tool_choice</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>An optional tool choice configuration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>claude-3-5-sonnet-20241022</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; msgs = [{'role': 'user', 'content': tbl.prompt}]\n... tbl.add_computed_column(response=messages(msgs, model='claude-3-5-sonnet-20241022'))\n</code></pre>"},{"location":"pixeltable/functions/audio/","title":"audio","text":""},{"location":"pixeltable/functions/audio/#pixeltable.functions.audio","title":"pixeltable.functions.audio","text":"<p>Pixeltable UDFs for <code>AudioType</code>.</p> <p>Example:</p> <pre><code>import pixeltable as pxt\nimport pixeltable.functions as pxtf\n\nt = pxt.get_table(...)\nt.select(pxtf.audio.get_metadata()).collect()\n</code></pre>"},{"location":"pixeltable/functions/audio/#pixeltable.functions.audio.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata(audio: Audio) -&gt; Json\n</code></pre> <p>Gets various metadata associated with an audio file and returns it as a dictionary.</p>"},{"location":"pixeltable/functions/bedrock/","title":"bedrock","text":""},{"location":"pixeltable/functions/bedrock/#pixeltable.functions.bedrock","title":"pixeltable.functions.bedrock","text":""},{"location":"pixeltable/functions/bedrock/#pixeltable.functions.bedrock.converse","title":"converse","text":"<pre><code>converse(\n    messages: Json,\n    *,\n    model_id: String,\n    system: Optional[Json] = None,\n    inference_config: Optional[Json] = None,\n    additional_model_request_fields: Optional[Json] = None,\n    tool_config: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Generate a conversation response.</p> <p>Equivalent to the AWS Bedrock <code>converse</code> API endpoint. For additional details, see: https://docs.aws.amazon.com/bedrock/latest/userguide/conversation-inference.html</p> <p>Requirements:</p> <ul> <li><code>pip install boto3</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>Json</code>)           \u2013            <p>Input messages.</p> </li> <li> <code>model_id</code>               (<code>String</code>)           \u2013            <p>The model that will complete your prompt.</p> </li> <li> <code>system</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>An optional system prompt.</p> </li> <li> <code>inference_config</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Base inference parameters to use.</p> </li> <li> <code>additional_model_request_fields</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional inference parameters to use.</p> </li> </ul> <p>For details on the optional parameters, see: https://docs.aws.amazon.com/bedrock/latest/userguide/conversation-inference.html</p> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>anthropic.claude-3-haiku-20240307-v1:0</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; msgs = [{'role': 'user', 'content': [{'text': tbl.prompt}]}]\n... tbl.add_computed_column(response=messages(msgs, model_id='anthropic.claude-3-haiku-20240307-v1:0'))\n</code></pre>"},{"location":"pixeltable/functions/bedrock/#pixeltable.functions.bedrock.invoke_tools","title":"invoke_tools","text":"<pre><code>invoke_tools(tools: Tools, response: Expr) -&gt; InlineDict\n</code></pre> <p>Converts an Anthropic response dict to Pixeltable tool invocation format and calls <code>tools._invoke()</code>.</p>"},{"location":"pixeltable/functions/date/","title":"date","text":""},{"location":"pixeltable/functions/date/#pixeltable.functions.date","title":"pixeltable.functions.date","text":"<p>Pixeltable UDFs for <code>DateType</code>.</p> <p>Usage example:</p> <pre><code>import pixeltable as pxt\n\nt = pxt.get_table(...)\nt.select(t.date_col.year, t.date_col.weekday()).collect()\n</code></pre>"},{"location":"pixeltable/functions/date/#pixeltable.functions.date.add_days","title":"add_days","text":"<pre><code>add_days(self: Date, n: Int) -&gt; Date\n</code></pre> <p>Add <code>n</code> days to the date.</p> <p>Equivalent to <code>date + timedelta(days=n)</code>.</p>"},{"location":"pixeltable/functions/date/#pixeltable.functions.date.day","title":"day","text":"<pre><code>day(self: Date) -&gt; Int\n</code></pre> <p>Between 1 and the number of days in the given month of the given year.</p> <p>Equivalent to <code>date.day</code>.</p>"},{"location":"pixeltable/functions/date/#pixeltable.functions.date.isocalendar","title":"isocalendar","text":"<pre><code>isocalendar(self: Date) -&gt; Json\n</code></pre> <p>Return a dictionary with three entries: <code>'year'</code>, <code>'week'</code>, and <code>'weekday'</code>.</p> <p>Equivalent to <code>date.isocalendar()</code>.</p>"},{"location":"pixeltable/functions/date/#pixeltable.functions.date.isoformat","title":"isoformat","text":"<pre><code>isoformat(self: Date, sep: String = 'T', timespec: String = 'auto') -&gt; String\n</code></pre> <p>Return a string representing the date and time in ISO 8601 format.</p> <p>Equivalent to <code>date.isoformat()</code>.</p> <p>Parameters:</p> <ul> <li> <code>sep</code>               (<code>String</code>, default:                   <code>'T'</code> )           \u2013            <p>Separator between date and time.</p> </li> <li> <code>timespec</code>               (<code>String</code>, default:                   <code>'auto'</code> )           \u2013            <p>The number of additional terms in the output. See the <code>date.isoformat()</code> documentation for more details.</p> </li> </ul>"},{"location":"pixeltable/functions/date/#pixeltable.functions.date.isoweekday","title":"isoweekday","text":"<pre><code>isoweekday(self: Date) -&gt; Int\n</code></pre> <p>Return the day of the week as an integer, where Monday is 1 and Sunday is 7.</p> <p>Equivalent to <code>date.isoweekday()</code>.</p>"},{"location":"pixeltable/functions/date/#pixeltable.functions.date.make_date","title":"make_date","text":"<pre><code>make_date(year: Int, month: Int, day: Int) -&gt; Date\n</code></pre> <p>Create a date.</p> <p>Equivalent to <code>datetime()</code>.</p>"},{"location":"pixeltable/functions/date/#pixeltable.functions.date.month","title":"month","text":"<pre><code>month(self: Date) -&gt; Int\n</code></pre> <p>Between 1 and 12 inclusive.</p> <p>Equivalent to <code>date.month</code>.</p>"},{"location":"pixeltable/functions/date/#pixeltable.functions.date.strftime","title":"strftime","text":"<pre><code>strftime(self: Date, format: String) -&gt; String\n</code></pre> <p>Return a string representing the date and time, controlled by an explicit format string.</p> <p>Equivalent to <code>date.strftime()</code>.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>String</code>)           \u2013            <p>The format string to control the output. For a complete list of formatting directives, see <code>strftime()</code> and <code>strptime()</code> Behavior.</p> </li> </ul>"},{"location":"pixeltable/functions/date/#pixeltable.functions.date.toordinal","title":"toordinal","text":"<pre><code>toordinal(self: Date) -&gt; Int\n</code></pre> <p>Return the proleptic Gregorian ordinal of the date, where January 1 of year 1 has ordinal 1.</p> <p>Equivalent to <code>date.toordinal()</code>.</p>"},{"location":"pixeltable/functions/date/#pixeltable.functions.date.weekday","title":"weekday","text":"<pre><code>weekday(self: Date) -&gt; Int\n</code></pre> <p>Between 0 (Monday) and 6 (Sunday) inclusive.</p> <p>Equivalent to <code>date.weekday()</code>.</p>"},{"location":"pixeltable/functions/date/#pixeltable.functions.date.year","title":"year","text":"<pre><code>year(self: Date) -&gt; Int\n</code></pre> <p>Between <code>MINYEAR</code> and <code>MAXYEAR</code> inclusive.</p> <p>Equivalent to <code>date.year</code>.</p>"},{"location":"pixeltable/functions/deepseek/","title":"deepseek","text":""},{"location":"pixeltable/functions/deepseek/#pixeltable.functions.deepseek","title":"pixeltable.functions.deepseek","text":""},{"location":"pixeltable/functions/deepseek/#pixeltable.functions.deepseek.chat_completions","title":"chat_completions  <code>async</code>","text":"<pre><code>chat_completions(\n    messages: Json,\n    *,\n    model: String,\n    model_kwargs: Optional[Json] = None,\n    tools: Optional[Json] = None,\n    tool_choice: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Creates a model response for the given chat conversation.</p> <p>Equivalent to the Deepseek <code>chat/completions</code> API endpoint. For additional details, see: https://api-docs.deepseek.com/api/create-chat-completion</p> <p>Deepseek uses the OpenAI SDK, so you will need to install the <code>openai</code> package to use this UDF.</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>Json</code>)           \u2013            <p>A list of messages to use for chat completion, as described in the Deepseek API documentation.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model to use for chat completion.</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the Deepseek <code>chat/completions</code> API. For details on the available parameters, see: https://api-docs.deepseek.com/api/create-chat-completion</p> </li> <li> <code>tools</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>An optional list of Pixeltable tools to use for the request.</p> </li> <li> <code>tool_choice</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>An optional tool choice configuration.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>deepseek-chat</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; messages = [\n        {'role': 'system', 'content': 'You are a helpful assistant.'},\n        {'role': 'user', 'content': tbl.prompt}\n    ]\n    tbl.add_computed_column(response=chat_completions(messages, model='deepseek-chat'))\n</code></pre>"},{"location":"pixeltable/functions/fireworks/","title":"fireworks","text":""},{"location":"pixeltable/functions/fireworks/#pixeltable.functions.fireworks","title":"pixeltable.functions.fireworks","text":"<p>Pixeltable UDFs that wrap various endpoints from the Fireworks AI API. In order to use them, you must first <code>pip install fireworks-ai</code> and configure your Fireworks AI credentials, as described in the Working with Fireworks tutorial.</p>"},{"location":"pixeltable/functions/fireworks/#pixeltable.functions.fireworks.chat_completions","title":"chat_completions  <code>async</code>","text":"<pre><code>chat_completions(\n    messages: Json, *, model: String, model_kwargs: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Creates a model response for the given chat conversation.</p> <p>Equivalent to the Fireworks AI <code>chat/completions</code> API endpoint. For additional details, see: https://docs.fireworks.ai/api-reference/post-chatcompletions</p> <p>Request throttling: Applies the rate limit set in the config (section <code>fireworks</code>, key <code>rate_limit</code>). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install fireworks-ai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>Json</code>)           \u2013            <p>A list of messages comprising the conversation so far.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The name of the model to use.</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the Fireworks <code>chat_completions</code> API. For details on the available parameters, see: https://docs.fireworks.ai/api-reference/post-chatcompletions</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>accounts/fireworks/models/mixtral-8x22b-instruct</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; messages = [{'role': 'user', 'content': tbl.prompt}]\n... tbl.add_computed_column(\n...     response=chat_completions(messages, model='accounts/fireworks/models/mixtral-8x22b-instruct')\n... )\n</code></pre>"},{"location":"pixeltable/functions/gemini/","title":"gemini","text":""},{"location":"pixeltable/functions/gemini/#pixeltable.functions.gemini","title":"pixeltable.functions.gemini","text":"<p>Pixeltable UDFs that wrap various endpoints from the Google Gemini API. In order to use them, you must first <code>pip install google-genai</code> and configure your Gemini credentials, as described in the Working with Gemini tutorial.</p>"},{"location":"pixeltable/functions/gemini/#pixeltable.functions.gemini.generate_content","title":"generate_content  <code>async</code>","text":"<pre><code>generate_content(\n    contents: String,\n    *,\n    model: String,\n    config: Optional[Json] = None,\n    tools: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Generate content from the specified model. For additional details, see: https://ai.google.dev/gemini-api/docs/text-generation</p> <p>Request throttling: Applies the rate limit set in the config (section <code>gemini</code>, key <code>rate_limit</code>). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install google-genai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>contents</code>               (<code>String</code>)           \u2013            <p>The input content to generate from.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The name of the model to use.</p> </li> <li> <code>config</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Configuration for generation, corresponding to keyword arguments of <code>genai.types.GenerateContentConfig</code>. For details on the parameters, see: https://googleapis.github.io/python-genai/genai.html#module-genai.types</p> </li> <li> <code>tools</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>An optional list of Pixeltable tools to use. It is also possible to specify tools manually via the <code>config['tools']</code> parameter, but at most one of <code>config['tools']</code> or <code>tools</code> may be used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>gemini-2.0-flash</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(response=generate_content(tbl.prompt, model='gemini-2.0-flash'))\n</code></pre>"},{"location":"pixeltable/functions/gemini/#pixeltable.functions.gemini.generate_images","title":"generate_images  <code>async</code>","text":"<pre><code>generate_images(\n    prompt: String, *, model: String, config: Optional[Json] = None\n) -&gt; Image\n</code></pre> <p>Generates images based on a text description and configuration. For additional details, see: https://ai.google.dev/gemini-api/docs/image-generation</p> <p>Requirements:</p> <ul> <li><code>pip install google-genai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>prompt</code>               (<code>String</code>)           \u2013            <p>A text description of the images to generate.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model to use.</p> </li> <li> <code>config</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Configuration for generation, corresponding to keyword arguments of <code>genai.types.GenerateImagesConfig</code>. For details on the parameters, see: https://googleapis.github.io/python-genai/genai.html#module-genai.types</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Image</code>           \u2013            <p>The generated image.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>imagen-3.0-generate-002</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(response=generate_images(tbl.prompt, model='imagen-3.0-generate-002'))\n</code></pre>"},{"location":"pixeltable/functions/gemini/#pixeltable.functions.gemini.generate_videos","title":"generate_videos  <code>async</code>","text":"<pre><code>generate_videos(\n    prompt: Optional[String] = None,\n    image: Optional[Image] = None,\n    *,\n    model: String,\n    config: Optional[Json] = None\n) -&gt; Video\n</code></pre> <p>Generates videos based on a text description and configuration. For additional details, see: https://ai.google.dev/gemini-api/docs/video-generation</p> <p>Requirements:</p> <ul> <li><code>pip install google-genai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>prompt</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>A text description of the videos to generate.</p> </li> <li> <code>image</code>               (<code>Optional[Image]</code>, default:                   <code>None</code> )           \u2013            <p>An optional image to use as the first frame of the video. At least one of <code>prompt</code> or <code>image</code> must be provided. (It is ok to specify both.)</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model to use.</p> </li> <li> <code>config</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Configuration for generation, corresponding to keyword arguments of <code>genai.types.GenerateVideosConfig</code>. For details on the parameters, see: https://googleapis.github.io/python-genai/genai.html#module-genai.types</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Video</code>           \u2013            <p>The generated video.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>veo-2.0-generate-001</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(response=generate_videos(tbl.prompt, model='veo-2.0-generate-001'))\n</code></pre>"},{"location":"pixeltable/functions/gemini/#pixeltable.functions.gemini.invoke_tools","title":"invoke_tools","text":"<pre><code>invoke_tools(tools: Tools, response: Expr) -&gt; InlineDict\n</code></pre> <p>Converts an OpenAI response dict to Pixeltable tool invocation format and calls <code>tools._invoke()</code>.</p>"},{"location":"pixeltable/functions/groq/","title":"groq","text":""},{"location":"pixeltable/functions/groq/#pixeltable.functions.groq","title":"pixeltable.functions.groq","text":"<p>Pixeltable UDFs that wrap various endpoints from the Groq API. In order to use them, you must first <code>pip install groq</code> and configure your Groq credentials, as described in the Working with Groq tutorial.</p>"},{"location":"pixeltable/functions/groq/#pixeltable.functions.groq.chat_completions","title":"chat_completions  <code>async</code>","text":"<pre><code>chat_completions(\n    messages: Json,\n    *,\n    model: String,\n    model_kwargs: Optional[Json] = None,\n    tools: Optional[Json] = None,\n    tool_choice: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Chat Completion API.</p> <p>Equivalent to the Groq <code>chat/completions</code> API endpoint. For additional details, see: https://console.groq.com/docs/api-reference#chat-create</p> <p>Request throttling: Applies the rate limit set in the config (section <code>groq</code>, key <code>rate_limit</code>). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install groq</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>Json</code>)           \u2013            <p>A list of messages comprising the conversation so far.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>ID of the model to use. (See overview here: https://console.groq.com/docs/models)</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the Groq <code>chat/completions</code> API. For details on the available parameters, see: https://console.groq.com/docs/api-reference#chat-create</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>llama3-8b-8192</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; messages = [{'role': 'user', 'content': tbl.prompt}]\n... tbl.add_computed_column(response=chat_completions(messages, model='llama3-8b-8192'))\n</code></pre>"},{"location":"pixeltable/functions/groq/#pixeltable.functions.groq.invoke_tools","title":"invoke_tools","text":"<pre><code>invoke_tools(tools: Tools, response: Expr) -&gt; InlineDict\n</code></pre> <p>Converts an OpenAI response dict to Pixeltable tool invocation format and calls <code>tools._invoke()</code>.</p>"},{"location":"pixeltable/functions/huggingface/","title":"huggingface","text":""},{"location":"pixeltable/functions/huggingface/#pixeltable.functions.huggingface","title":"pixeltable.functions.huggingface","text":"<p>Pixeltable UDFs that wrap various models from the Hugging Face <code>transformers</code> package.</p> <p>These UDFs will cause Pixeltable to invoke the relevant models locally. In order to use them, you must first <code>pip install transformers</code> (or in some cases, <code>sentence-transformers</code>, as noted in the specific UDFs).</p>"},{"location":"pixeltable/functions/huggingface/#pixeltable.functions.huggingface.clip","title":"clip","text":"<pre><code>clip(text: String, *, model_id: String) -&gt; Array[(None,), Float]\n</code></pre> <pre><code>clip(image: Image, *, model_id: String) -&gt; Array[(None,), Float]\n</code></pre> <p>Computes a CLIP embedding for the specified text or image. <code>model_id</code> should be a reference to a pretrained CLIP Model.</p> <p>Requirements:</p> <ul> <li><code>pip install torch transformers</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>String</code>)           \u2013            <p>The string to embed.</p> </li> <li> <code>model_id</code>               (<code>String</code>)           \u2013            <p>The pretrained model to use for the embedding.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array[(None,), Float]</code>           \u2013            <p>An array containing the output of the embedding model.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>openai/clip-vit-base-patch32</code> to an existing Pixeltable column <code>tbl.text</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(\n...     result=clip(tbl.text, model_id='openai/clip-vit-base-patch32')\n... )\n</code></pre> <p>The same would work with an image column <code>tbl.image</code> in place of <code>tbl.text</code>.</p>"},{"location":"pixeltable/functions/huggingface/#pixeltable.functions.huggingface.cross_encoder","title":"cross_encoder","text":"<pre><code>cross_encoder(\n    sentences1: String, sentences2: String, *, model_id: String\n) -&gt; Float\n</code></pre> <p>Performs predicts on the given sentence pair. <code>model_id</code> should be a pretrained Cross-Encoder model, as described in the Cross-Encoder Pretrained Models documentation.</p> <p>Requirements:</p> <ul> <li><code>pip install torch sentence-transformers</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>sentences1</code>               (<code>String</code>)           \u2013            <p>The first sentence to be paired.</p> </li> <li> <code>sentences2</code>               (<code>String</code>)           \u2013            <p>The second sentence to be paired.</p> </li> <li> <code>model_id</code>               (<code>String</code>)           \u2013            <p>The identifier of the cross-encoder model to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Float</code>           \u2013            <p>The similarity score between the inputs.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>ms-marco-MiniLM-L-4-v2</code> to the sentences in columns <code>tbl.sentence1</code> and <code>tbl.sentence2</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(result=sentence_transformer(\n...     tbl.sentence1, tbl.sentence2, model_id='ms-marco-MiniLM-L-4-v2'\n... ))\n</code></pre>"},{"location":"pixeltable/functions/huggingface/#pixeltable.functions.huggingface.detr_for_object_detection","title":"detr_for_object_detection","text":"<pre><code>detr_for_object_detection(\n    image: Image,\n    *,\n    model_id: String,\n    threshold: Float = 0.5,\n    revision: String = \"no_timm\"\n) -&gt; Json\n</code></pre> <p>Computes DETR object detections for the specified image. <code>model_id</code> should be a reference to a pretrained DETR Model.</p> <p>Requirements:</p> <ul> <li><code>pip install torch transformers</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>image</code>               (<code>Image</code>)           \u2013            <p>The image to embed.</p> </li> <li> <code>model_id</code>               (<code>String</code>)           \u2013            <p>The pretrained model to use for object detection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the output of the object detection model, in the following format:</p> <pre><code>{\n    'scores': [0.99, 0.999],  # list of confidence scores for each detected object\n    'labels': [25, 25],  # list of COCO class labels for each detected object\n    'label_text': ['giraffe', 'giraffe'],  # corresponding text names of class labels\n    'boxes': [[51.942, 356.174, 181.481, 413.975], [383.225, 58.66, 605.64, 361.346]]\n        # list of bounding boxes for each detected object, as [x1, y1, x2, y2]\n}\n</code></pre> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>facebook/detr-resnet-50</code> to an existing Pixeltable column <code>image</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(detections=detr_for_object_detection(\n...     tbl.image,\n...     model_id='facebook/detr-resnet-50',\n...     threshold=0.8\n... ))\n</code></pre>"},{"location":"pixeltable/functions/huggingface/#pixeltable.functions.huggingface.detr_to_coco","title":"detr_to_coco","text":"<pre><code>detr_to_coco(image: Image, detr_info: Json) -&gt; Json\n</code></pre> <p>Converts the output of a DETR object detection model to COCO format.</p> <p>Parameters:</p> <ul> <li> <code>image</code>               (<code>Image</code>)           \u2013            <p>The image for which detections were computed.</p> </li> <li> <code>detr_info</code>               (<code>Json</code>)           \u2013            <p>The output of a DETR object detection model, as returned by <code>detr_for_object_detection</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the data from <code>detr_info</code>, converted to COCO format.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that converts the output <code>tbl.detections</code> to COCO format, where <code>tbl.image</code> is the image for which detections were computed:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(detections_coco=detr_to_coco(tbl.image, tbl.detections))\n</code></pre>"},{"location":"pixeltable/functions/huggingface/#pixeltable.functions.huggingface.sentence_transformer","title":"sentence_transformer","text":"<pre><code>sentence_transformer(\n    sentence: String, *, model_id: String, normalize_embeddings: Bool = False\n) -&gt; Array[(None,), Float]\n</code></pre> <p>Computes sentence embeddings. <code>model_id</code> should be a pretrained Sentence Transformers model, as described in the Sentence Transformers Pretrained Models documentation.</p> <p>Requirements:</p> <ul> <li><code>pip install torch sentence-transformers</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>sentence</code>               (<code>String</code>)           \u2013            <p>The sentence to embed.</p> </li> <li> <code>model_id</code>               (<code>String</code>)           \u2013            <p>The pretrained model to use for the encoding.</p> </li> <li> <code>normalize_embeddings</code>               (<code>Bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, normalizes embeddings to length 1; see the Sentence Transformers API Docs for more details</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array[(None,), Float]</code>           \u2013            <p>An array containing the output of the embedding model.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>all-mpnet-base-2</code> to an existing Pixeltable column <code>tbl.sentence</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(result=sentence_transformer(tbl.sentence, model_id='all-mpnet-base-v2'))\n</code></pre>"},{"location":"pixeltable/functions/huggingface/#pixeltable.functions.huggingface.speech2text_for_conditional_generation","title":"speech2text_for_conditional_generation","text":"<pre><code>speech2text_for_conditional_generation(\n    audio: Audio, *, model_id: String, language: Optional[String] = None\n) -&gt; String\n</code></pre> <p>Transcribes or translates speech to text using a Speech2Text model. <code>model_id</code> should be a reference to a pretrained Speech2Text model.</p> <p>Requirements:</p> <ul> <li><code>pip install torch torchaudio sentencepiece transformers</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>audio</code>               (<code>Audio</code>)           \u2013            <p>The audio clip to transcribe or translate.</p> </li> <li> <code>model_id</code>               (<code>String</code>)           \u2013            <p>The pretrained model to use for the transcription or translation.</p> </li> <li> <code>language</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>If using a multilingual translation model, the language code to translate to. If not provided, the model's default language will be used. If the model is not translation model, is not a multilingual model, or does not support the specified language, an error will be raised.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>String</code>           \u2013            <p>The transcribed or translated text.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>facebook/s2t-small-librispeech-asr</code> to an existing Pixeltable column <code>audio</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(transcription=speech2text_for_conditional_generation(\n...     tbl.audio,\n...     model_id='facebook/s2t-small-librispeech-asr'\n... ))\n</code></pre> <p>Add a computed column that applies the model <code>facebook/s2t-medium-mustc-multilingual-st</code> to an existing Pixeltable column <code>audio</code> of the table <code>tbl</code>, translating the audio to French:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(translation=speech2text_for_conditional_generation(\n...     tbl.audio,\n...     model_id='facebook/s2t-medium-mustc-multilingual-st',\n...     language='fr'\n... ))\n</code></pre>"},{"location":"pixeltable/functions/huggingface/#pixeltable.functions.huggingface.vit_for_image_classification","title":"vit_for_image_classification","text":"<pre><code>vit_for_image_classification(\n    image: Image, *, model_id: String, top_k: Int = 5\n) -&gt; Json\n</code></pre> <p>Computes image classifications for the specified image using a Vision Transformer (ViT) model. <code>model_id</code> should be a reference to a pretrained ViT Model.</p> <p>Note: Be sure the model is a ViT model that is trained for image classification (that is, a model designed for use with the ViTForImageClassification class), such as <code>google/vit-base-patch16-224</code>. General feature-extraction models such as <code>google/vit-base-patch16-224-in21k</code> will not produce the desired results.</p> <p>Requirements:</p> <ul> <li><code>pip install torch transformers</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>image</code>               (<code>Image</code>)           \u2013            <p>The image to classify.</p> </li> <li> <code>model_id</code>               (<code>String</code>)           \u2013            <p>The pretrained model to use for the classification.</p> </li> <li> <code>top_k</code>               (<code>Int</code>, default:                   <code>5</code> )           \u2013            <p>The number of classes to return.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the output of the image classification model, in the following format:</p> </li> <li> <code>Json</code>           \u2013            <p>```python</p> </li> <li> <code>Json</code>           \u2013            <p>{ 'scores': [0.325, 0.198, 0.105],  # list of probabilities of the top-k most likely classes 'labels': [340, 353, 386],  # list of class IDs for the top-k most likely classes 'label_text': ['zebra', 'gazelle', 'African elephant, Loxodonta africana'],     # corresponding text names of the top-k most likely classes</p> </li> <li> <code>Json</code>           \u2013            <p>```</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>google/vit-base-patch16-224</code> to an existing Pixeltable column <code>image</code> of the table <code>tbl</code>, returning the 10 most likely classes for each image:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(image_class=vit_for_image_classification(\n...     tbl.image,\n...     model_id='google/vit-base-patch16-224',\n...     top_k=10\n... ))\n</code></pre>"},{"location":"pixeltable/functions/image/","title":"image","text":""},{"location":"pixeltable/functions/image/#pixeltable.functions.image","title":"pixeltable.functions.image","text":"<p>Pixeltable UDFs for <code>ImageType</code>.</p> <p>Example:</p> <pre><code>import pixeltable as pxt\n\nt = pxt.get_table(...)\nt.select(t.img_col.convert('L')).collect()\n</code></pre>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.alpha_composite","title":"alpha_composite","text":"<pre><code>alpha_composite(im1: Image, im2: Image) -&gt; Image\n</code></pre> <p>Alpha composite <code>im2</code> over <code>im1</code>.</p> <p>Equivalent to <code>PIL.Image.alpha_composite()</code></p>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.b64_encode","title":"b64_encode","text":"<pre><code>b64_encode(img: Image, image_format: String = 'png') -&gt; String\n</code></pre> <p>Convert image to a base64-encoded string.</p> <p>Parameters:</p> <ul> <li> <code>img</code>               (<code>Image</code>)           \u2013            <p>image</p> </li> <li> <code>image_format</code>               (<code>String</code>, default:                   <code>'png'</code> )           \u2013            <p>image format supported by PIL</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.blend","title":"blend","text":"<pre><code>blend(im1: Image, im2: Image, alpha: Float) -&gt; Image\n</code></pre> <p>Return a new image by interpolating between two input images, using a constant alpha.</p> <p>Equivalent to <code>PIL.Image.blend()</code></p>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.composite","title":"composite","text":"<pre><code>composite(image1: Image, image2: Image, mask: Image) -&gt; Image\n</code></pre> <p>Return a composite image by blending two images using a mask.</p> <p>Equivalent to <code>PIL.Image.composite()</code></p>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.convert","title":"convert","text":"<pre><code>convert(self: Image, mode: String) -&gt; Image\n</code></pre> <p>Convert the image to a different mode.</p> <p>Equivalent to <code>PIL.Image.Image.convert()</code>.</p> <p>Parameters:</p> <ul> <li> <code>mode</code>               (<code>String</code>)           \u2013            <p>The mode to convert to. See the Pillow documentation for a list of supported modes.</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.crop","title":"crop","text":"<pre><code>crop(self: Image, box: Json) -&gt; Image\n</code></pre> <p>Return a rectangular region from the image. The box is a 4-tuple defining the left, upper, right, and lower pixel coordinates.</p> <p>Equivalent to <code>PIL.Image.Image.crop()</code></p>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.effect_spread","title":"effect_spread","text":"<pre><code>effect_spread(self: Image, distance: Int) -&gt; Image\n</code></pre> <p>Randomly spread pixels in an image.</p> <p>Equivalent to <code>PIL.Image.Image.effect_spread()</code></p> <p>Parameters:</p> <ul> <li> <code>distance</code>               (<code>Int</code>)           \u2013            <p>The distance to spread pixels.</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.entropy","title":"entropy","text":"<pre><code>entropy(\n    self: Image, mask: Optional[Image] = None, extrema: Optional[Json] = None\n) -&gt; Float\n</code></pre> <p>Returns the entropy of the image, optionally using a mask and extrema.</p> <p>Equivalent to <code>PIL.Image.Image.entropy()</code></p> <p>Parameters:</p> <ul> <li> <code>mask</code>               (<code>Optional[Image]</code>, default:                   <code>None</code> )           \u2013            <p>An optional mask image.</p> </li> <li> <code>extrema</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>An optional list of extrema.</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata(self: Image) -&gt; Json\n</code></pre> <p>Return metadata for the image.</p>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.getbands","title":"getbands","text":"<pre><code>getbands(self: Image) -&gt; Json\n</code></pre> <p>Return a tuple containing the names of the image bands.</p> <p>Equivalent to <code>PIL.Image.Image.getbands()</code></p>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.getbbox","title":"getbbox","text":"<pre><code>getbbox(self: Image, *, alpha_only: Bool = True) -&gt; Json\n</code></pre> <p>Return a bounding box for the non-zero regions of the image.</p> <p>Equivalent to <code>PIL.Image.Image.getbbox()</code></p> <p>Parameters:</p> <ul> <li> <code>alpha_only</code>               (<code>Bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, and the image has an alpha channel, trim transparent pixels. Otherwise, trim pixels when all channels are zero.</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.getchannel","title":"getchannel","text":"<pre><code>getchannel(self: Image, channel: Int) -&gt; Image\n</code></pre> <p>Return an L-mode image containing a single channel of the original image.</p> <p>Equivalent to <code>PIL.Image.Image.getchannel()</code></p> <p>Parameters:</p> <ul> <li> <code>channel</code>               (<code>Int</code>)           \u2013            <p>The channel to extract. This is a 0-based index.</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.getcolors","title":"getcolors","text":"<pre><code>getcolors(self: Image, maxcolors: Int = 256) -&gt; Json\n</code></pre> <p>Return a list of colors used in the image, up to a maximum of <code>maxcolors</code>.</p> <p>Equivalent to <code>PIL.Image.Image.getcolors()</code></p> <p>Parameters:</p> <ul> <li> <code>maxcolors</code>               (<code>Int</code>, default:                   <code>256</code> )           \u2013            <p>The maximum number of colors to return.</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.getextrema","title":"getextrema","text":"<pre><code>getextrema(self: Image) -&gt; Json\n</code></pre> <p>Return a 2-tuple containing the minimum and maximum pixel values of the image.</p> <p>Equivalent to <code>PIL.Image.Image.getextrema()</code></p>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.getpalette","title":"getpalette","text":"<pre><code>getpalette(self: Image, mode: Optional[String] = None) -&gt; Json\n</code></pre> <p>Return the palette of the image, optionally converting it to a different mode.</p> <p>Equivalent to <code>PIL.Image.Image.getpalette()</code></p> <p>Parameters:</p> <ul> <li> <code>mode</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>The mode to convert the palette to.</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.getpixel","title":"getpixel","text":"<pre><code>getpixel(self: Image, xy: Json) -&gt; Json\n</code></pre> <p>Return the pixel value at the given position. The position <code>xy</code> is a tuple containing the x and y coordinates.</p> <p>Equivalent to <code>PIL.Image.Image.getpixel()</code></p> <p>Parameters:</p> <ul> <li> <code>xy</code>               (<code>Json</code>)           \u2013            <p>The coordinates, given as (x, y).</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.getprojection","title":"getprojection","text":"<pre><code>getprojection(self: Image) -&gt; Json\n</code></pre> <p>Return two sequences representing the horizontal and vertical projection of the image.</p> <p>Equivalent to <code>PIL.Image.Image.getprojection()</code></p>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.histogram","title":"histogram","text":"<pre><code>histogram(\n    self: Image, mask: Optional[Image] = None, extrema: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Return a histogram for the image.</p> <p>Equivalent to <code>PIL.Image.Image.histogram()</code></p> <p>Parameters:</p> <ul> <li> <code>mask</code>               (<code>Optional[Image]</code>, default:                   <code>None</code> )           \u2013            <p>An optional mask image.</p> </li> <li> <code>extrema</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>An optional list of extrema.</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.point","title":"point","text":"<pre><code>point(self: Image, lut: Json, mode: Optional[String] = None) -&gt; Image\n</code></pre> <p>Map image pixels through a lookup table.</p> <p>Equivalent to <code>PIL.Image.Image.point()</code></p> <p>Parameters:</p> <ul> <li> <code>lut</code>               (<code>Json</code>)           \u2013            <p>A lookup table.</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.quantize","title":"quantize","text":"<pre><code>quantize(\n    self: Image,\n    colors: Int = 256,\n    method: Optional[Int] = None,\n    kmeans: Int = 0,\n    palette: Optional[Int] = None,\n    dither: Int = PIL.Image.Dither.FLOYDSTEINBERG,\n) -&gt; Image\n</code></pre> <p>Convert the image to 'P' mode with the specified number of colors.</p> <p>Equivalent to  <code>PIL.Image.Image.quantize()</code></p> <p>Parameters:</p> <ul> <li> <code>colors</code>               (<code>Int</code>, default:                   <code>256</code> )           \u2013            <p>The number of colors to quantize to.</p> </li> <li> <code>method</code>               (<code>Optional[Int]</code>, default:                   <code>None</code> )           \u2013            <p>The quantization method. See the Pillow documentation for a list of supported methods.</p> </li> <li> <code>kmeans</code>               (<code>Int</code>, default:                   <code>0</code> )           \u2013            <p>The number of k-means clusters to use.</p> </li> <li> <code>palette</code>               (<code>Optional[Int]</code>, default:                   <code>None</code> )           \u2013            <p>The palette to use.</p> </li> <li> <code>dither</code>               (<code>Int</code>, default:                   <code>FLOYDSTEINBERG</code> )           \u2013            <p>The dithering method. See the Pillow documentation for a list of supported methods.</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.reduce","title":"reduce","text":"<pre><code>reduce(self: Image, factor: Int, box: Optional[Json] = None) -&gt; Image\n</code></pre> <p>Reduce the image by the given factor.</p> <p>Equivalent to <code>PIL.Image.Image.reduce()</code></p> <p>Parameters:</p> <ul> <li> <code>factor</code>               (<code>Int</code>)           \u2013            <p>The reduction factor.</p> </li> <li> <code>box</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>An optional 4-tuple of ints providing the source image region to be reduced. The values must be within (0, 0, width, height) rectangle. If omitted or None, the entire source is used.</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.resize","title":"resize","text":"<pre><code>resize(self: Image, size: Json) -&gt; Image\n</code></pre> <p>Return a resized copy of the image. The size parameter is a tuple containing the width and height of the new image.</p> <p>Equivalent to <code>PIL.Image.Image.resize()</code></p>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.rotate","title":"rotate","text":"<pre><code>rotate(self: Image, angle: Int) -&gt; Image\n</code></pre> <p>Return a copy of the image rotated by the given angle.</p> <p>Equivalent to <code>PIL.Image.Image.rotate()</code></p> <p>Parameters:</p> <ul> <li> <code>angle</code>               (<code>Int</code>)           \u2013            <p>The angle to rotate the image, in degrees. Positive angles are counter-clockwise.</p> </li> </ul>"},{"location":"pixeltable/functions/image/#pixeltable.functions.image.transpose","title":"transpose","text":"<pre><code>transpose(self: Image, method: Int) -&gt; Image\n</code></pre> <p>Transpose the image.</p> <p>Equivalent to <code>PIL.Image.Image.transpose()</code></p> <p>Parameters:</p> <ul> <li> <code>method</code>               (<code>Int</code>)           \u2013            <p>The transpose method. See the Pillow documentation for a list of supported methods.</p> </li> </ul>"},{"location":"pixeltable/functions/json/","title":"json","text":""},{"location":"pixeltable/functions/json/#pixeltable.functions.json","title":"pixeltable.functions.json","text":"<p>Pixeltable UDFs for <code>JsonType</code>.</p> <p>Example:</p> <pre><code>import pixeltable as pxt\nimport pixeltable.functions as pxtf\n\nt = pxt.get_table(...)\nt.select(pxtf.json.make_list(t.json_col)).collect()\n</code></pre>"},{"location":"pixeltable/functions/json/#pixeltable.functions.json.make_list","title":"make_list","text":"<pre><code>make_list()\n</code></pre> <p>Collects arguments into a list.</p>"},{"location":"pixeltable/functions/llama_cpp/","title":"llama_cpp","text":""},{"location":"pixeltable/functions/llama_cpp/#pixeltable.functions.llama_cpp","title":"pixeltable.functions.llama_cpp","text":""},{"location":"pixeltable/functions/llama_cpp/#pixeltable.functions.llama_cpp.create_chat_completion","title":"create_chat_completion","text":"<pre><code>create_chat_completion(\n    messages: Json,\n    *,\n    model_path: Optional[String] = None,\n    repo_id: Optional[String] = None,\n    repo_filename: Optional[String] = None,\n    model_kwargs: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Generate a chat completion from a list of messages.</p> <p>The model can be specified either as a local path, or as a repo_id and repo_filename that reference a pretrained model on the Hugging Face model hub. Exactly one of <code>model_path</code> or <code>repo_id</code> must be provided; if <code>model_path</code> is provided, then an optional <code>repo_filename</code> can also be specified.</p> <p>For additional details, see the llama_cpp create_chat_completions documentation.</p> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>Json</code>)           \u2013            <p>A list of messages to generate a response for.</p> </li> <li> <code>model_path</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>Path to the model (if using a local model).</p> </li> <li> <code>repo_id</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>The Hugging Face model repo id (if using a pretrained model).</p> </li> <li> <code>repo_filename</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>A filename or glob pattern to match the model file in the repo (optional, if using a pretrained model).</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the llama_cpp <code>create_chat_completions</code> API, such as <code>max_tokens</code>, <code>temperature</code>, <code>top_p</code>, and <code>top_k</code>. For details, see the llama_cpp create_chat_completions documentation.</p> </li> </ul>"},{"location":"pixeltable/functions/math/","title":"math","text":""},{"location":"pixeltable/functions/math/#pixeltable.functions.math","title":"pixeltable.functions.math","text":"<p>Pixeltable UDFs for mathematical operations.</p> <p>Example:</p> <pre><code>import pixeltable as pxt\n\nt = pxt.get_table(...)\nt.select(t.float_col.floor()).collect()\n</code></pre>"},{"location":"pixeltable/functions/math/#pixeltable.functions.math.abs","title":"abs","text":"<pre><code>abs(self: Float) -&gt; Float\n</code></pre> <p>Return the absolute value of the given number.</p> <p>Equivalent to Python <code>builtins.abs()</code>.</p>"},{"location":"pixeltable/functions/math/#pixeltable.functions.math.bitwise_and","title":"bitwise_and","text":"<pre><code>bitwise_and(self: Int, other: Int) -&gt; Int\n</code></pre> <p>Bitwise AND of two integers.</p> <p>Equivalent to Python <code>self &amp; other</code>.</p>"},{"location":"pixeltable/functions/math/#pixeltable.functions.math.bitwise_or","title":"bitwise_or","text":"<pre><code>bitwise_or(self: Int, other: Int) -&gt; Int\n</code></pre> <p>Bitwise OR of two integers.</p> <p>Equivalent to Python <code>self | other</code>.</p>"},{"location":"pixeltable/functions/math/#pixeltable.functions.math.bitwise_xor","title":"bitwise_xor","text":"<pre><code>bitwise_xor(self: Int, other: Int) -&gt; Int\n</code></pre> <p>Bitwise XOR of two integers.</p> <p>Equivalent to Python <code>self ^ other</code>.</p>"},{"location":"pixeltable/functions/math/#pixeltable.functions.math.ceil","title":"ceil","text":"<pre><code>ceil(self: Float) -&gt; Float\n</code></pre> <p>Return the ceiling of the given number.</p> <p>Equivalent to Python <code>float(math.ceil(self))</code> if <code>self</code> is finite, or <code>self</code> itself if <code>self</code> is infinite. (This is slightly different from the default behavior of <code>math.ceil(self)</code>, which always returns an <code>int</code> and raises an error if <code>self</code> is infinite. The behavior in Pixeltable generalizes the Python operator and is chosen to align with the SQL standard.)</p>"},{"location":"pixeltable/functions/math/#pixeltable.functions.math.floor","title":"floor","text":"<pre><code>floor(self: Float) -&gt; Float\n</code></pre> <p>Return the ceiling of the given number.</p> <p>Equivalent to Python <code>float(math.floor(self))</code> if <code>self</code> is finite, or <code>self</code> itself if <code>self</code> is infinite. (This is slightly different from the default behavior of <code>math.floor(self)</code>, which always returns an <code>int</code> and raises an error if <code>self</code> is infinite. The behavior of Pixeltable generalizes the Python operator and is chosen to align with the SQL standard.)</p>"},{"location":"pixeltable/functions/math/#pixeltable.functions.math.pow","title":"pow","text":"<pre><code>pow(self: Int, other: Int) -&gt; Float\n</code></pre> <p>Raise <code>self</code> to the power of <code>other</code>.</p> <p>Equivalent to Python <code>self ** other</code>.</p>"},{"location":"pixeltable/functions/math/#pixeltable.functions.math.round","title":"round","text":"<pre><code>round(self: Float, digits: Optional[Int] = None) -&gt; Float\n</code></pre> <p>Round a number to a given precision in decimal digits.</p> <p>Equivalent to Python <code>builtins.round(self, digits or 0)</code>. Note that if <code>digits</code> is not specified, the behavior matches <code>builtins.round(self, 0)</code> rather than <code>builtins.round(self)</code>; this ensures that the return type is always <code>float</code> (as in SQL) rather than <code>int</code>.</p>"},{"location":"pixeltable/functions/mistralai/","title":"mistralai","text":""},{"location":"pixeltable/functions/mistralai/#pixeltable.functions.mistralai","title":"pixeltable.functions.mistralai","text":"<p>Pixeltable UDFs that wrap various endpoints from the Mistral AI API. In order to use them, you must first <code>pip install mistralai</code> and configure your Mistral AI credentials, as described in the Working with Mistral AI tutorial.</p>"},{"location":"pixeltable/functions/mistralai/#pixeltable.functions.mistralai.chat_completions","title":"chat_completions  <code>async</code>","text":"<pre><code>chat_completions(\n    messages: Json, *, model: String, model_kwargs: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Chat Completion API.</p> <p>Equivalent to the Mistral AI <code>chat/completions</code> API endpoint. For additional details, see: https://docs.mistral.ai/api/#tag/chat</p> <p>Request throttling: Applies the rate limit set in the config (section <code>mistral</code>, key <code>rate_limit</code>). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install mistralai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>Json</code>)           \u2013            <p>The prompt(s) to generate completions for.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>ID of the model to use. (See overview here: https://docs.mistral.ai/getting-started/models/)</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the Mistral <code>chat/completions</code> API. For details on the available parameters, see: https://docs.mistral.ai/api/#tag/chat</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>mistral-latest-small</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; messages = [{'role': 'user', 'content': tbl.prompt}]\n... tbl.add_computed_column(response=completions(messages, model='mistral-latest-small'))\n</code></pre>"},{"location":"pixeltable/functions/mistralai/#pixeltable.functions.mistralai.embeddings","title":"embeddings  <code>async</code>","text":"<pre><code>embeddings(input: String, *, model: String) -&gt; Array[(None,), Float]\n</code></pre> <p>Embeddings API.</p> <p>Equivalent to the Mistral AI <code>embeddings</code> API endpoint. For additional details, see: https://docs.mistral.ai/api/#tag/embeddings</p> <p>Request throttling: Applies the rate limit set in the config (section <code>mistral</code>, key <code>rate_limit</code>). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install mistralai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>String</code>)           \u2013            <p>Text to embed.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>ID of the model to use. (See overview here: https://docs.mistral.ai/getting-started/models/)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array[(None,), Float]</code>           \u2013            <p>An array representing the application of the given embedding to <code>input</code>.</p> </li> </ul>"},{"location":"pixeltable/functions/mistralai/#pixeltable.functions.mistralai.fim_completions","title":"fim_completions  <code>async</code>","text":"<pre><code>fim_completions(\n    prompt: String, *, model: String, model_kwargs: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Fill-in-the-middle Completion API.</p> <p>Equivalent to the Mistral AI <code>fim/completions</code> API endpoint. For additional details, see: https://docs.mistral.ai/api/#tag/fim</p> <p>Request throttling: Applies the rate limit set in the config (section <code>mistral</code>, key <code>rate_limit</code>). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install mistralai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>prompt</code>               (<code>String</code>)           \u2013            <p>The text/code to complete.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>ID of the model to use. (See overview here: https://docs.mistral.ai/getting-started/models/)</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the Mistral <code>fim/completions</code> API. For details on the available parameters, see: https://docs.mistral.ai/api/#tag/fim</p> </li> </ul> <p>For details on the other parameters, see: https://docs.mistral.ai/api/#tag/fim</p> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>codestral-latest</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(response=completions(tbl.prompt, model='codestral-latest'))\n</code></pre>"},{"location":"pixeltable/functions/ollama/","title":"ollama","text":"<p>Pixeltable integrates with the popular Ollama model server. To use these endpoints, you need to either have an Ollama server running locally, or explicitly specify an Ollama host in your Pixeltable configration. To specify an explicit host, either set the <code>OLLAMA_HOST</code> environment variable, or add an entry for <code>host</code> in the <code>ollama</code> section of your <code>$PIXELTABLE_HOME/config.toml</code> configuration file.</p>"},{"location":"pixeltable/functions/ollama/#pixeltable.functions.ollama","title":"pixeltable.functions.ollama","text":""},{"location":"pixeltable/functions/ollama/#pixeltable.functions.ollama.chat","title":"chat","text":"<pre><code>chat(\n    messages: Json,\n    *,\n    model: String,\n    tools: Optional[Json] = None,\n    format: Optional[String] = None,\n    options: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Generate the next message in a chat with a provided model.</p> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>Json</code>)           \u2013            <p>The messages of the chat.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model name.</p> </li> <li> <code>tools</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Tools for the model to use.</p> </li> <li> <code>format</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>The format of the response; must be one of <code>'json'</code> or <code>None</code>.</p> </li> <li> <code>options</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional options to pass to the <code>chat</code> call, such as <code>max_tokens</code>, <code>temperature</code>, <code>top_p</code>, and <code>top_k</code>. For details, see the Valid Parameters and Values section of the Ollama documentation.</p> </li> </ul>"},{"location":"pixeltable/functions/ollama/#pixeltable.functions.ollama.embed","title":"embed","text":"<pre><code>embed(\n    input: String,\n    *,\n    model: String,\n    truncate: Bool = True,\n    options: Optional[Json] = None\n) -&gt; Array[(None,), Float]\n</code></pre> <p>Generate embeddings from a model.</p> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>String</code>)           \u2013            <p>The input text to generate embeddings for.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model name.</p> </li> <li> <code>truncate</code>               (<code>Bool</code>, default:                   <code>True</code> )           \u2013            <p>Truncates the end of each input to fit within context length. Returns error if false and context length is exceeded.</p> </li> <li> <code>options</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional options to pass to the <code>embed</code> call. For details, see the Valid Parameters and Values section of the Ollama documentation.</p> </li> </ul>"},{"location":"pixeltable/functions/ollama/#pixeltable.functions.ollama.generate","title":"generate","text":"<pre><code>generate(\n    prompt: String,\n    *,\n    model: String,\n    suffix: String = \"\",\n    system: String = \"\",\n    template: String = \"\",\n    context: Optional[Json] = None,\n    raw: Bool = False,\n    format: Optional[String] = None,\n    options: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Generate a response for a given prompt with a provided model.</p> <p>Parameters:</p> <ul> <li> <code>prompt</code>               (<code>String</code>)           \u2013            <p>The prompt to generate a response for.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model name.</p> </li> <li> <code>suffix</code>               (<code>String</code>, default:                   <code>''</code> )           \u2013            <p>The text after the model response.</p> </li> <li> <code>format</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>The format of the response; must be one of <code>'json'</code> or <code>None</code>.</p> </li> <li> <code>system</code>               (<code>String</code>, default:                   <code>''</code> )           \u2013            <p>System message.</p> </li> <li> <code>template</code>               (<code>String</code>, default:                   <code>''</code> )           \u2013            <p>Prompt template to use.</p> </li> <li> <code>context</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>The context parameter returned from a previous call to <code>generate()</code>.</p> </li> <li> <code>raw</code>               (<code>Bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, no formatting will be applied to the prompt.</p> </li> <li> <code>options</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional options for the Ollama <code>chat</code> call, such as <code>max_tokens</code>, <code>temperature</code>, <code>top_p</code>, and <code>top_k</code>. For details, see the Valid Parameters and Values section of the Ollama documentation.</p> </li> </ul>"},{"location":"pixeltable/functions/openai/","title":"openai","text":""},{"location":"pixeltable/functions/openai/#pixeltable.functions.openai","title":"pixeltable.functions.openai","text":"<p>Pixeltable UDFs that wrap various endpoints from the OpenAI API. In order to use them, you must first <code>pip install openai</code> and configure your OpenAI credentials, as described in the Working with OpenAI tutorial.</p>"},{"location":"pixeltable/functions/openai/#pixeltable.functions.openai.chat_completions","title":"chat_completions  <code>async</code>","text":"<pre><code>chat_completions(\n    messages: Json,\n    *,\n    model: String,\n    model_kwargs: Optional[Json] = None,\n    tools: Optional[Json] = None,\n    tool_choice: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Creates a model response for the given chat conversation.</p> <p>Equivalent to the OpenAI <code>chat/completions</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/chat-completions</p> <p>Request throttling: Uses the rate limit-related headers returned by the API to throttle requests adaptively, based on available request and token capacity. No configuration is necessary.</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>Json</code>)           \u2013            <p>A list of messages to use for chat completion, as described in the OpenAI API documentation.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model to use for chat completion.</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the OpenAI <code>chat/completions</code> API. For details on the available parameters, see: https://platform.openai.com/docs/api-reference/chat/create</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>gpt-4o-mini</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; messages = [\n        {'role': 'system', 'content': 'You are a helpful assistant.'},\n        {'role': 'user', 'content': tbl.prompt}\n    ]\n    tbl.add_computed_column(response=chat_completions(messages, model='gpt-4o-mini'))\n</code></pre>"},{"location":"pixeltable/functions/openai/#pixeltable.functions.openai.embeddings","title":"embeddings  <code>async</code>","text":"<pre><code>embeddings(\n    input: String, *, model: String, model_kwargs: Optional[Json] = None\n) -&gt; Array[(None,), Float]\n</code></pre> <p>Creates an embedding vector representing the input text.</p> <p>Equivalent to the OpenAI <code>embeddings</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/embeddings</p> <p>Request throttling: Uses the rate limit-related headers returned by the API to throttle requests adaptively, based on available request and token capacity. No configuration is necessary.</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>String</code>)           \u2013            <p>The text to embed.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model to use for the embedding.</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the OpenAI <code>embeddings</code> API. For details on the available parameters, see: https://platform.openai.com/docs/api-reference/embeddings</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array[(None,), Float]</code>           \u2013            <p>An array representing the application of the given embedding to <code>input</code>.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>text-embedding-3-small</code> to an existing Pixeltable column <code>tbl.text</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(embed=embeddings(tbl.text, model='text-embedding-3-small'))\n</code></pre> <p>Add an embedding index to an existing column <code>text</code>, using the model <code>text-embedding-3-small</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_embedding_index(embedding=embeddings.using(model='text-embedding-3-small'))\n</code></pre>"},{"location":"pixeltable/functions/openai/#pixeltable.functions.openai.image_generations","title":"image_generations  <code>async</code>","text":"<pre><code>image_generations(\n    prompt: String,\n    *,\n    model: String = \"dall-e-2\",\n    model_kwargs: Optional[Json] = None\n) -&gt; Image\n</code></pre> <p>Creates an image given a prompt.</p> <p>Equivalent to the OpenAI <code>images/generations</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/images</p> <p>Request throttling: Applies the rate limit set in the config (section <code>openai.rate_limits</code>; use the model id as the key). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>prompt</code>               (<code>String</code>)           \u2013            <p>Prompt for the image.</p> </li> <li> <code>model</code>               (<code>String</code>, default:                   <code>'dall-e-2'</code> )           \u2013            <p>The model to use for the generations.</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the OpenAI <code>images/generations</code> API. For details on the available parameters, see: https://platform.openai.com/docs/api-reference/images/create</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Image</code>           \u2013            <p>The generated image.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>dall-e-2</code> to an existing Pixeltable column <code>tbl.text</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(gen_image=image_generations(tbl.text, model='dall-e-2'))\n</code></pre>"},{"location":"pixeltable/functions/openai/#pixeltable.functions.openai.invoke_tools","title":"invoke_tools","text":"<pre><code>invoke_tools(tools: Tools, response: Expr) -&gt; InlineDict\n</code></pre> <p>Converts an OpenAI response dict to Pixeltable tool invocation format and calls <code>tools._invoke()</code>.</p>"},{"location":"pixeltable/functions/openai/#pixeltable.functions.openai.moderations","title":"moderations  <code>async</code>","text":"<pre><code>moderations(input: String, *, model: String = 'omni-moderation-latest') -&gt; Json\n</code></pre> <p>Classifies if text is potentially harmful.</p> <p>Equivalent to the OpenAI <code>moderations</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/moderation</p> <p>Request throttling: Applies the rate limit set in the config (section <code>openai.rate_limits</code>; use the model id as the key). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>String</code>)           \u2013            <p>Text to analyze with the moderations model.</p> </li> <li> <code>model</code>               (<code>String</code>, default:                   <code>'omni-moderation-latest'</code> )           \u2013            <p>The model to use for moderations.</p> </li> </ul> <p>For details on the other parameters, see: https://platform.openai.com/docs/api-reference/moderations</p> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>Details of the moderations results.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>text-moderation-stable</code> to an existing Pixeltable column <code>tbl.input</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(moderations=moderations(tbl.text, model='text-moderation-stable'))\n</code></pre>"},{"location":"pixeltable/functions/openai/#pixeltable.functions.openai.speech","title":"speech  <code>async</code>","text":"<pre><code>speech(\n    input: String,\n    *,\n    model: String,\n    voice: String,\n    model_kwargs: Optional[Json] = None\n) -&gt; Audio\n</code></pre> <p>Generates audio from the input text.</p> <p>Equivalent to the OpenAI <code>audio/speech</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/text-to-speech</p> <p>Request throttling: Applies the rate limit set in the config (section <code>openai.rate_limits</code>; use the model id as the key). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>String</code>)           \u2013            <p>The text to synthesize into speech.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model to use for speech synthesis.</p> </li> <li> <code>voice</code>               (<code>String</code>)           \u2013            <p>The voice profile to use for speech synthesis. Supported options include: <code>alloy</code>, <code>echo</code>, <code>fable</code>, <code>onyx</code>, <code>nova</code>, and <code>shimmer</code>.</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the OpenAI <code>audio/speech</code> API. For details on the available parameters, see: https://platform.openai.com/docs/api-reference/audio/createSpeech</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Audio</code>           \u2013            <p>An audio file containing the synthesized speech.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>tts-1</code> to an existing Pixeltable column <code>tbl.text</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(audio=speech(tbl.text, model='tts-1', voice='nova'))\n</code></pre>"},{"location":"pixeltable/functions/openai/#pixeltable.functions.openai.transcriptions","title":"transcriptions  <code>async</code>","text":"<pre><code>transcriptions(\n    audio: Audio, *, model: String, model_kwargs: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Transcribes audio into the input language.</p> <p>Equivalent to the OpenAI <code>audio/transcriptions</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/speech-to-text</p> <p>Request throttling: Applies the rate limit set in the config (section <code>openai.rate_limits</code>; use the model id as the key). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>audio</code>               (<code>Audio</code>)           \u2013            <p>The audio to transcribe.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model to use for speech transcription.</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the OpenAI <code>audio/transcriptions</code> API. For details on the available parameters, see: https://platform.openai.com/docs/api-reference/audio/createTranscription</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the transcription and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>whisper-1</code> to an existing Pixeltable column <code>tbl.audio</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(transcription=transcriptions(tbl.audio, model='whisper-1', language='en'))\n</code></pre>"},{"location":"pixeltable/functions/openai/#pixeltable.functions.openai.translations","title":"translations  <code>async</code>","text":"<pre><code>translations(\n    audio: Audio, *, model: String, model_kwargs: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Translates audio into English.</p> <p>Equivalent to the OpenAI <code>audio/translations</code> API endpoint. For additional details, see: https://platform.openai.com/docs/guides/speech-to-text</p> <p>Request throttling: Applies the rate limit set in the config (section <code>openai.rate_limits</code>; use the model id as the key). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>audio</code>               (<code>Audio</code>)           \u2013            <p>The audio to translate.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model to use for speech transcription and translation.</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the OpenAI <code>audio/translations</code> API. For details on the available parameters, see: https://platform.openai.com/docs/api-reference/audio/createTranslation</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the translation and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>whisper-1</code> to an existing Pixeltable column <code>tbl.audio</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(translation=translations(tbl.audio, model='whisper-1', language='en'))\n</code></pre>"},{"location":"pixeltable/functions/openai/#pixeltable.functions.openai.vision","title":"vision  <code>async</code>","text":"<pre><code>vision(\n    prompt: String,\n    image: Image,\n    *,\n    model: String,\n    model_kwargs: Optional[Json] = None\n) -&gt; String\n</code></pre> <p>Analyzes an image with the OpenAI vision capability. This is a convenience function that takes an image and prompt, and constructs a chat completion request that utilizes OpenAI vision.</p> <p>For additional details, see: https://platform.openai.com/docs/guides/vision</p> <p>Request throttling: Uses the rate limit-related headers returned by the API to throttle requests adaptively, based on available request and token capacity. No configuration is necessary.</p> <p>Requirements:</p> <ul> <li><code>pip install openai</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>prompt</code>               (<code>String</code>)           \u2013            <p>A prompt for the OpenAI vision request.</p> </li> <li> <code>image</code>               (<code>Image</code>)           \u2013            <p>The image to analyze.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model to use for OpenAI vision.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>String</code>           \u2013            <p>The response from the OpenAI vision API.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>gpt-4o-mini</code> to an existing Pixeltable column <code>tbl.image</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(response=vision(\"What's in this image?\", tbl.image, model='gpt-4o-mini'))\n</code></pre>"},{"location":"pixeltable/functions/replicate/","title":"replicate","text":""},{"location":"pixeltable/functions/replicate/#pixeltable.functions.replicate","title":"pixeltable.functions.replicate","text":"<p>Pixeltable UDFs that wrap various endpoints from the Replicate API. In order to use them, you must first <code>pip install replicate</code> and configure your Replicate credentials, as described in the Working with Replicate tutorial.</p>"},{"location":"pixeltable/functions/replicate/#pixeltable.functions.replicate.run","title":"run  <code>async</code>","text":"<pre><code>run(input: Json, *, ref: String) -&gt; Json\n</code></pre> <p>Run a model on Replicate.</p> <p>For additional details, see: https://replicate.com/docs/topics/models/run-a-model</p> <p>Request throttling: Applies the rate limit set in the config (section <code>replicate</code>, key <code>rate_limit</code>). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install replicate</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>Json</code>)           \u2013            <p>The input parameters for the model.</p> </li> <li> <code>ref</code>               (<code>String</code>)           \u2013            <p>The name of the model to run.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>The output of the model.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>meta/meta-llama-3-8b-instruct</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; input = {'system_prompt': 'You are a helpful assistant.', 'prompt': tbl.prompt}\n... tbl.add_computed_column(response=run(input, ref='meta/meta-llama-3-8b-instruct'))\n</code></pre> <p>Add a computed column that uses the model <code>black-forest-labs/flux-schnell</code> to generate images from an existing Pixeltable column <code>tbl.prompt</code>:</p> <pre><code>&gt;&gt;&gt; input = {'prompt': tbl.prompt, 'go_fast': True, 'megapixels': '1'}\n... tbl.add_computed_column(response=run(input, ref='black-forest-labs/flux-schnell'))\n... tbl.add_computed_column(image=tbl.response.output[0].astype(pxt.Image))\n</code></pre>"},{"location":"pixeltable/functions/string/","title":"string","text":""},{"location":"pixeltable/functions/string/#pixeltable.functions.string","title":"pixeltable.functions.string","text":"<p>Pixeltable UDFs for <code>StringType</code>. It closely follows the Pandas <code>pandas.Series.str</code> API.</p> <p>Example:</p> <pre><code>import pixeltable as pxt\n\nt = pxt.get_table(...)\nt.select(t.str_col.capitalize()).collect()\n</code></pre>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.capitalize","title":"capitalize","text":"<pre><code>capitalize(self: String) -&gt; String\n</code></pre> <p>Return string with its first character capitalized and the rest lowercased.</p> <p>Equivalent to <code>str.capitalize()</code>.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.casefold","title":"casefold","text":"<pre><code>casefold(self: String) -&gt; String\n</code></pre> <p>Return a casefolded copy of string.</p> <p>Equivalent to <code>str.casefold()</code>.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.center","title":"center","text":"<pre><code>center(self: String, width: Int, fillchar: String = ' ') -&gt; String\n</code></pre> <p>Return a centered string of length <code>width</code>.</p> <p>Equivalent to <code>str.center()</code>.</p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>Int</code>)           \u2013            <p>Total width of the resulting string.</p> </li> <li> <code>fillchar</code>               (<code>String</code>, default:                   <code>' '</code> )           \u2013            <p>Character used for padding.</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.contains","title":"contains","text":"<pre><code>contains(self: String, substr: String, case: Bool = True) -&gt; Bool\n</code></pre> <p>Test if string contains a substring.</p> <p>Parameters:</p> <ul> <li> <code>substr</code>               (<code>String</code>)           \u2013            <p>string literal or regular expression</p> </li> <li> <code>case</code>               (<code>Bool</code>, default:                   <code>True</code> )           \u2013            <p>if False, ignore case</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.contains_re","title":"contains_re","text":"<pre><code>contains_re(self: String, pattern: String, flags: Int = 0) -&gt; Bool\n</code></pre> <p>Test if string contains a regular expression pattern.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>String</code>)           \u2013            <p>regular expression pattern</p> </li> <li> <code>flags</code>               (<code>Int</code>, default:                   <code>0</code> )           \u2013            <p>flags for the <code>re</code> module</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.count","title":"count","text":"<pre><code>count(self: String, pattern: String, flags: Int = 0) -&gt; Int\n</code></pre> <p>Count occurrences of pattern or regex.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>String</code>)           \u2013            <p>string literal or regular expression</p> </li> <li> <code>flags</code>               (<code>Int</code>, default:                   <code>0</code> )           \u2013            <p>flags for the <code>re</code> module</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.endswith","title":"endswith","text":"<pre><code>endswith(self: String, substr: String) -&gt; Bool\n</code></pre> <p>Return <code>True</code> if the string ends with the specified suffix, otherwise return <code>False</code>.</p> <p>Equivalent to <code>str.endswith()</code>.</p> <p>Parameters:</p> <ul> <li> <code>substr</code>               (<code>String</code>)           \u2013            <p>string literal</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.fill","title":"fill","text":"<pre><code>fill(self: String, width: Int, **kwargs: None) -&gt; String\n</code></pre> <p>Wraps the single paragraph in string, and returns a single string containing the wrapped paragraph.</p> <p>Equivalent to <code>textwrap.fill()</code>.</p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>Int</code>)           \u2013            <p>Maximum line width.</p> </li> <li> <code>kwargs</code>               (<code>None</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to <code>textwrap.fill()</code>.</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.find","title":"find","text":"<pre><code>find(\n    self: String, substr: String, start: Int = 0, end: Optional[Int] = None\n) -&gt; Int\n</code></pre> <p>Return the lowest index in string where <code>substr</code> is found within the slice <code>s[start:end]</code>.</p> <p>Equivalent to <code>str.find()</code>.</p> <p>Parameters:</p> <ul> <li> <code>substr</code>               (<code>String</code>)           \u2013            <p>substring to search for</p> </li> <li> <code>start</code>               (<code>Int</code>, default:                   <code>0</code> )           \u2013            <p>slice start</p> </li> <li> <code>end</code>               (<code>Optional[Int]</code>, default:                   <code>None</code> )           \u2013            <p>slice end</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.findall","title":"findall","text":"<pre><code>findall(self: String, pattern: String, flags: Int = 0) -&gt; Json\n</code></pre> <p>Find all occurrences of a regular expression pattern in string.</p> <p>Equivalent to <code>re.findall()</code>.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>String</code>)           \u2013            <p>regular expression pattern</p> </li> <li> <code>flags</code>               (<code>Int</code>, default:                   <code>0</code> )           \u2013            <p>flags for the <code>re</code> module</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.format","title":"format","text":"<pre><code>format(self: String, *args: None, **kwargs: None) -&gt; String\n</code></pre> <p>Perform string formatting.</p> <p>Equivalent to <code>str.format()</code>.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.fullmatch","title":"fullmatch","text":"<pre><code>fullmatch(\n    self: String, pattern: String, case: Bool = True, flags: Int = 0\n) -&gt; Bool\n</code></pre> <p>Determine if string fully matches a regular expression.</p> <p>Equivalent to <code>re.fullmatch()</code>.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>String</code>)           \u2013            <p>regular expression pattern</p> </li> <li> <code>case</code>               (<code>Bool</code>, default:                   <code>True</code> )           \u2013            <p>if False, ignore case</p> </li> <li> <code>flags</code>               (<code>Int</code>, default:                   <code>0</code> )           \u2013            <p>flags for the <code>re</code> module</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.index","title":"index","text":"<pre><code>index(\n    self: String, substr: String, start: Int = 0, end: Optional[Int] = None\n) -&gt; Int\n</code></pre> <p>Return the lowest index in string where <code>substr</code> is found within the slice <code>[start:end]</code>. Raises ValueError if <code>substr</code> is not found.</p> <p>Equivalent to <code>str.index()</code>.</p> <p>Parameters:</p> <ul> <li> <code>substr</code>               (<code>String</code>)           \u2013            <p>substring to search for</p> </li> <li> <code>start</code>               (<code>Int</code>, default:                   <code>0</code> )           \u2013            <p>slice start</p> </li> <li> <code>end</code>               (<code>Optional[Int]</code>, default:                   <code>None</code> )           \u2013            <p>slice end</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.isalnum","title":"isalnum","text":"<pre><code>isalnum(self: String) -&gt; Bool\n</code></pre> <p>Return <code>True</code> if all characters in the string are alphanumeric and there is at least one character, <code>False</code> otherwise.</p> <p>Equivalent to [<code>str.isalnum()</code>](https://docs.python.org/3/library/stdtypes.html#str.isalnum</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.isalpha","title":"isalpha","text":"<pre><code>isalpha(self: String) -&gt; Bool\n</code></pre> <p>Return <code>True</code> if all characters in the string are alphabetic and there is at least one character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isalpha()</code>.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.isascii","title":"isascii","text":"<pre><code>isascii(self: String) -&gt; Bool\n</code></pre> <p>Return <code>True</code> if the string is empty or all characters in the string are ASCII, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isascii()</code>.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.isdecimal","title":"isdecimal","text":"<pre><code>isdecimal(self: String) -&gt; Bool\n</code></pre> <p>Return <code>True</code> if all characters in the string are decimal characters and there is at least one character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isdecimal()</code>.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.isdigit","title":"isdigit","text":"<pre><code>isdigit(self: String) -&gt; Bool\n</code></pre> <p>Return <code>True</code> if all characters in the string are digits and there is at least one character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isdigit()</code>.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.isidentifier","title":"isidentifier","text":"<pre><code>isidentifier(self: String) -&gt; Bool\n</code></pre> <p>Return <code>True</code> if the string is a valid identifier according to the language definition, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isidentifier()</code></p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.islower","title":"islower","text":"<pre><code>islower(self: String) -&gt; Bool\n</code></pre> <p>Return <code>True</code> if all cased characters in the string are lowercase and there is at least one cased character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.islower()</code></p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.isnumeric","title":"isnumeric","text":"<pre><code>isnumeric(self: String) -&gt; Bool\n</code></pre> <p>Return <code>True</code> if all characters in the string are numeric characters, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isnumeric()</code></p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.isspace","title":"isspace","text":"<pre><code>isspace(self: String) -&gt; Bool\n</code></pre> <p>Return <code>True</code> if there are only whitespace characters in the string and there is at least one character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isspace()</code></p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.istitle","title":"istitle","text":"<pre><code>istitle(self: String) -&gt; Bool\n</code></pre> <p>Return <code>True</code> if the string is a titlecased string and there is at least one character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.istitle()</code></p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.isupper","title":"isupper","text":"<pre><code>isupper(self: String) -&gt; Bool\n</code></pre> <p>Return <code>True</code> if all cased characters in the string are uppercase and there is at least one cased character, <code>False</code> otherwise.</p> <p>Equivalent to <code>str.isupper()</code></p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.join","title":"join","text":"<pre><code>join(sep: String, elements: Json) -&gt; String\n</code></pre> <p>Return a string which is the concatenation of the strings in <code>elements</code>.</p> <p>Equivalent to <code>str.join()</code></p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.len","title":"len","text":"<pre><code>len(self: String) -&gt; Int\n</code></pre> <p>Return the number of characters in the string.</p> <p>Equivalent to <code>len(str)</code></p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.ljust","title":"ljust","text":"<pre><code>ljust(self: String, width: Int, fillchar: String = ' ') -&gt; String\n</code></pre> <p>Return the string left-justified in a string of length <code>width</code>.</p> <p>Equivalent to <code>str.ljust()</code></p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>Int</code>)           \u2013            <p>Minimum width of resulting string; additional characters will be filled with character defined in <code>fillchar</code>.</p> </li> <li> <code>fillchar</code>               (<code>String</code>, default:                   <code>' '</code> )           \u2013            <p>Additional character for filling.</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.lower","title":"lower","text":"<pre><code>lower(self: String) -&gt; String\n</code></pre> <p>Return a copy of the string with all the cased characters converted to lowercase.</p> <p>Equivalent to <code>str.lower()</code></p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.lstrip","title":"lstrip","text":"<pre><code>lstrip(self: String, chars: Optional[String] = None) -&gt; String\n</code></pre> <p>Return a copy of the string with leading characters removed. The <code>chars</code> argument is a string specifying the set of characters to be removed. If omitted or <code>None</code>, whitespace characters are removed.</p> <p>Equivalent to <code>str.lstrip()</code></p> <p>Parameters:</p> <ul> <li> <code>chars</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>The set of characters to be removed.</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.match","title":"match","text":"<pre><code>match(self: String, pattern: String, case: Bool = True, flags: Int = 0) -&gt; Bool\n</code></pre> <p>Determine if string starts with a match of a regular expression</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>String</code>)           \u2013            <p>regular expression pattern</p> </li> <li> <code>case</code>               (<code>Bool</code>, default:                   <code>True</code> )           \u2013            <p>if False, ignore case</p> </li> <li> <code>flags</code>               (<code>Int</code>, default:                   <code>0</code> )           \u2013            <p>flags for the <code>re</code> module</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.normalize","title":"normalize","text":"<pre><code>normalize(self: String, form: String) -&gt; String\n</code></pre> <p>Return the Unicode normal form.</p> <p>Equivalent to <code>unicodedata.normalize()</code></p> <p>Parameters:</p> <ul> <li> <code>form</code>               (<code>String</code>)           \u2013            <p>Unicode normal form (<code>'NFC'</code>, <code>'NFKC'</code>, <code>'NFD'</code>, <code>'NFKD'</code>)</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.pad","title":"pad","text":"<pre><code>pad(\n    self: String, width: Int, side: String = \"left\", fillchar: String = \" \"\n) -&gt; String\n</code></pre> <p>Pad string up to width</p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>Int</code>)           \u2013            <p>Minimum width of resulting string; additional characters will be filled with character defined in <code>fillchar</code>.</p> </li> <li> <code>side</code>               (<code>String</code>, default:                   <code>'left'</code> )           \u2013            <p>Side from which to fill resulting string (<code>'left'</code>, <code>'right'</code>, <code>'both'</code>)</p> </li> <li> <code>fillchar</code>               (<code>String</code>, default:                   <code>' '</code> )           \u2013            <p>Additional character for filling</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.partition","title":"partition","text":"<pre><code>partition(self: String, sep: String = ' ') -&gt; Json\n</code></pre> <p>Splits string at the first occurrence of <code>sep</code>, and returns 3 elements containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 elements containing string itself, followed by two empty strings.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.removeprefix","title":"removeprefix","text":"<pre><code>removeprefix(self: String, prefix: String) -&gt; String\n</code></pre> <p>Remove prefix. If the prefix is not present, returns string.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.removesuffix","title":"removesuffix","text":"<pre><code>removesuffix(self: String, suffix: String) -&gt; String\n</code></pre> <p>Remove suffix. If the suffix is not present, returns string.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.repeat","title":"repeat","text":"<pre><code>repeat(self: String, n: Int) -&gt; String\n</code></pre> <p>Repeat string <code>n</code> times.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.replace","title":"replace","text":"<pre><code>replace(\n    self: String, substr: String, repl: String, n: Optional[Int] = None\n) -&gt; String\n</code></pre> <p>Replace occurrences of <code>substr</code> with <code>repl</code>.</p> <p>Equivalent to <code>str.replace()</code>.</p> <p>Parameters:</p> <ul> <li> <code>substr</code>               (<code>String</code>)           \u2013            <p>string literal</p> </li> <li> <code>repl</code>               (<code>String</code>)           \u2013            <p>replacement string</p> </li> <li> <code>n</code>               (<code>Optional[Int]</code>, default:                   <code>None</code> )           \u2013            <p>number of replacements to make (if <code>None</code>, replace all occurrences)</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.replace_re","title":"replace_re","text":"<pre><code>replace_re(\n    self: String,\n    pattern: String,\n    repl: String,\n    n: Optional[Int] = None,\n    flags: Int = 0,\n) -&gt; String\n</code></pre> <p>Replace occurrences of a regular expression pattern with <code>repl</code>.</p> <p>Equivalent to <code>re.sub()</code>.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>String</code>)           \u2013            <p>regular expression pattern</p> </li> <li> <code>repl</code>               (<code>String</code>)           \u2013            <p>replacement string</p> </li> <li> <code>n</code>               (<code>Optional[Int]</code>, default:                   <code>None</code> )           \u2013            <p>number of replacements to make (if <code>None</code>, replace all occurrences)</p> </li> <li> <code>flags</code>               (<code>Int</code>, default:                   <code>0</code> )           \u2013            <p>flags for the <code>re</code> module</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.reverse","title":"reverse","text":"<pre><code>reverse(self: String) -&gt; String\n</code></pre> <p>Return a reversed copy of the string.</p> <p>Equivalent to <code>str[::-1]</code>.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.rfind","title":"rfind","text":"<pre><code>rfind(\n    self: String,\n    substr: String,\n    start: Optional[Int] = 0,\n    end: Optional[Int] = None,\n) -&gt; Int\n</code></pre> <p>Return the highest index where <code>substr</code> is found, such that <code>substr</code> is contained within <code>[start:end]</code>.</p> <p>Equivalent to <code>str.rfind()</code>.</p> <p>Parameters:</p> <ul> <li> <code>substr</code>               (<code>String</code>)           \u2013            <p>substring to search for</p> </li> <li> <code>start</code>               (<code>Optional[Int]</code>, default:                   <code>0</code> )           \u2013            <p>slice start</p> </li> <li> <code>end</code>               (<code>Optional[Int]</code>, default:                   <code>None</code> )           \u2013            <p>slice end</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.rindex","title":"rindex","text":"<pre><code>rindex(\n    self: String,\n    substr: String,\n    start: Optional[Int] = 0,\n    end: Optional[Int] = None,\n) -&gt; Int\n</code></pre> <p>Return the highest index where <code>substr</code> is found, such that <code>substr</code> is contained within <code>[start:end]</code>. Raises ValueError if <code>substr</code> is not found.</p> <p>Equivalent to <code>str.rindex()</code>.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.rjust","title":"rjust","text":"<pre><code>rjust(self: String, width: Int, fillchar: String = ' ') -&gt; String\n</code></pre> <p>Return the string right-justified in a string of length <code>width</code>.</p> <p>Equivalent to <code>str.rjust()</code>.</p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>Int</code>)           \u2013            <p>Minimum width of resulting string.</p> </li> <li> <code>fillchar</code>               (<code>String</code>, default:                   <code>' '</code> )           \u2013            <p>Additional character for filling.</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.rpartition","title":"rpartition","text":"<pre><code>rpartition(self: String, sep: String = ' ') -&gt; Json\n</code></pre> <p>This method splits string at the last occurrence of <code>sep</code>, and returns a list containing the part before the separator, the separator itself, and the part after the separator.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.rstrip","title":"rstrip","text":"<pre><code>rstrip(self: String, chars: Optional[String] = None) -&gt; String\n</code></pre> <p>Return a copy of string with trailing characters removed.</p> <p>Equivalent to <code>str.rstrip()</code>.</p> <p>Parameters:</p> <ul> <li> <code>chars</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>The set of characters to be removed. If omitted or <code>None</code>, whitespace characters are removed.</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.slice","title":"slice","text":"<pre><code>slice(\n    self: String,\n    start: Optional[Int] = None,\n    stop: Optional[Int] = None,\n    step: Optional[Int] = None,\n) -&gt; String\n</code></pre> <p>Return a slice.</p> <p>Parameters:</p> <ul> <li> <code>start</code>               (<code>Optional[Int]</code>, default:                   <code>None</code> )           \u2013            <p>slice start</p> </li> <li> <code>stop</code>               (<code>Optional[Int]</code>, default:                   <code>None</code> )           \u2013            <p>slice end</p> </li> <li> <code>step</code>               (<code>Optional[Int]</code>, default:                   <code>None</code> )           \u2013            <p>slice step</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.slice_replace","title":"slice_replace","text":"<pre><code>slice_replace(\n    self: String,\n    start: Optional[Int] = None,\n    stop: Optional[Int] = None,\n    repl: Optional[String] = None,\n) -&gt; String\n</code></pre> <p>Replace a positional slice with another value.</p> <p>Parameters:</p> <ul> <li> <code>start</code>               (<code>Optional[Int]</code>, default:                   <code>None</code> )           \u2013            <p>slice start</p> </li> <li> <code>stop</code>               (<code>Optional[Int]</code>, default:                   <code>None</code> )           \u2013            <p>slice end</p> </li> <li> <code>repl</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>replacement value</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.startswith","title":"startswith","text":"<pre><code>startswith(self: String, substr: String) -&gt; Int\n</code></pre> <p>Return <code>True</code> if string starts with <code>substr</code>, otherwise return <code>False</code>.</p> <p>Equivalent to <code>str.startswith()</code>.</p> <p>Parameters:</p> <ul> <li> <code>substr</code>               (<code>String</code>)           \u2013            <p>string literal</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.strip","title":"strip","text":"<pre><code>strip(self: String, chars: Optional[String] = None) -&gt; String\n</code></pre> <p>Return a copy of string with leading and trailing characters removed.</p> <p>Equivalent to <code>str.strip()</code>.</p> <p>Parameters:</p> <ul> <li> <code>chars</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>The set of characters to be removed. If omitted or <code>None</code>, whitespace characters are removed.</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.swapcase","title":"swapcase","text":"<pre><code>swapcase(self: String) -&gt; String\n</code></pre> <p>Return a copy of string with uppercase characters converted to lowercase and vice versa.</p> <p>Equivalent to <code>str.swapcase()</code>.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.title","title":"title","text":"<pre><code>title(self: String) -&gt; String\n</code></pre> <p>Return a titlecased version of string, i.e. words start with uppercase characters, all remaining cased characters are lowercase.</p> <p>Equivalent to <code>str.title()</code>.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.upper","title":"upper","text":"<pre><code>upper(self: String) -&gt; String\n</code></pre> <p>Return a copy of string converted to uppercase.</p> <p>Equivalent to <code>str.upper()</code>.</p>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.wrap","title":"wrap","text":"<pre><code>wrap(self: String, width: Int, **kwargs: None) -&gt; Json\n</code></pre> <p>Wraps the single paragraph in string so every line is at most <code>width</code> characters long. Returns a list of output lines, without final newlines.</p> <p>Equivalent to <code>textwrap.fill()</code>.</p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>Int</code>)           \u2013            <p>Maximum line width.</p> </li> <li> <code>kwargs</code>               (<code>None</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to <code>textwrap.fill()</code>.</p> </li> </ul>"},{"location":"pixeltable/functions/string/#pixeltable.functions.string.zfill","title":"zfill","text":"<pre><code>zfill(self: String, width: Int) -&gt; String\n</code></pre> <p>Pad a numeric string with ASCII <code>0</code> on the left to a total length of <code>width</code>.</p> <p>Equivalent to <code>str.zfill()</code>.</p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>Int</code>)           \u2013            <p>Minimum width of resulting string.</p> </li> </ul>"},{"location":"pixeltable/functions/timestamp/","title":"timestamp","text":""},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp","title":"pixeltable.functions.timestamp","text":"<p>Pixeltable UDFs for <code>TimestampType</code>.</p> <p>Usage example:</p> <pre><code>import pixeltable as pxt\n\nt = pxt.get_table(...)\nt.select(t.timestamp_col.year, t.timestamp_col.weekday()).collect()\n</code></pre>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.astimezone","title":"astimezone","text":"<pre><code>astimezone(self: Timestamp, tz: String) -&gt; Timestamp\n</code></pre> <p>Convert the datetime to the given time zone.</p> <p>Parameters:</p> <ul> <li> <code>tz</code>               (<code>String</code>)           \u2013            <p>The time zone to convert to. Must be a valid time zone name from the IANA Time Zone Database.</p> </li> </ul>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.day","title":"day","text":"<pre><code>day(self: Timestamp) -&gt; Int\n</code></pre> <p>Between 1 and the number of days in the given month of the given year.</p> <p>Equivalent to <code>datetime.day</code>.</p>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.hour","title":"hour","text":"<pre><code>hour(self: Timestamp) -&gt; Int\n</code></pre> <p>Between 0 and 23 inclusive.</p> <p>Equivalent to <code>datetime.hour</code>.</p>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.isocalendar","title":"isocalendar","text":"<pre><code>isocalendar(self: Timestamp) -&gt; Json\n</code></pre> <p>Return a dictionary with three entries: <code>'year'</code>, <code>'week'</code>, and <code>'weekday'</code>.</p> <p>Equivalent to <code>datetime.isocalendar()</code>.</p>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.isoformat","title":"isoformat","text":"<pre><code>isoformat(\n    self: Timestamp, sep: String = \"T\", timespec: String = \"auto\"\n) -&gt; String\n</code></pre> <p>Return a string representing the date and time in ISO 8601 format.</p> <p>Equivalent to <code>datetime.isoformat()</code>.</p> <p>Parameters:</p> <ul> <li> <code>sep</code>               (<code>String</code>, default:                   <code>'T'</code> )           \u2013            <p>Separator between date and time.</p> </li> <li> <code>timespec</code>               (<code>String</code>, default:                   <code>'auto'</code> )           \u2013            <p>The number of additional terms in the output. See the <code>datetime.isoformat()</code> documentation for more details.</p> </li> </ul>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.isoweekday","title":"isoweekday","text":"<pre><code>isoweekday(self: Timestamp) -&gt; Int\n</code></pre> <p>Return the day of the week as an integer, where Monday is 1 and Sunday is 7.</p> <p>Equivalent to <code>datetime.isoweekday()</code>.</p>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.make_timestamp","title":"make_timestamp","text":"<pre><code>make_timestamp(\n    year: Int,\n    month: Int,\n    day: Int,\n    hour: Int = 0,\n    minute: Int = 0,\n    second: Int = 0,\n    microsecond: Int = 0,\n) -&gt; Timestamp\n</code></pre> <p>Create a timestamp.</p> <p>Equivalent to <code>datetime()</code>.</p>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.microsecond","title":"microsecond","text":"<pre><code>microsecond(self: Timestamp) -&gt; Int\n</code></pre> <p>Between 0 and 999999 inclusive.</p> <p>Equivalent to <code>datetime.microsecond</code>.</p>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.minute","title":"minute","text":"<pre><code>minute(self: Timestamp) -&gt; Int\n</code></pre> <p>Between 0 and 59 inclusive.</p> <p>Equivalent to <code>datetime.minute</code>.</p>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.month","title":"month","text":"<pre><code>month(self: Timestamp) -&gt; Int\n</code></pre> <p>Between 1 and 12 inclusive.</p> <p>Equivalent to <code>datetime.month</code>.</p>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.posix_timestamp","title":"posix_timestamp","text":"<pre><code>posix_timestamp(self: Timestamp) -&gt; Float\n</code></pre> <p>Return POSIX timestamp corresponding to the datetime instance.</p> <p>Equivalent to <code>datetime.timestamp()</code>.</p>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.replace","title":"replace","text":"<pre><code>replace(\n    self: Timestamp,\n    year: Optional[Int] = None,\n    month: Optional[Int] = None,\n    day: Optional[Int] = None,\n    hour: Optional[Int] = None,\n    minute: Optional[Int] = None,\n    second: Optional[Int] = None,\n    microsecond: Optional[Int] = None,\n) -&gt; Timestamp\n</code></pre> <p>Return a datetime with the same attributes, except for those attributes given new values by whichever keyword arguments are specified.</p> <p>Equivalent to <code>datetime.replace()</code>.</p>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.second","title":"second","text":"<pre><code>second(self: Timestamp) -&gt; Int\n</code></pre> <p>Between 0 and 59 inclusive.</p> <p>Equivalent to <code>datetime.second</code>.</p>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.strftime","title":"strftime","text":"<pre><code>strftime(self: Timestamp, format: String) -&gt; String\n</code></pre> <p>Return a string representing the date and time, controlled by an explicit format string.</p> <p>Equivalent to <code>datetime.strftime()</code>.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>String</code>)           \u2013            <p>The format string to control the output. For a complete list of formatting directives, see <code>strftime()</code> and <code>strptime()</code> Behavior.</p> </li> </ul>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.toordinal","title":"toordinal","text":"<pre><code>toordinal(self: Timestamp) -&gt; Int\n</code></pre> <p>Return the proleptic Gregorian ordinal of the date, where January 1 of year 1 has ordinal 1.</p> <p>Equivalent to <code>datetime.toordinal()</code>.</p>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.weekday","title":"weekday","text":"<pre><code>weekday(self: Timestamp) -&gt; Int\n</code></pre> <p>Between 0 (Monday) and 6 (Sunday) inclusive.</p> <p>Equivalent to <code>datetime.weekday()</code>.</p>"},{"location":"pixeltable/functions/timestamp/#pixeltable.functions.timestamp.year","title":"year","text":"<pre><code>year(self: Timestamp) -&gt; Int\n</code></pre> <p>Between <code>MINYEAR</code> and <code>MAXYEAR</code> inclusive.</p> <p>Equivalent to <code>datetime.year</code>.</p>"},{"location":"pixeltable/functions/together/","title":"together","text":""},{"location":"pixeltable/functions/together/#pixeltable.functions.together","title":"pixeltable.functions.together","text":"<p>Pixeltable UDFs that wrap various endpoints from the Together AI API. In order to use them, you must first <code>pip install together</code> and configure your Together AI credentials, as described in the Working with Together AI tutorial.</p>"},{"location":"pixeltable/functions/together/#pixeltable.functions.together.chat_completions","title":"chat_completions  <code>async</code>","text":"<pre><code>chat_completions(\n    messages: Json, *, model: String, model_kwargs: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Generate chat completions based on a given prompt using a specified model.</p> <p>Equivalent to the Together AI <code>chat/completions</code> API endpoint. For additional details, see: https://docs.together.ai/reference/chat-completions-1</p> <p>Request throttling: Applies the rate limit set in the config (section <code>together.rate_limits</code>, key <code>chat</code>). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install together</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>messages</code>               (<code>Json</code>)           \u2013            <p>A list of messages comprising the conversation so far.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The name of the model to query.</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments for the Together <code>chat/completions</code> API. For details on the available parameters, see: https://docs.together.ai/reference/chat-completions-1</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>mistralai/Mixtral-8x7B-v0.1</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; messages = [{'role': 'user', 'content': tbl.prompt}]\n... tbl.add_computed_column(response=chat_completions(messages, model='mistralai/Mixtral-8x7B-v0.1'))\n</code></pre>"},{"location":"pixeltable/functions/together/#pixeltable.functions.together.completions","title":"completions  <code>async</code>","text":"<pre><code>completions(\n    prompt: String, *, model: String, model_kwargs: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Generate completions based on a given prompt using a specified model.</p> <p>Equivalent to the Together AI <code>completions</code> API endpoint. For additional details, see: https://docs.together.ai/reference/completions-1</p> <p>Request throttling: Applies the rate limit set in the config (section <code>together.rate_limits</code>, key <code>chat</code>). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install together</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>prompt</code>               (<code>String</code>)           \u2013            <p>A string providing context for the model to complete.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The name of the model to query.</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments for the Together <code>completions</code> API. For details on the available parameters, see: https://docs.together.ai/reference/completions-1</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the response and other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>mistralai/Mixtral-8x7B-v0.1</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(response=completions(tbl.prompt, model='mistralai/Mixtral-8x7B-v0.1'))\n</code></pre>"},{"location":"pixeltable/functions/together/#pixeltable.functions.together.embeddings","title":"embeddings  <code>async</code>","text":"<pre><code>embeddings(input: String, *, model: String) -&gt; Array[(None,), Float]\n</code></pre> <p>Query an embedding model for a given string of text.</p> <p>Equivalent to the Together AI <code>embeddings</code> API endpoint. For additional details, see: https://docs.together.ai/reference/embeddings-2</p> <p>Request throttling: Applies the rate limit set in the config (section <code>together.rate_limits</code>, key <code>embeddings</code>). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install together</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>input</code>               (<code>String</code>)           \u2013            <p>A string providing the text for the model to embed.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The name of the embedding model to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Array[(None,), Float]</code>           \u2013            <p>An array representing the application of the given embedding to <code>input</code>.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>togethercomputer/m2-bert-80M-8k-retrieval</code> to an existing Pixeltable column <code>tbl.text</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(response=embeddings(tbl.text, model='togethercomputer/m2-bert-80M-8k-retrieval'))\n</code></pre>"},{"location":"pixeltable/functions/together/#pixeltable.functions.together.image_generations","title":"image_generations  <code>async</code>","text":"<pre><code>image_generations(\n    prompt: String, *, model: String, model_kwargs: Optional[Json] = None\n) -&gt; Image\n</code></pre> <p>Generate images based on a given prompt using a specified model.</p> <p>Equivalent to the Together AI <code>images/generations</code> API endpoint. For additional details, see: https://docs.together.ai/reference/post_images-generations</p> <p>Request throttling: Applies the rate limit set in the config (section <code>together.rate_limits</code>, key <code>images</code>). If no rate limit is configured, uses a default of 600 RPM.</p> <p>Requirements:</p> <ul> <li><code>pip install together</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>prompt</code>               (<code>String</code>)           \u2013            <p>A description of the desired images.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The model to use for image generation.</p> </li> <li> <code>model_kwargs</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword args for the Together <code>images/generations</code> API. For details on the available parameters, see: https://docs.together.ai/reference/post_images-generations</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Image</code>           \u2013            <p>The generated image.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>stabilityai/stable-diffusion-xl-base-1.0</code> to an existing Pixeltable column <code>tbl.prompt</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(\n...     response=image_generations(tbl.prompt, model='stabilityai/stable-diffusion-xl-base-1.0')\n... )\n</code></pre>"},{"location":"pixeltable/functions/video/","title":"video","text":""},{"location":"pixeltable/functions/video/#pixeltable.functions.video","title":"pixeltable.functions.video","text":"<p>Pixeltable UDFs for <code>VideoType</code>.</p> <p>Example:</p> <pre><code>import pixeltable as pxt\nimport pixeltable.functions as pxtf\n\nt = pxt.get_table(...)\nt.select(pxtf.video.extract_audio(t.video_col)).collect()\n</code></pre>"},{"location":"pixeltable/functions/video/#pixeltable.functions.video.make_video","title":"make_video","text":"<pre><code>make_video(fps: int = 25)\n</code></pre> <p>Aggregator that creates a video from a sequence of images.</p>"},{"location":"pixeltable/functions/video/#pixeltable.functions.video.extract_audio","title":"extract_audio","text":"<pre><code>extract_audio(\n    video_path: Video,\n    stream_idx: Int = 0,\n    format: String = \"wav\",\n    codec: Optional[String] = None,\n) -&gt; Audio\n</code></pre> <p>Extract an audio stream from a video file, save it as a media file and return its path.</p> <p>Parameters:</p> <ul> <li> <code>stream_idx</code>               (<code>Int</code>, default:                   <code>0</code> )           \u2013            <p>Index of the audio stream to extract.</p> </li> <li> <code>format</code>               (<code>String</code>, default:                   <code>'wav'</code> )           \u2013            <p>The target audio format. (<code>'wav'</code>, <code>'mp3'</code>, <code>'flac'</code>).</p> </li> <li> <code>codec</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>The codec to use for the audio stream. If not provided, a default codec will be used.</p> </li> </ul>"},{"location":"pixeltable/functions/video/#pixeltable.functions.video.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata(video: Video) -&gt; Json\n</code></pre> <p>Gets various metadata associated with a video file and returns it as a dictionary.</p>"},{"location":"pixeltable/functions/vision/","title":"Computer Vision","text":""},{"location":"pixeltable/functions/vision/#pixeltable.functions.vision","title":"pixeltable.functions.vision","text":"<p>Pixeltable UDFs for Computer Vision.</p> <p>Example:</p> <pre><code>import pixeltable as pxt\nfrom pixeltable.functions import vision as pxtv\n\nt = pxt.get_table(...)\nt.select(pxtv.draw_bounding_boxes(t.img, boxes=t.boxes, label=t.labels)).collect()\n</code></pre>"},{"location":"pixeltable/functions/vision/#pixeltable.functions.vision.mean_ap","title":"mean_ap","text":"<pre><code>mean_ap()\n</code></pre> <p>Calculates the mean average precision (mAP) over <code>eval_detections()</code> results.</p> <p>Parameters:</p> <ul> <li><code>eval_dicts</code> (list[dict]): List of dictionaries as returned by     <code>eval_detections()</code>.</li> </ul> <p>Returns:</p> <ul> <li>A <code>dict[int, float]</code> mapping each label class to an average precision (AP) value for that class.</li> </ul>"},{"location":"pixeltable/functions/vision/#pixeltable.functions.vision.draw_bounding_boxes","title":"draw_bounding_boxes","text":"<pre><code>draw_bounding_boxes(\n    img: Image,\n    boxes: Json,\n    labels: Optional[Json] = None,\n    color: Optional[String] = None,\n    box_colors: Optional[Json] = None,\n    fill: Bool = False,\n    width: Int = 1,\n    font: Optional[String] = None,\n    font_size: Optional[Int] = None,\n) -&gt; Image\n</code></pre> <p>Draws bounding boxes on the given image.</p> <p>Labels can be any type that supports <code>str()</code> and is hashable (e.g., strings, ints, etc.).</p> <p>Colors can be specified as common HTML color names (e.g., 'red') supported by PIL's <code>ImageColor</code> module or as RGB hex codes (e.g., '#FF0000').</p> <p>If no colors are specified, this function randomly assigns each label a specific color based on a hash of the label.</p> <p>Parameters:</p> <ul> <li> <code>img</code>               (<code>Image</code>)           \u2013            <p>The image on which to draw the bounding boxes.</p> </li> <li> <code>boxes</code>               (<code>Json</code>)           \u2013            <p>List of bounding boxes, each represented as [xmin, ymin, xmax, ymax].</p> </li> <li> <code>labels</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>List of labels for each bounding box.</p> </li> <li> <code>color</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>Single color to be used for all bounding boxes and labels.</p> </li> <li> <code>box_colors</code>               (<code>Optional[Json]</code>, default:                   <code>None</code> )           \u2013            <p>List of colors, one per bounding box.</p> </li> <li> <code>fill</code>               (<code>Bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to fill the bounding boxes with color.</p> </li> <li> <code>width</code>               (<code>Int</code>, default:                   <code>1</code> )           \u2013            <p>Width of the bounding box borders.</p> </li> <li> <code>font</code>               (<code>Optional[String]</code>, default:                   <code>None</code> )           \u2013            <p>Name of a system font or path to a TrueType font file, as required by <code>PIL.ImageFont.truetype()</code>. If <code>None</code>, uses the default provided by <code>PIL.ImageFont.load_default()</code>.</p> </li> <li> <code>font_size</code>               (<code>Optional[Int]</code>, default:                   <code>None</code> )           \u2013            <p>Size of the font used for labels in points. Only used in conjunction with non-<code>None</code> <code>font</code> argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Image</code>           \u2013            <p>The image with bounding boxes drawn on it.</p> </li> </ul>"},{"location":"pixeltable/functions/vision/#pixeltable.functions.vision.eval_detections","title":"eval_detections","text":"<pre><code>eval_detections(\n    pred_bboxes: Json,\n    pred_labels: Json,\n    pred_scores: Json,\n    gt_bboxes: Json,\n    gt_labels: Json,\n    min_iou: Float = 0.5,\n) -&gt; Json\n</code></pre> <p>Evaluates the performance of a set of predicted bounding boxes against a set of ground truth bounding boxes.</p> <p>Parameters:</p> <ul> <li> <code>pred_bboxes</code>               (<code>Json</code>)           \u2013            <p>List of predicted bounding boxes, each represented as [xmin, ymin, xmax, ymax].</p> </li> <li> <code>pred_labels</code>               (<code>Json</code>)           \u2013            <p>List of predicted labels.</p> </li> <li> <code>pred_scores</code>               (<code>Json</code>)           \u2013            <p>List of predicted scores.</p> </li> <li> <code>gt_bboxes</code>               (<code>Json</code>)           \u2013            <p>List of ground truth bounding boxes, each represented as [xmin, ymin, xmax, ymax].</p> </li> <li> <code>gt_labels</code>               (<code>Json</code>)           \u2013            <p>List of ground truth labels.</p> </li> <li> <code>min_iou</code>               (<code>Float</code>, default:                   <code>0.5</code> )           \u2013            <p>Minimum intersection-over-union (IoU) threshold for a predicted bounding box to be considered a true positive.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A list of dictionaries, one per label class, with the following structure:</p> </li> <li> <code>Json</code>           \u2013            <p>```python</p> </li> <li> <code>Json</code>           \u2013            <p>{ 'min_iou': float,  # The value of <code>min_iou</code> used for the detections 'class': int,  # The label class 'tp': list[int],  # List of 1's and 0's indicating true positives for each                   # predicted bounding box of this class 'fp': list[int],  # List of 1's and 0's indicating false positives for each                   # predicted bounding box of this class; <code>fp[n] == 1 - tp[n]</code> 'scores': list[float],  # List of predicted scores for each bounding box of this class 'num_gts': int,  # Number of ground truth bounding boxes of this class</p> </li> <li> <code>Json</code>           \u2013            <p>}</p> </li> <li> <code>Json</code>           \u2013            <p>```</p> </li> </ul>"},{"location":"pixeltable/functions/whisper/","title":"whisper","text":""},{"location":"pixeltable/functions/whisper/#pixeltable.functions.whisper","title":"pixeltable.functions.whisper","text":"<p>Pixeltable UDF that wraps the OpenAI Whisper library.</p> <p>This UDF will cause Pixeltable to invoke the relevant model locally. In order to use it, you must first <code>pip install openai-whisper</code>.</p>"},{"location":"pixeltable/functions/whisper/#pixeltable.functions.whisper.transcribe","title":"transcribe","text":"<pre><code>transcribe(\n    audio: Audio,\n    *,\n    model: String,\n    temperature: Optional[Json] = (0.0, 0.2, 0.4, 0.6, 0.8, 1.0),\n    compression_ratio_threshold: Optional[Float] = 2.4,\n    logprob_threshold: Optional[Float] = -1.0,\n    no_speech_threshold: Optional[Float] = 0.6,\n    condition_on_previous_text: Bool = True,\n    initial_prompt: Optional[String] = None,\n    word_timestamps: Bool = False,\n    prepend_punctuations: String = \"\\\"'\u201c\u00bf([{-\",\n    append_punctuations: String = \"\\\"'.\u3002,\uff0c!\uff01?\uff1f:\uff1a\u201d)]}\u3001\",\n    decode_options: Optional[Json] = None\n) -&gt; Json\n</code></pre> <p>Transcribe an audio file using Whisper.</p> <p>This UDF runs a transcription model locally using the Whisper library, equivalent to the Whisper <code>transcribe</code> function, as described in the Whisper library documentation.</p> <p>Requirements:</p> <ul> <li><code>pip install openai-whisper</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>audio</code>               (<code>Audio</code>)           \u2013            <p>The audio file to transcribe.</p> </li> <li> <code>model</code>               (<code>String</code>)           \u2013            <p>The name of the model to use for transcription.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Json</code>           \u2013            <p>A dictionary containing the transcription and various other metadata.</p> </li> </ul> <p>Examples:</p> <p>Add a computed column that applies the model <code>base.en</code> to an existing Pixeltable column <code>tbl.audio</code> of the table <code>tbl</code>:</p> <pre><code>&gt;&gt;&gt; tbl.add_computed_column(result=transcribe(tbl.audio, model='base.en'))\n</code></pre>"},{"location":"pixeltable/iterators/audio-splitter/","title":"AudioSplitter","text":""},{"location":"pixeltable/iterators/audio-splitter/#pixeltable.iterators.AudioSplitter","title":"pixeltable.iterators.AudioSplitter","text":"<pre><code>AudioSplitter(\n    audio: str,\n    chunk_duration_sec: float,\n    *,\n    overlap_sec: float = 0.0,\n    min_chunk_duration_sec: float = 0.0\n)\n</code></pre> <p>Iterator over chunks of an audio file. The audio file is split into smaller chunks, where the duration of each chunk is determined by chunk_duration_sec. The iterator yields audio chunks as pxt.Audio, along with the start and end time of each chunk. If the input contains no audio, no chunks are yielded.</p> <p>Parameters:</p> <ul> <li> <code>chunk_duration_sec</code>               (<code>float</code>)           \u2013            <p>Audio chunk duration in seconds</p> </li> <li> <code>overlap_sec</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Overlap between consecutive chunks in seconds.</p> </li> <li> <code>min_chunk_duration_sec</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Drop the last chunk if it is smaller than min_chunk_duration_sec</p> </li> </ul>"},{"location":"pixeltable/iterators/component-iterator/","title":"ComponentIterator","text":""},{"location":"pixeltable/iterators/component-iterator/#pixeltable.iterators.ComponentIterator","title":"pixeltable.iterators.ComponentIterator","text":"<p>Base class for Pixeltable iterators.</p>"},{"location":"pixeltable/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.close","title":"close  <code>abstractmethod</code>","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Close the iterator and release all resources</p>"},{"location":"pixeltable/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.input_schema","title":"input_schema  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>input_schema() -&gt; dict[str, ColumnType]\n</code></pre> <p>Provide the Pixeltable types of the init() parameters</p> <p>The keys need to match the names of the init() parameters. This is equivalent to the parameters_types parameter of the @function decorator.</p>"},{"location":"pixeltable/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.output_schema","title":"output_schema  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>output_schema(\n    *args: Any, **kwargs: Any\n) -&gt; tuple[dict[str, ColumnType], list[str]]\n</code></pre> <p>Specify the dictionary returned by next() and a list of unstored column names</p> <p>Returns:</p> <ul> <li> <code>dict[str, ColumnType]</code>           \u2013            <p>a dictionary which is turned into a list of columns in the output table</p> </li> <li> <code>list[str]</code>           \u2013            <p>a list of unstored column names</p> </li> </ul>"},{"location":"pixeltable/iterators/component-iterator/#pixeltable.iterators.ComponentIterator.set_pos","title":"set_pos  <code>abstractmethod</code>","text":"<pre><code>set_pos(pos: int) -&gt; None\n</code></pre> <p>Set the iterator position to pos</p>"},{"location":"pixeltable/iterators/document-splitter/","title":"DocumentSplitter","text":""},{"location":"pixeltable/iterators/document-splitter/#pixeltable.iterators.DocumentSplitter","title":"pixeltable.iterators.DocumentSplitter","text":"<pre><code>DocumentSplitter(\n    document: str,\n    *,\n    separators: str,\n    limit: Optional[int] = None,\n    overlap: Optional[int] = None,\n    metadata: str = \"\",\n    html_skip_tags: Optional[list[str]] = None,\n    tiktoken_encoding: Optional[str] = \"cl100k_base\",\n    tiktoken_target_model: Optional[str] = None\n)\n</code></pre> <p>Iterator over chunks of a document. The document is chunked according to the specified <code>separators</code>.</p> <p>The iterator yields a <code>text</code> field containing the text of the chunk, and it may also include additional metadata fields if specified in the <code>metadata</code> parameter, as explained below.</p> <p>Chunked text will be cleaned with <code>ftfy.fix_text</code> to fix up common problems with unicode sequences.</p> <p>Parameters:</p> <ul> <li> <code>separators</code>               (<code>str</code>)           \u2013            <p>separators to use to chunk the document. Options are:  <code>'heading'</code>, <code>'paragraph'</code>, <code>'sentence'</code>, <code>'token_limit'</code>, <code>'char_limit'</code>, <code>'page'</code>.  This may be a comma-separated string, e.g., <code>'heading,token_limit'</code>.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>the maximum number of tokens or characters in each chunk, if <code>'token_limit'</code>  or <code>'char_limit'</code> is specified.</p> </li> <li> <code>metadata</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>additional metadata fields to include in the output. Options are:  <code>'title'</code>, <code>'heading'</code> (HTML and Markdown), <code>'sourceline'</code> (HTML), <code>'page'</code> (PDF), <code>'bounding_box'</code>  (PDF). The input may be a comma-separated string, e.g., <code>'title,heading,sourceline'</code>.</p> </li> </ul>"},{"location":"pixeltable/iterators/frame-iterator/","title":"FrameIterator","text":""},{"location":"pixeltable/iterators/frame-iterator/#pixeltable.iterators.FrameIterator","title":"pixeltable.iterators.FrameIterator","text":"<pre><code>FrameIterator(\n    video: str, *, fps: Optional[float] = None, num_frames: Optional[int] = None\n)\n</code></pre> <p>Iterator over frames of a video. At most one of <code>fps</code> or <code>num_frames</code> may be specified. If <code>fps</code> is specified, then frames will be extracted at the specified rate (frames per second). If <code>num_frames</code> is specified, then the exact number of frames will be extracted. If neither is specified, then all frames will be extracted. The first frame of the video will always be extracted, and the remaining frames will be spaced as evenly as possible.</p> <p>Parameters:</p> <ul> <li> <code>fps</code>               (<code>Optional[float]</code>, default:                   <code>None</code> )           \u2013            <p>Number of frames to extract per second of video. This may be a fractional value, such as 0.5. If omitted or set to 0.0, then the native framerate of the video will be used (all frames will be extracted). If <code>fps</code> is greater than the frame rate of the video, an error will be raised.</p> </li> <li> <code>num_frames</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Exact number of frames to extract. The frames will be spaced as evenly as possible. If <code>num_frames</code> is greater than the number of frames in the video, all frames will be extracted.</p> </li> </ul>"},{"location":"pixeltable/iterators/tile-iterator/","title":"TileIterator","text":""},{"location":"pixeltable/iterators/tile-iterator/#pixeltable.iterators.TileIterator","title":"pixeltable.iterators.TileIterator","text":"<pre><code>TileIterator(\n    image: Image,\n    *,\n    tile_size: tuple[int, int],\n    overlap: tuple[int, int] = (0, 0)\n)\n</code></pre> <p>Iterator over tiles of an image. Each image will be divided into tiles of size <code>tile_size</code>, and the tiles will be iterated over in row-major order (left-to-right, then top-to-bottom). An optional <code>overlap</code> parameter may be specified. If the tiles do not exactly cover the image, then the rightmost and bottommost tiles will be padded with blackspace, so that the output images all have the exact size <code>tile_size</code>.</p> <p>Parameters:</p> <ul> <li> <code>image</code>               (<code>Image</code>)           \u2013            <p>Image to split into tiles.</p> </li> <li> <code>tile_size</code>               (<code>tuple[int, int]</code>)           \u2013            <p>Size of each tile, as a pair of integers <code>[width, height]</code>.</p> </li> <li> <code>overlap</code>               (<code>tuple[int, int]</code>, default:                   <code>(0, 0)</code> )           \u2013            <p>Amount of overlap between adjacent tiles, as a pair of integers <code>[width, height]</code>.</p> </li> </ul>"}]}