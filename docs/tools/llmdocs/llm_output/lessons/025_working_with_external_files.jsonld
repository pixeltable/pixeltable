{
  "@context": "https://pixeltable.com/learn",
  "@type": "Tutorial",
  "@id": "working-with-external-files",
  "github_url": "https://github.com/pixeltable/pixeltable/blob/release/docs/notebooks/feature-guides/working-with-external-files.ipynb",
  "title": "Working with External Files",
  "objective": "Master external file handling, caching, and error management for media data in Pixeltable",
  "difficulty": "intermediate",
  "categories": ["media", "files", "caching", "storage", "error_handling"],
  "prerequisites": ["pixeltable-basics"],
  "imports_required": ["import tempfile", "import random", "import shutil", "import pixeltable as pxt"],
  "performance_notes": {
    "typical_runtime": "2-3 minutes depending on S3 downloads",
    "resource_requirements": "Network for S3 access, local disk for cache",
    "bottlenecks": ["S3 download speed", "file validation", "local disk I/O"]
  },
  "key_learnings": [
    "Media files stored as references, not embedded in database",
    "S3 files automatically cached locally on access",
    "Local paths preserved for local files, cached for remote",
    "Media validation occurs during insertion by default",
    "Error handling configurable via on_error parameter",
    "UDFs receive local file paths as strings",
    "fileurl and localpath properties provide access to original locations"
  ],
  "relationships": {
    "builds_on": ["table_creation", "data_insertion"],
    "enables": ["media_processing", "cloud_storage_integration"],
    "see_also": ["video-processing", "image-analysis"],
    "contrasts_with": ["embedded_binary_data"]
  },
  "steps": [
    {
      "number": 1,
      "section_title": "Installation and Setup",
      "intent": "Install dependencies for external file handling demo",
      "code": "%pip install -qU pixeltable boto3",
      "imports_used": [],
      "explanation": "Install Pixeltable and boto3 for S3 access. External file handling works with local and remote storage",
      "actual_output": "[Installation output]",
      "output_summary": "Pixeltable and S3 dependencies installed",
      "output_type": "text",
      "learns": [],
      "reinforces": ["installation", "cloud_dependencies"],
      "gotchas": [],
      "performance": {"execution_time": "10-30s", "scaling": "O(1)", "optimization": "demo"},
      "alternatives": {"description": "Skip boto3 if only using local files", "when_to_use": "Local-only workflows"},
      "state_after": {"tables": [], "views": [], "variables": [], "models_loaded": []},
      "pattern_refs": ["environment_setup", "cloud_dependencies"]
    },
    {
      "number": 2,
      "section_title": "Create Video Table",
      "intent": "Set up table for external video file references",
      "code": "import tempfile\nimport random\nimport shutil\nimport pixeltable as pxt\n\n# First drop the `external_data` directory if it exists, to ensure\n# a clean environment for the demo\npxt.drop_dir('external_data', force=True)\npxt.create_dir('external_data')",
      "imports_used": ["import tempfile", "import random", "import shutil", "import pixeltable as pxt"],
      "explanation": "Creates clean directory structure for external file demo. Video columns store file references, not binary data",
      "actual_output": "Connected to Pixeltable database at: postgresql+psycopg://postgres:@/pixeltable?host=/Users/asiegel/.pixeltable/pgdata\nCreated directory `external_data`.",
      "output_summary": "Database connected and demo directory created",
      "output_type": "text",
      "learns": [],
      "reinforces": ["directory_creation", "environment_setup"],
      "gotchas": [],
      "performance": {"execution_time": "100-500ms", "scaling": "O(1)", "optimization": "demo"},
      "alternatives": {"description": "Use existing directory", "when_to_use": "Working with existing project structure"},
      "state_after": {"tables": [], "views": [], "variables": [], "models_loaded": []},
      "pattern_refs": ["test_environment_setup"]
    },
    {
      "number": 3,
      "section_title": "Insert S3 Video Files",
      "intent": "Demonstrate inserting remote S3 file references",
      "code": "v = pxt.create_table('external_data.videos', {'video': pxt.Video})\n\nprefix = 's3://multimedia-commons/'\npaths = [\n    'data/videos/mp4/ffe/ffb/ffeffbef41bbc269810b2a1a888de.mp4',\n    'data/videos/mp4/ffe/feb/ffefebb41485539f964760e6115fbc44.mp4',\n    'data/videos/mp4/ffe/f73/ffef7384d698b5f70d411c696247169.mp4'\n]\nv.insert({'video': prefix + p} for p in paths)",
      "imports_used": [],
      "explanation": "Creates video table and inserts S3 references. Files remain in S3 but are cached locally on access",
      "actual_output": "Created table `videos`.\nComputing cells:   0%|                                                    | 0/6 [00:00<?, ? cells/s]\nInserting rows into `videos`: 3 rows [00:00, 1004.62 rows/s]\nComputing cells: 100%|████████████████████████████████████████████| 6/6 [00:00<00:00, 79.14 cells/s]\nInserted 3 rows with 0 errors.\n\nUpdateStatus(num_rows=3, num_computed_values=6, num_excs=0, updated_cols=[], cols_with_excs=[])",
      "output_summary": "Video table created and 3 S3 video references inserted successfully",
      "output_type": "text",
      "learns": ["s3_file_insertion", "external_file_references"],
      "reinforces": ["table_creation", "data_insertion"],
      "gotchas": ["Files downloaded and cached during insertion", "Requires internet connectivity"],
      "performance": {"execution_time": "1-3s", "scaling": "O(n) file downloads", "optimization": "demo"},
      "alternatives": {"description": "Use local file paths", "when_to_use": "Offline environments or local development"},
      "state_after": {"tables": ["external_data.videos"], "views": [], "variables": ["v", "prefix", "paths"], "models_loaded": []},
      "pattern_refs": ["s3_media_insertion", "external_storage_integration"]
    },
    {
      "number": 4,
      "section_title": "Query Cached File Paths",
      "intent": "Show how S3 files are cached locally and accessible as paths",
      "code": "rows = list(v.select(v.video).collect())\nrows[0]",
      "imports_used": [],
      "explanation": "S3 files automatically cached to local filesystem. Applications see local paths, not S3 URLs",
      "actual_output": "{'video': '/Users/asiegel/.pixeltable/file_cache/682f022a704d4459adb2f29f7fe9577c_0_1fcfcb221263cff76a2853250fbbb2e90375dd495454c0007bc6ff4430c9a4a7.mp4'}",
      "output_summary": "S3 file cached locally with hash-based filename in Pixeltable cache directory",
      "output_type": "text",
      "learns": ["automatic_file_caching", "local_path_access"],
      "reinforces": ["query_operations"],
      "gotchas": ["Cache directory managed by Pixeltable", "Cached filenames are hashes, not original names"],
      "performance": {"execution_time": "5-20ms", "scaling": "O(n)", "optimization": "demo"},
      "alternatives": {"description": "Access fileurl property for original S3 path", "when_to_use": "Need original location info"},
      "state_after": {"tables": ["external_data.videos"], "views": [], "variables": ["v", "prefix", "paths", "rows"], "models_loaded": []},
      "pattern_refs": ["cached_file_access", "local_path_resolution"]
    },
    {
      "number": 5,
      "section_title": "Insert Local File",
      "intent": "Demonstrate inserting and preserving local file paths",
      "code": "local_path = tempfile.mktemp(suffix='.mp4')\nshutil.copyfile(rows[0]['video'], local_path)\nlocal_path",
      "imports_used": [],
      "explanation": "Create local copy of cached file to demonstrate local file handling",
      "actual_output": "'/var/folders/hb/qd0dztsj43j_mdb6hbl1gzyc0000gn/T/tmp1jo4a7ca.mp4'",
      "output_summary": "Local file path created in temporary directory",
      "output_type": "text",
      "learns": [],
      "reinforces": ["file_operations"],
      "gotchas": ["Temporary files may be cleaned up by system"],
      "performance": {"execution_time": "10-100ms", "scaling": "O(file_size)", "optimization": "demo"},
      "alternatives": {"description": "Use permanent local directory", "when_to_use": "Production workflows"},
      "state_after": {"tables": ["external_data.videos"], "views": [], "variables": ["v", "prefix", "paths", "rows", "local_path"], "models_loaded": []},
      "pattern_refs": ["local_file_creation"]
    },
    {
      "number": 6,
      "section_title": "Insert Local File Reference",
      "intent": "Show that local file paths are preserved in Pixeltable",
      "code": "v.insert(video=local_path)",
      "imports_used": [],
      "explanation": "Local files inserted by reference - paths preserved without copying or caching",
      "actual_output": "Computing cells:   0%|                                                    | 0/2 [00:00<?, ? cells/s]\nInserting rows into `videos`: 1 rows [00:00, 725.78 rows/s]\nComputing cells: 100%|████████████████████████████████████████████| 2/2 [00:00<00:00, 53.23 cells/s]\nInserted 1 row with 0 errors.\n\nUpdateStatus(num_rows=1, num_computed_values=2, num_excs=0, updated_cols=[], cols_with_excs=[])",
      "output_summary": "Local file inserted successfully with original path preserved",
      "output_type": "text",
      "learns": ["local_file_path_preservation"],
      "reinforces": ["data_insertion"],
      "gotchas": ["File must remain accessible at original path", "No automatic backup of local files"],
      "performance": {"execution_time": "50-200ms", "scaling": "O(1)", "optimization": "demo"},
      "alternatives": {"description": "Copy to managed directory first", "when_to_use": "Files may be moved or deleted"},
      "state_after": {"tables": ["external_data.videos"], "views": [], "variables": ["v", "prefix", "paths", "rows", "local_path"], "models_loaded": []},
      "pattern_refs": ["local_file_insertion"]
    },
    {
      "number": 7,
      "section_title": "Verify Mixed File Paths",
      "intent": "Show how cached and local files coexist in same table",
      "code": "rows = list(v.select(v.video).collect())\nrows",
      "imports_used": [],
      "explanation": "Table contains mix of cached S3 files and local files, each with appropriate path type",
      "actual_output": "[{'video': '/Users/asiegel/.pixeltable/file_cache/682f022a704d4459adb2f29f7fe9577c_0_1fcfcb221263cff76a2853250fbbb2e90375dd495454c0007bc6ff4430c9a4a7.mp4'},\n {'video': '/Users/asiegel/.pixeltable/file_cache/682f022a704d4459adb2f29f7fe9577c_0_fc11428b32768ae782193a57ebcbad706f45bbd9fa13354471e0bcd798fee3ea.mp4'},\n {'video': '/Users/asiegel/.pixeltable/file_cache/682f022a704d4459adb2f29f7fe9577c_0_b9fb0d9411bc9cd183a36866911baa7a8834f22f665bce47608566b38485c16a.mp4'},\n {'video': '/var/folders/hb/qd0dztsj43j_mdb6hbl1gzyc0000gn/T/tmp1jo4a7ca.mp4'}]",
      "output_summary": "Four video paths: three in cache directory (S3 files) and one in temp directory (local file)",
      "output_type": "text",
      "learns": ["mixed_storage_handling"],
      "reinforces": ["query_operations", "file_path_management"],
      "gotchas": ["Different path patterns for different storage types"],
      "performance": {"execution_time": "5-20ms", "scaling": "O(n)", "optimization": "demo"},
      "alternatives": {"description": "Standardize on single storage type", "when_to_use": "Consistent deployment requirements"},
      "state_after": {"tables": ["external_data.videos"], "views": [], "variables": ["v", "prefix", "paths", "rows", "local_path"], "models_loaded": []},
      "pattern_refs": ["mixed_storage_access"]
    },
    {
      "number": 8,
      "section_title": "UDF File Path Access",
      "intent": "Demonstrate how UDFs receive local file paths",
      "code": "@pxt.udf\ndef f(v: pxt.Video) -> int:\n    print(f'{type(v)}: {v}')\n    return 1",
      "imports_used": [],
      "explanation": "UDFs receive media data as local file paths (strings), not binary data or URLs",
      "actual_output": "",
      "output_summary": "UDF defined to demonstrate file path parameter type",
      "output_type": "none",
      "learns": ["udf_media_parameters"],
      "reinforces": ["udf_creation"],
      "gotchas": ["Media parameters are strings, not binary data"],
      "performance": {"execution_time": "<1ms", "scaling": "O(1)", "optimization": "demo"},
      "alternatives": {"description": "Load file content within UDF", "when_to_use": "Need binary data access"},
      "state_after": {"tables": ["external_data.videos"], "views": [], "variables": ["v", "prefix", "paths", "rows", "local_path", "f"], "models_loaded": []},
      "pattern_refs": ["media_udf_definition"]
    },
    {
      "number": 9,
      "section_title": "Execute UDF on Media Files",
      "intent": "Show UDF execution with local file paths",
      "code": "v.select(f(v.video)).show()",
      "imports_used": [],
      "explanation": "UDF executes with local file paths as string parameters, enabling file processing libraries",
      "actual_output": "<class 'str'>: /Users/asiegel/.pixeltable/file_cache/682f022a704d4459adb2f29f7fe9577c_0_1fcfcb221263cff76a2853250fbbb2e90375dd495454c0007bc6ff4430c9a4a7.mp4\n<class 'str'>: /Users/asiegel/.pixeltable/file_cache/682f022a704d4459adb2f29f7fe9577c_0_fc11428b32768ae782193a57ebcbad706f45bbd9fa13354471e0bcd798fee3ea.mp4\n<class 'str'>: /Users/asiegel/.pixeltable/file_cache/682f022a704d4459adb2f29f7fe9577c_0_b9fb0d9411bc9cd183a36866911baa7a8834f22f665bce47608566b38485c16a.mp4\n<class 'str'>: /var/folders/hb/qd0dztsj43j_mdb6hbl1gzyc0000gn/T/tmp1jo4a7ca.mp4\n\n   f\n0  1\n1  1\n2  1\n3  1",
      "output_summary": "UDF received string file paths for all videos, including both cached and local files",
      "output_type": "table",
      "learns": ["udf_media_execution"],
      "reinforces": ["udf_execution", "computed_columns"],
      "gotchas": ["Files must exist and be readable at provided paths"],
      "performance": {"execution_time": "50-200ms", "scaling": "O(n)", "optimization": "demo"},
      "alternatives": {"description": "Process files in batch", "when_to_use": "Large-scale media processing"},
      "state_after": {"tables": ["external_data.videos"], "views": [], "variables": ["v", "prefix", "paths", "rows", "local_path", "f"], "models_loaded": []},
      "pattern_refs": ["media_processing_udf"]
    },
    {
      "number": 10,
      "section_title": "Invalid File Insertion - Default Error Handling",
      "intent": "Show default error handling for invalid file paths",
      "code": "v.insert(video=prefix + 'bad_path.mp4')",
      "imports_used": [],
      "explanation": "By default, Pixeltable validates media files and rejects invalid ones with immediate error",
      "actual_output": "Error: Failed to download s3://multimedia-commons/bad_path.mp4: 404 Not Found",
      "output_summary": "Insertion failed immediately due to non-existent S3 file",
      "output_type": "text",
      "learns": ["default_error_handling", "file_validation"],
      "reinforces": ["error_handling"],
      "gotchas": ["Default behavior fails fast on invalid files", "Network errors during insertion"],
      "performance": {"execution_time": "1-5s", "scaling": "O(1)", "optimization": "demo"},
      "alternatives": {"description": "Use on_error='ignore' to defer validation", "when_to_use": "Bulk imports with expected errors"},
      "state_after": {"tables": ["external_data.videos"], "views": [], "variables": ["v", "prefix", "paths", "rows", "local_path", "f"], "models_loaded": []},
      "pattern_refs": ["file_validation_error"]
    },
    {
      "number": 11,
      "section_title": "Corrupted File Insertion",
      "intent": "Demonstrate validation of file format and content",
      "code": "# create invalid .mp4\nwith tempfile.NamedTemporaryFile(mode='wb', suffix='.mp4', delete=False) as temp_file:\n    temp_file.write(random.randbytes(1024))\n    corrupted_path = temp_file.name\n\nv.insert(video=corrupted_path)",
      "imports_used": [],
      "explanation": "Pixeltable validates file format, not just existence. Random bytes in .mp4 file fail validation",
      "actual_output": "Computing cells: 100%|██████████████████████████████████████████| 2/2 [00:00<00:00, 1084.64 cells/s]\n\nError: Not a valid video: /var/folders/hb/qd0dztsj43j_mdb6hbl1gzyc0000gn/T/tmp3djgfyjp.mp4",
      "output_summary": "File validation failed due to corrupted video content despite .mp4 extension",
      "output_type": "text",
      "learns": ["file_content_validation"],
      "reinforces": ["error_handling", "file_validation"],
      "gotchas": ["File extension doesn't guarantee valid content", "Validation occurs during insertion"],
      "performance": {"execution_time": "100-500ms", "scaling": "O(file_size)", "optimization": "demo"},
      "alternatives": {"description": "Pre-validate files before insertion", "when_to_use": "Batch processing workflows"},
      "state_after": {"tables": ["external_data.videos"], "views": [], "variables": ["v", "prefix", "paths", "rows", "local_path", "f", "corrupted_path"], "models_loaded": []},
      "pattern_refs": ["content_validation_error"]
    },
    {
      "number": 12,
      "section_title": "Error Handling - Ignore Mode",
      "intent": "Show how to handle errors during batch insertion",
      "code": "v.insert([{'video': prefix + 'bad_path.mp4'}, {'video': corrupted_path}], on_error='ignore')",
      "imports_used": [],
      "explanation": "on_error='ignore' allows insertion to continue despite validation failures, storing error info instead",
      "actual_output": "Computing cells: 100%|████████████████████████████████████████████| 4/4 [00:00<00:00, 20.98 cells/s]\nInserting rows into `videos`: 2 rows [00:00, 671.63 rows/s]\nComputing cells: 100%|████████████████████████████████████████████| 4/4 [00:00<00:00, 20.13 cells/s]\nInserted 2 rows with 4 errors across 2 columns (videos.video, videos.None).\n\nUpdateStatus(num_rows=2, num_computed_values=4, num_excs=4, updated_cols=[], cols_with_excs=['videos.video', 'videos.None'])",
      "output_summary": "Two rows inserted with errors, allowing batch processing to continue",
      "output_type": "text",
      "learns": ["error_ignore_mode", "batch_error_handling"],
      "reinforces": ["error_handling", "batch_insertion"],
      "gotchas": ["Errors stored in metadata, not raised immediately", "Invalid files show as None"],
      "performance": {"execution_time": "1-5s", "scaling": "O(n)", "optimization": "production"},
      "alternatives": {"description": "Use on_error='abort' for fail-fast behavior", "when_to_use": "Clean data with no expected errors"},
      "state_after": {"tables": ["external_data.videos"], "views": [], "variables": ["v", "prefix", "paths", "rows", "local_path", "f", "corrupted_path"], "models_loaded": []},
      "pattern_refs": ["batch_error_handling"]
    },
    {
      "number": 13,
      "section_title": "Query Error Metadata",
      "intent": "Show how to access error information for failed insertions",
      "code": "v.select(v.video == None, v.video.errortype, v.video.errormsg).collect()",
      "imports_used": [],
      "explanation": "Media columns have errortype and errormsg properties to inspect validation failures",
      "actual_output": "   col_0 video_errortype                                     video_errormsg\n0  False            None                                               None\n1  False            None                                               None\n2  False            None                                               None\n3  False            None                                               None\n4   True           Error  Failed to download s3://multimedia-commons/bad...\n5   True           Error  Not a valid video: /var/folders/hb/qd0dztsj43j...",
      "output_summary": "Shows 4 valid videos (errortype=None) and 2 failed videos with error details",
      "output_type": "table",
      "learns": ["error_metadata_access"],
      "reinforces": ["query_operations", "error_handling"],
      "gotchas": ["Failed videos show as None in main column", "Error details in separate properties"],
      "performance": {"execution_time": "10-50ms", "scaling": "O(n)", "optimization": "demo"},
      "alternatives": {"description": "Filter on errortype to find only errors", "when_to_use": "Error analysis and debugging"},
      "state_after": {"tables": ["external_data.videos"], "views": [], "variables": ["v", "prefix", "paths", "rows", "local_path", "f", "corrupted_path"], "models_loaded": []},
      "pattern_refs": ["error_inspection"]
    },
    {
      "number": 14,
      "section_title": "Filter and Inspect Errors",
      "intent": "Show how to query only rows with errors for debugging",
      "code": "v.where(v.video.errortype != None).select(v.video.errormsg).collect()",
      "imports_used": [],
      "explanation": "Filter for error rows to analyze failures and determine corrective actions",
      "actual_output": "                                      video_errormsg\n0  Failed to download s3://multimedia-commons/bad...\n1  Not a valid video: /var/folders/hb/qd0dztsj43j...",
      "output_summary": "Two error messages: S3 download failure and content validation failure",
      "output_type": "table",
      "learns": ["error_filtering"],
      "reinforces": ["query_filtering", "error_analysis"],
      "gotchas": ["Error messages may be truncated in display"],
      "performance": {"execution_time": "10-50ms", "scaling": "O(n)", "optimization": "demo"},
      "alternatives": {"description": "Export error details for external analysis", "when_to_use": "Large-scale error debugging"},
      "state_after": {"tables": ["external_data.videos"], "views": [], "variables": ["v", "prefix", "paths", "rows", "local_path", "f", "corrupted_path"], "models_loaded": []},
      "pattern_refs": ["error_analysis"]
    },
    {
      "number": 15,
      "section_title": "Access Original File URLs",
      "intent": "Show how to access original file locations vs cached locations",
      "code": "v.select(v.video.fileurl, v.video.localpath).collect()",
      "imports_used": [],
      "explanation": "fileurl shows original location, localpath shows where file is actually accessible locally",
      "actual_output": "                                       video_fileurl  \\\n0  s3://multimedia-commons/data/videos/mp4/ffe/ff...   \n1  s3://multimedia-commons/data/videos/mp4/ffe/fe...   \n2  s3://multimedia-commons/data/videos/mp4/ffe/f7...   \n3  file:///var/folders/hb/qd0dztsj43j_mdb6hbl1gzy...   \n4                                               None   \n5                                               None   \n\n                                     video_localpath  \n0  /Users/asiegel/.pixeltable/file_cache/682f022a...  \n1  /Users/asiegel/.pixeltable/file_cache/682f022a...  \n2  /Users/asiegel/.pixeltable/file_cache/682f022a...  \n3  /var/folders/hb/qd0dztsj43j_mdb6hbl1gzyc0000gn...  \n4                                               None  \n5                                               None",
      "output_summary": "Shows original S3/file URLs vs actual local cache paths, with None for failed insertions",
      "output_type": "table",
      "learns": ["file_location_properties"],
      "reinforces": ["metadata_access"],
      "gotchas": ["Local files have file:// URLs", "Failed insertions have None for both properties"],
      "performance": {"execution_time": "10-50ms", "scaling": "O(n)", "optimization": "demo"},
      "alternatives": {"description": "Use fileurl for backup/migration planning", "when_to_use": "Infrastructure management"},
      "state_after": {"tables": ["external_data.videos"], "views": [], "variables": ["v", "prefix", "paths", "rows", "local_path", "f", "corrupted_path"], "models_loaded": []},
      "pattern_refs": ["file_metadata_access"]
    }
  ],
  "patterns": [
    {
      "name": "s3_media_insertion",
      "description": "Insert media files from S3 with automatic local caching",
      "confidence": "high",
      "frequency": 4,
      "first_seen": "working-with-external-files",
      "code_template": "table.insert({'media_col': 's3://bucket/path/file.ext'})",
      "parameters": {
        "s3_url": "Full S3 URL including bucket and object key",
        "media_type": "Video, Image, or Audio column type"
      },
      "variations": [
        {
          "name": "batch_s3_insertion",
          "difference": "Insert multiple S3 files in single operation",
          "code": "table.insert({'media': url} for url in s3_urls)"
        }
      ],
      "prerequisites": ["s3_access", "media_column"],
      "enables": ["cloud_storage_integration", "distributed_media_processing"],
      "performance_impact": "Network download and caching overhead",
      "reusable": true,
      "production_ready": true
    },
    {
      "name": "local_file_insertion", 
      "description": "Insert local media files by reference without copying",
      "confidence": "high",
      "frequency": 3,
      "first_seen": "working-with-external-files",
      "code_template": "table.insert({'media_col': '/local/path/file.ext'})",
      "parameters": {
        "local_path": "Absolute or relative path to local file",
        "media_type": "Video, Image, or Audio column type"
      },
      "variations": [
        {
          "name": "temporary_file_insertion",
          "difference": "Use temporary files (may be cleaned up)",
          "code": "table.insert({'media': tempfile.mktemp(suffix='.mp4')})"
        }
      ],
      "prerequisites": ["local_file_access", "media_column"],
      "enables": ["local_development", "existing_file_integration"],
      "performance_impact": "Minimal - references only",
      "reusable": true,
      "production_ready": true
    },
    {
      "name": "batch_error_handling",
      "description": "Handle errors gracefully during batch media insertion",
      "confidence": "high",
      "frequency": 2,
      "first_seen": "working-with-external-files",
      "code_template": "table.insert(rows, on_error='ignore')",
      "parameters": {
        "on_error": "Either 'abort' (default) or 'ignore'",
        "rows": "List of dictionaries with media references"
      },
      "variations": [
        {
          "name": "abort_on_error",
          "difference": "Fail fast on first error (default)",
          "code": "table.insert(rows, on_error='abort')"
        }
      ],
      "prerequisites": ["media_column"],
      "enables": ["robust_batch_processing", "data_quality_management"],
      "performance_impact": "Error validation overhead",
      "reusable": true,
      "production_ready": true
    },
    {
      "name": "media_processing_udf",
      "description": "Process media files in UDFs using local file paths",
      "confidence": "high",
      "frequency": 5,
      "first_seen": "working-with-external-files",
      "code_template": "@pxt.udf\ndef process(media: pxt.Video) -> RetType:\n    # media is a string path\n    return process_file(media)",
      "parameters": {
        "media_type": "pxt.Video, pxt.Image, or pxt.Audio",
        "return_type": "Any valid Pixeltable type"
      },
      "variations": [
        {
          "name": "multi_media_udf",
          "difference": "Process multiple media inputs",
          "code": "@pxt.udf\ndef process(vid: pxt.Video, img: pxt.Image) -> str:\n    return analyze_both(vid, img)"
        }
      ],
      "prerequisites": ["media_column", "udf_creation"],
      "enables": ["custom_media_processing", "integration_with_media_libraries"],
      "performance_impact": "File I/O and processing time",
      "reusable": true,
      "production_ready": true
    },
    {
      "name": "error_inspection",
      "description": "Query and analyze media insertion and validation errors",
      "confidence": "high",
      "frequency": 2,
      "first_seen": "working-with-external-files", 
      "code_template": "table.where(col.errortype != None).select(col.errormsg)",
      "parameters": {
        "media_column": "Any media column with potential errors"
      },
      "variations": [
        {
          "name": "error_type_filtering",
          "difference": "Filter by specific error types",
          "code": "table.where(col.errortype == 'ValidationError')"
        }
      ],
      "prerequisites": ["media_column", "error_prone_data"],
      "enables": ["data_quality_analysis", "debugging_media_issues"],
      "performance_impact": "Minimal query overhead",
      "reusable": true,
      "production_ready": true
    },
    {
      "name": "file_metadata_access",
      "description": "Access original file locations and cached paths",
      "confidence": "high",
      "frequency": 1,
      "first_seen": "working-with-external-files",
      "code_template": "table.select(col.fileurl, col.localpath)",
      "parameters": {
        "media_column": "Any media column"
      },
      "variations": [],
      "prerequisites": ["media_column"],
      "enables": ["backup_management", "infrastructure_monitoring"],
      "performance_impact": "Minimal metadata access",
      "reusable": true,
      "production_ready": true
    }
  ],
  "common_errors": [
    {
      "error_type": "Failed to download s3://... 404 Not Found",
      "frequency": "common",
      "cause": "S3 object doesn't exist or incorrect path",
      "symptoms": ["Download failure during insertion", "404 error in logs"],
      "solution": {
        "quick_fix": "Verify S3 path and object existence",
        "proper_fix": "Validate S3 paths before insertion"
      },
      "prevention": "Pre-validate file existence or use on_error='ignore'",
      "example": "s3://bucket/wrong/path.mp4",
      "first_seen": "working-with-external-files#10"
    },
    {
      "error_type": "Not a valid video: /path/to/file.mp4",
      "frequency": "occasional",
      "cause": "File corruption or wrong format despite extension",
      "symptoms": ["Content validation failure", "Format detection errors"],
      "solution": {
        "quick_fix": "Verify file integrity and format",
        "proper_fix": "Add pre-processing validation step"
      },
      "prevention": "Validate media files before database insertion",
      "example": "Corrupted .mp4 file with random bytes",
      "first_seen": "working-with-external-files#11"
    },
    {
      "error_type": "File not found at local path",
      "frequency": "occasional",
      "cause": "Local file moved, deleted, or path incorrect",
      "symptoms": ["Runtime errors during media access", "File not found exceptions"],
      "solution": {
        "quick_fix": "Verify file still exists at path",
        "proper_fix": "Copy files to managed storage"
      },
      "prevention": "Use absolute paths and managed storage locations",
      "example": "Temporary file cleaned up by system",
      "first_seen": "working-with-external-files#6"
    }
  ],
  "test_questions": [
    {
      "question": "How are S3 files handled when inserted into a media column?",
      "answer": "They are downloaded and cached locally, with applications accessing the cached local paths",
      "difficulty": "beginner"
    },
    {
      "question": "What type of parameter do UDFs receive for media columns?",
      "answer": "String file paths to locally accessible files, not binary data or URLs",
      "difficulty": "intermediate"
    },
    {
      "question": "What happens when you insert a corrupted media file with on_error='ignore'?",
      "answer": "The row is inserted with the media column as None and error details in errortype/errormsg properties",
      "difficulty": "intermediate"
    },
    {
      "question": "What's the difference between fileurl and localpath properties?",
      "answer": "fileurl shows the original location (S3 URL or file:// URL), localpath shows where the file is actually accessible",
      "difficulty": "advanced"
    }
  ],
  "production_tips": [
    {
      "tip": "Use on_error='ignore' for batch imports with expected failures",
      "impact": "Prevents entire batch from failing due to individual file issues",
      "implementation": "table.insert(rows, on_error='ignore') then analyze errors separately",
      "trade_offs": "Need to handle error inspection and cleanup separately",
      "example": "Bulk import from untrusted data sources"
    },
    {
      "tip": "Monitor cache directory size for S3-heavy workloads", 
      "impact": "Prevents disk space issues from unlimited caching",
      "implementation": "Set up monitoring for ~/.pixeltable/file_cache size",
      "trade_offs": "May need cache cleanup strategies",
      "example": "Large video processing pipelines"
    },
    {
      "tip": "Use absolute paths for local files in production",
      "impact": "Prevents path resolution issues across different execution contexts",
      "implementation": "Convert relative paths to absolute before insertion",
      "trade_offs": "Reduces portability across environments",
      "example": "os.path.abspath(relative_path)"
    },
    {
      "tip": "Pre-validate media files before insertion",
      "impact": "Catches issues early and improves batch processing reliability",
      "implementation": "Check file existence and basic format before insert",
      "trade_offs": "Additional validation overhead",
      "example": "Use ffprobe for video validation"
    }
  ],
  "pattern_maturity": {
    "novel_patterns": 0,
    "established_patterns": 6,
    "total_patterns": 6
  },
  "cookies": "🍪 External files are like cookies in a jar - you know where they are, but sometimes the jar gets moved and you have to go looking for them!"
}