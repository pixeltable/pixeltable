{
  "@context": "https://pixeltable.com/learn",
  "@type": "Tutorial",
  "@id": "udfs-in-pixeltable",
  "github_url": "https://github.com/pixeltable/pixeltable/blob/release/docs/notebooks/feature-guides/udfs-in-pixeltable.ipynb",
  "title": "UDFs in Pixeltable",
  "objective": "Learn to create custom UDFs, optimize with batching, and implement custom aggregates for production workloads",
  "difficulty": "intermediate",
  "categories": ["udfs", "optimization", "batching", "aggregation", "production"],
  "prerequisites": ["pixeltable-basics", "computed-columns"],
  "imports_required": ["pixeltable", "numpy", "pixeltable.func.Batch", "pixeltable.Aggregator", "pixeltable.functions"],
  "performance_notes": {
    "typical_runtime": "2-3 minutes",
    "resource_requirements": "Minimal CPU, benefits from GPU for batched operations",
    "bottlenecks": ["Non-batched UDF execution", "Large aggregations without indexing"]
  },
  "key_learnings": [
    "@pxt.udf decorator converts Python functions to column operations",
    "Type hints are REQUIRED for UDFs - Pixeltable needs types upfront",
    "Local UDFs serialize code, module UDFs store references",
    "Batching dramatically improves GPU operation performance",
    "Batch[T] type hint enables batch processing",
    "UDAs enable custom aggregation logic",
    "Changes to local UDFs only affect new columns"
  ],
  "relationships": {
    "builds_on": ["computed-columns", "@pxt.udf decorator"],
    "enables": ["custom-transformations", "gpu-optimization", "complex-aggregations"],
    "see_also": ["01_pixeltable_basics#step-9"],
    "contrasts_with": ["built-in-functions"]
  },
  "steps": [
    {
      "number": 1,
      "intent": "Set up demo table with string data",
      "code": "import pixeltable as pxt\n\n# Create the directory and table\npxt.drop_dir('udf_demo', force=True)  # Ensure a clean slate for the demo\npxt.create_dir('udf_demo')\nt = pxt.create_table('udf_demo.strings', {'input': pxt.String})\n\n# Add some sample data\nt.insert([{'input': 'Hello, world!'}, {'input': 'You can do a lot with Pixeltable UDFs.'}])\nt.show()",
      "imports_used": ["pixeltable"],
      "explanation": "Clean setup with string data for UDF demonstrations.",
      "actual_output": "                                    input\n0                           Hello, world!\n1  You can do a lot with Pixeltable UDFs.",
      "output_summary": "Table with two string rows",
      "output_type": "table",
      "learns": ["table setup for UDF testing"],
      "reinforces": ["table creation", "data insertion"],
      "gotchas": [],
      "performance": {
        "execution_time": "~100ms",
        "scaling": "O(n) for n rows",
        "optimization": "demo"
      },
      "alternatives": null,
      "state_after": {
        "tables": ["udf_demo.strings"],
        "views": [],
        "variables": ["t"],
        "models_loaded": []
      },
      "pattern_refs": ["setup_insert_transform_query"]
    },
    {
      "number": 2,
      "section_title": "What is a UDF?",
      "intent": "Create first UDF to find longest word",
      "code": "import numpy as np\n\ndef longest_word(sentence: str, strip_punctuation: bool = False) -> str:\n    words = sentence.split()\n    if strip_punctuation:  # Remove non-alphanumeric characters from each word\n        words = [''.join(filter(str.isalnum, word)) for word in words]\n    i = np.argmax([len(word) for word in words])\n    return words[i]",
      "imports_used": ["numpy"],
      "explanation": "Plain Python function before decoration. Shows logic without Pixeltable integration.",
      "actual_output": null,
      "output_summary": "Function defined but not yet a UDF",
      "output_type": "none",
      "learns": ["UDF logic structure", "parameter handling"],
      "reinforces": [],
      "gotchas": ["Not yet a UDF - just Python"],
      "performance": {
        "execution_time": "N/A",
        "scaling": "N/A",
        "optimization": "demo"
      },
      "alternatives": null,
      "state_after": {
        "tables": ["udf_demo.strings"],
        "views": [],
        "variables": ["t", "longest_word"],
        "models_loaded": []
      },
      "pattern_refs": []
    },
    {
      "number": 3,
      "intent": "Convert to Pixeltable UDF with decorator",
      "code": "@pxt.udf\ndef longest_word(sentence: str, strip_punctuation: bool = False) -> str:\n    words = sentence.split()\n    if strip_punctuation:  # Remove non-alphanumeric characters from each word\n        words = [''.join(filter(str.isalnum, word)) for word in words]\n    i = np.argmax([len(word) for word in words])\n    return words[i]",
      "imports_used": ["pixeltable", "numpy"],
      "explanation": "@pxt.udf decorator transforms function to operate on columns not individual values.",
      "actual_output": null,
      "output_summary": "UDF created and ready for column operations",
      "output_type": "none",
      "learns": ["@pxt.udf decorator", "column vs value operations"],
      "reinforces": ["type hints required"],
      "gotchas": ["Type hints MANDATORY for UDFs", "Now operates on columns not strings"],
      "performance": {
        "execution_time": "Instant",
        "scaling": "O(1) definition",
        "optimization": "demo"
      },
      "alternatives": {
        "description": "Could define as module UDF",
        "when_to_use": "When UDF needs versioning"
      },
      "state_after": {
        "tables": ["udf_demo.strings"],
        "views": [],
        "variables": ["t", "longest_word"],
        "models_loaded": []
      },
      "pattern_refs": ["udf_creation"]
    },
    {
      "number": 4,
      "intent": "Apply UDF as computed column",
      "code": "t.add_computed_column(longest_word=longest_word(t.input))\nt.show()",
      "imports_used": ["pixeltable"],
      "explanation": "UDF automatically applied to all existing rows. Orchestration handled by Pixeltable.",
      "actual_output": "                                    input longest_word\n0                           Hello, world!       Hello,\n1  You can do a lot with Pixeltable UDFs.   Pixeltable",
      "output_summary": "Longest words extracted but with punctuation",
      "output_type": "table",
      "learns": ["UDF as computed column", "automatic backfill"],
      "reinforces": ["computed columns", "incremental updates"],
      "gotchas": ["Punctuation included in results"],
      "performance": {
        "execution_time": "~10ms",
        "scaling": "O(n) for n rows",
        "optimization": "demo"
      },
      "alternatives": null,
      "state_after": {
        "tables": ["udf_demo.strings"],
        "views": [],
        "variables": ["t"],
        "models_loaded": []
      },
      "pattern_refs": ["computed_column_pattern"]
    },
    {
      "number": 5,
      "intent": "Test incremental updates with new data",
      "code": "t.insert(input='Pixeltable updates tables incrementally.')\nt.show()",
      "imports_used": ["pixeltable"],
      "explanation": "New rows automatically processed by existing UDF columns.",
      "actual_output": "                                      input    longest_word\n0                             Hello, world!          Hello,\n1    You can do a lot with Pixeltable UDFs.      Pixeltable\n2  Pixeltable updates tables incrementally.  incrementally.",
      "output_summary": "New row processed with trailing punctuation",
      "output_type": "table",
      "learns": ["incremental UDF execution"],
      "reinforces": ["automatic updates"],
      "gotchas": ["Punctuation still present"],
      "performance": {
        "execution_time": "~5ms",
        "scaling": "O(1) for single row",
        "optimization": "demo"
      },
      "alternatives": null,
      "state_after": {
        "tables": ["udf_demo.strings"],
        "views": [],
        "variables": ["t"],
        "models_loaded": []
      },
      "pattern_refs": ["incremental_update_pattern"]
    },
    {
      "number": 6,
      "intent": "Add column with strip_punctuation parameter",
      "code": "t.add_computed_column(\n    longest_word_2=longest_word(t.input, strip_punctuation=True)\n)\nt.show()",
      "imports_used": ["pixeltable"],
      "explanation": "Parameters can be columns or constants. Shows UDF flexibility.",
      "actual_output": "                                      input    longest_word longest_word_2\n0                             Hello, world!          Hello,          Hello\n1    You can do a lot with Pixeltable UDFs.      Pixeltable     Pixeltable\n2  Pixeltable updates tables incrementally.  incrementally.  incrementally",
      "output_summary": "Clean results without punctuation",
      "output_type": "table",
      "learns": ["UDF parameters", "mixing columns and constants"],
      "reinforces": ["computed columns"],
      "gotchas": [],
      "performance": {
        "execution_time": "~10ms",
        "scaling": "O(n)",
        "optimization": "demo"
      },
      "alternatives": null,
      "state_after": {
        "tables": ["udf_demo.strings"],
        "views": [],
        "variables": ["t"],
        "models_loaded": []
      },
      "pattern_refs": ["parameterized_udf"]
    },
    {
      "number": 7,
      "section_title": "Local and Module UDFs",
      "intent": "Modify UDF to demonstrate local vs module behavior",
      "code": "@pxt.udf\ndef longest_word(sentence: str, strip_punctuation: bool = False) -> str:\n    words = sentence.split()\n    if strip_punctuation:\n        words = [\n            word if word[-1].isalnum() else word[:-1]\n            for word in words\n        ]\n    i = np.argmax([len(word) for word in words])\n    return words[i]",
      "imports_used": ["pixeltable", "numpy"],
      "explanation": "Modified logic: only strips last character if punctuation. Local UDFs serialize code, existing columns keep old version.",
      "actual_output": null,
      "output_summary": "UDF redefined with new logic",
      "output_type": "none",
      "learns": ["local UDF code serialization", "versioning behavior"],
      "reinforces": ["UDF modification"],
      "gotchas": ["Existing columns keep old UDF version", "Only new columns use updated UDF"],
      "performance": {
        "execution_time": "Instant",
        "scaling": "O(1)",
        "optimization": "demo"
      },
      "alternatives": {
        "description": "Module UDFs update everywhere",
        "when_to_use": "When you want updates to propagate"
      },
      "state_after": {
        "tables": ["udf_demo.strings"],
        "views": [],
        "variables": ["t", "longest_word"],
        "models_loaded": []
      },
      "pattern_refs": ["local_vs_module_udf"]
    },
    {
      "number": 8,
      "intent": "Test that existing columns use old UDF version",
      "code": "t.insert(input=\"Let's check that it still works.\")\nt.show()",
      "imports_used": ["pixeltable"],
      "explanation": "Existing columns continue using serialized old version. Important for reproducibility.",
      "actual_output": "                                      input    longest_word longest_word_2\n0                             Hello, world!          Hello,          Hello\n1    You can do a lot with Pixeltable UDFs.      Pixeltable     Pixeltable\n2  Pixeltable updates tables incrementally.  incrementally.  incrementally\n3          Let's check that it still works.          works.          check",
      "output_summary": "Old columns use old logic (fully strips), showing 'check' not 'Let's'",
      "output_type": "table",
      "learns": ["UDF version persistence"],
      "reinforces": ["local UDF behavior"],
      "gotchas": ["Can be confusing if you expect updates"],
      "performance": {
        "execution_time": "~5ms",
        "scaling": "O(1)",
        "optimization": "demo"
      },
      "alternatives": null,
      "state_after": {
        "tables": ["udf_demo.strings"],
        "views": [],
        "variables": ["t"],
        "models_loaded": []
      },
      "pattern_refs": []
    },
    {
      "number": 9,
      "section_title": "Batching",
      "intent": "Create batched UDF for GPU optimization",
      "code": "from pixeltable.func import Batch\n\n@pxt.udf(batch_size=16)\ndef longest_word(sentences: Batch[str], strip_punctuation: bool = False) -> Batch[str]:\n    results = []\n    for sentence in sentences:\n        words = sentence.split()\n        if strip_punctuation:\n            words = [\n                word if word[-1].isalnum() else word[:-1]\n                for word in words\n            ]\n        i = np.argmax([len(word) for word in words])\n        results.append(words[i])\n    return results",
      "imports_used": ["pixeltable", "pixeltable.func.Batch", "numpy"],
      "explanation": "Batch[T] processes multiple rows at once. Critical for GPU operations. batch_size=16 in decorator.",
      "actual_output": null,
      "output_summary": "Batched UDF ready for efficient processing",
      "output_type": "none",
      "learns": ["Batch type hint", "batch_size parameter", "GPU optimization"],
      "reinforces": ["UDF modification"],
      "gotchas": ["Batch[str] != list[str]", "Parameters without Batch are constants", "Must return Batch"],
      "performance": {
        "execution_time": "Instant",
        "scaling": "O(n/batch_size)",
        "optimization": "production"
      },
      "alternatives": {
        "description": "Adjust batch_size for memory/speed tradeoff",
        "when_to_use": "GPU operations, embeddings, models"
      },
      "state_after": {
        "tables": ["udf_demo.strings"],
        "views": [],
        "variables": ["t", "longest_word"],
        "models_loaded": []
      },
      "pattern_refs": ["batched_udf_pattern", "gpu_optimization"]
    },
    {
      "number": 10,
      "intent": "Apply batched UDF to verify same results",
      "code": "t.add_computed_column(\n    longest_word_3_batched=longest_word(t.input, strip_punctuation=True)\n)\nt.show()",
      "imports_used": ["pixeltable"],
      "explanation": "Batched execution invisible to user but processes 16 rows at once internally.",
      "actual_output": "[Table showing longest_word_3_batched column with same results]",
      "output_summary": "Identical results but executed in batches",
      "output_type": "table",
      "learns": ["transparent batching", "performance without changes"],
      "reinforces": ["computed columns", "UDF application"],
      "gotchas": ["Last batch may be smaller than batch_size"],
      "performance": {
        "execution_time": "~10ms",
        "scaling": "O(n/16)",
        "optimization": "production"
      },
      "alternatives": null,
      "state_after": {
        "tables": ["udf_demo.strings"],
        "views": [],
        "variables": ["t"],
        "models_loaded": []
      },
      "pattern_refs": ["transparent_optimization"]
    },
    {
      "number": 11,
      "section_title": "UDAs (Aggregate UDFs)",
      "intent": "Create table for aggregation demo",
      "code": "import pixeltable as pxt\n\nt = pxt.create_table('udf_demo.values', {'val': pxt.Int})\nt.insert({'val': n} for n in range(50))",
      "imports_used": ["pixeltable"],
      "explanation": "Integer table for demonstrating custom aggregates. 50 rows for meaningful aggregation.",
      "actual_output": "Inserted 50 rows with 0 errors.",
      "output_summary": "Table with integers 0-49",
      "output_type": "text",
      "learns": ["aggregate setup"],
      "reinforces": ["table creation", "bulk insert"],
      "gotchas": [],
      "performance": {
        "execution_time": "~50ms",
        "scaling": "O(n)",
        "optimization": "demo"
      },
      "alternatives": null,
      "state_after": {
        "tables": ["udf_demo.strings", "udf_demo.values"],
        "views": [],
        "variables": ["t"],
        "models_loaded": []
      },
      "pattern_refs": []
    },
    {
      "number": 12,
      "intent": "Define custom sum_of_squares aggregate",
      "code": "@pxt.uda\nclass sum_of_squares(pxt.Aggregator):\n    def __init__(self):\n        # No data yet; initialize `cur_sum` to 0\n        self.cur_sum = 0\n\n    def update(self, val: int) -> None:\n        # Update the value of `cur_sum` with the new datapoint\n        self.cur_sum += val * val\n\n    def value(self) -> int:\n        # Retrieve the current value of `cur_sum`\n        return self.cur_sum",
      "imports_used": ["pixeltable"],
      "explanation": "UDAs need __init__, update(), and value() methods. Maintains state across rows.",
      "actual_output": null,
      "output_summary": "Custom aggregate defined",
      "output_type": "none",
      "learns": ["UDA structure", "Aggregator base class", "@pxt.uda decorator"],
      "reinforces": [],
      "gotchas": ["Must implement all three methods", "State management critical"],
      "performance": {
        "execution_time": "Instant",
        "scaling": "O(n) for n rows",
        "optimization": "production"
      },
      "alternatives": {
        "description": "Use built-in aggregates when available",
        "when_to_use": "Standard operations like sum, mean, count"
      },
      "state_after": {
        "tables": ["udf_demo.strings", "udf_demo.values"],
        "views": [],
        "variables": ["t", "sum_of_squares"],
        "models_loaded": []
      },
      "pattern_refs": ["custom_aggregate_pattern"]
    },
    {
      "number": 13,
      "intent": "Use custom aggregate in query",
      "code": "t.select(sum_of_squares(t.val)).collect()",
      "imports_used": ["pixeltable"],
      "explanation": "Custom aggregate works like built-in aggregates. Processes all rows.",
      "actual_output": "   sum_of_squares\n0           40425",
      "output_summary": "Sum of squares 0²+1²+...+49² = 40425",
      "output_type": "table",
      "learns": ["UDA usage", "aggregate queries"],
      "reinforces": ["select operations"],
      "gotchas": [],
      "performance": {
        "execution_time": "~20ms",
        "scaling": "O(n)",
        "optimization": "production"
      },
      "alternatives": null,
      "state_after": {
        "tables": ["udf_demo.strings", "udf_demo.values"],
        "views": [],
        "variables": ["t"],
        "models_loaded": []
      },
      "pattern_refs": ["aggregation_pattern"]
    },
    {
      "number": 14,
      "intent": "Group by with custom aggregate",
      "code": "t.group_by(t.val // 10).order_by(t.val // 10).select(\n    t.val // 10, sum_of_squares(t.val)\n).collect()",
      "imports_used": ["pixeltable"],
      "explanation": "Custom aggregates work with group_by. Groups by tens digit.",
      "actual_output": "   col_0  sum_of_squares\n0      0             285\n1      1            2185\n2      2            6085\n3      3           11985\n4      4           19885",
      "output_summary": "Sum of squares grouped by tens digit",
      "output_type": "table",
      "learns": ["grouped aggregation", "UDA with group_by"],
      "reinforces": ["group_by operations"],
      "gotchas": ["Groups processed independently"],
      "performance": {
        "execution_time": "~30ms",
        "scaling": "O(n + g) for g groups",
        "optimization": "production"
      },
      "alternatives": null,
      "state_after": {
        "tables": ["udf_demo.strings", "udf_demo.values"],
        "views": [],
        "variables": ["t"],
        "models_loaded": []
      },
      "pattern_refs": ["grouped_aggregation_pattern"]
    }
  ],
  "patterns": [
    {
      "name": "udf_creation",
      "description": "Convert Python function to Pixeltable UDF",
      "confidence": "high",
      "frequency": 5,
      "first_seen": "01_pixeltable_basics",
      "code_template": "@pxt.udf\ndef my_function(param: type) -> return_type:\n    # Process single value\n    return result",
      "parameters": {
        "param": "Input with required type hint",
        "return_type": "Output type (required)"
      },
      "variations": [
        {
          "name": "with_parameters",
          "difference": "Additional parameters for control",
          "code": "@pxt.udf\ndef func(data: str, option: bool = False) -> str:"
        }
      ],
      "prerequisites": ["type hints", "pixeltable basics"],
      "enables": ["computed columns", "custom transformations"],
      "performance_impact": "Row-by-row processing",
      "reusable": true,
      "production_ready": false
    },
    {
      "name": "batched_udf_pattern",
      "description": "Optimize UDF for batch processing (GPU)",
      "confidence": "high",
      "frequency": 1,
      "first_seen": "05_udfs_pixeltable",
      "code_template": "from pixeltable.func import Batch\n\n@pxt.udf(batch_size=16)\ndef batched_func(data: Batch[str]) -> Batch[str]:\n    results = []\n    for item in data:\n        results.append(process(item))\n    return results",
      "parameters": {
        "batch_size": "Number of rows to process together (8-64 typical)",
        "Batch[T]": "Wrapper type for batched parameters"
      },
      "variations": [],
      "prerequisites": ["basic UDF", "understanding batching"],
      "enables": ["GPU optimization", "efficient model inference"],
      "performance_impact": "10-100x speedup for GPU operations",
      "reusable": true,
      "production_ready": true
    },
    {
      "name": "local_vs_module_udf",
      "description": "Choose between local (serialized) and module (referenced) UDFs",
      "confidence": "high",
      "frequency": 2,
      "first_seen": "05_udfs_pixeltable",
      "code_template": "# Local UDF (notebook/script)\n@pxt.udf\ndef local_func(): ...\n\n# Module UDF (in .py file)\n# my_module.py:\n@pxt.udf\ndef module_func(): ...",
      "parameters": {},
      "variations": [],
      "prerequisites": ["UDF basics"],
      "enables": ["version control", "code organization"],
      "performance_impact": "None",
      "reusable": true,
      "production_ready": true
    },
    {
      "name": "custom_aggregate_pattern",
      "description": "Create custom aggregation logic",
      "confidence": "high",
      "frequency": 1,
      "first_seen": "05_udfs_pixeltable",
      "code_template": "@pxt.uda\nclass CustomAgg(pxt.Aggregator):\n    def __init__(self):\n        self.state = initial_value\n    \n    def update(self, val: type) -> None:\n        self.state = combine(self.state, val)\n    \n    def value(self) -> return_type:\n        return self.state",
      "parameters": {
        "state": "Internal accumulator",
        "update": "How to incorporate new values",
        "value": "Final result extraction"
      },
      "variations": [],
      "prerequisites": ["aggregation concepts", "class definition"],
      "enables": ["complex aggregations", "stateful operations"],
      "performance_impact": "O(n) for n rows",
      "reusable": true,
      "production_ready": true
    }
  ],
  "common_errors": [
    {
      "error_type": "TypeError: missing required type hints",
      "frequency": "common",
      "cause": "UDF parameters or return missing type hints",
      "symptoms": ["Decorator fails", "Function not recognized as UDF"],
      "solution": {
        "quick_fix": "Add type hints to all parameters and return",
        "proper_fix": "Use typing module for complex types"
      },
      "prevention": "Always include type hints",
      "example": "def my_udf(x) -> str:  # Missing type for x",
      "first_seen": "05_udfs_pixeltable#step-3"
    },
    {
      "error_type": "Batch type mismatch",
      "frequency": "occasional",
      "cause": "Mixing Batch[T] and list[T] incorrectly",
      "symptoms": ["Type errors", "Unexpected list processing"],
      "solution": {
        "quick_fix": "Use Batch[T] for batched data",
        "proper_fix": "Understand Batch vs list semantics"
      },
      "prevention": "Batch[T] for batching, list[T] for list columns",
      "example": "def func(data: list[str]) when should be Batch[str]",
      "first_seen": "05_udfs_pixeltable#step-9"
    },
    {
      "error_type": "UDF version confusion",
      "frequency": "occasional",
      "cause": "Modifying local UDF expecting updates",
      "symptoms": ["Old behavior persists", "Inconsistent results"],
      "solution": {
        "quick_fix": "Create new column with updated UDF",
        "proper_fix": "Use module UDFs for versioning"
      },
      "prevention": "Understand local vs module UDF behavior",
      "example": "Changing UDF after column creation",
      "first_seen": "05_udfs_pixeltable#step-7"
    }
  ],
  "test_questions": [
    "How do I create a custom UDF?",
    "What's the difference between local and module UDFs?",
    "How do I optimize UDFs for GPU?",
    "How do I create custom aggregates?",
    "Why are type hints required?",
    "When should I use batching?",
    "How do UDF updates affect existing columns?"
  ],
  "production_tips": [
    {
      "tip": "Always use batching for GPU operations",
      "impact": "10-100x performance improvement",
      "implementation": "@pxt.udf(batch_size=32) with Batch[T] types",
      "trade_offs": "Slightly more complex code",
      "example": "Embedding generation, model inference"
    },
    {
      "tip": "Module UDFs for production code",
      "impact": "Version control and updates",
      "implementation": "Define UDFs in .py files, import them",
      "trade_offs": "Requires file management",
      "example": "Production transformation pipeline"
    },
    {
      "tip": "Cache expensive computations in UDF",
      "impact": "Avoid repeated calculations",
      "implementation": "Store results in class variables",
      "trade_offs": "Memory usage",
      "example": "Model loading, preprocessing"
    }
  ],
  "pattern_maturity": {
    "novel_patterns": 2,
    "established_patterns": 3,
    "total_patterns": 5
  },
  "cookies": "🍪 Batched cookies bake faster than one at a time!"
}