---
title: "Video"
description: "Build a video search workflow with Pixeltable"
icon: "video"
---

# Building a Video Search Workflow

Pixeltable lets you build video search workflows in two phases:
1. Define your processing workflow (once)
2. Query your knowledge base (anytime)

<Steps>
  <Step title="Install Dependencies">
    ```bash
    pip install boto3 pixeltable tiktoken openai openai-whisper spacy sentence-transformers
    python -m spacy download en_core_web_sm
    ```
  </Step>

  <Step title="Define Your Workflow" icon="diagram-project">
    Create `table.py`:
    ```python
    import pixeltable as pxt
    from pixeltable.functions import whisper
    from pixeltable.functions.huggingface import sentence_transformer
    from pixeltable.iterators.string import StringSplitter
    import spacy

    # Initialize spaCy
    nlp = spacy.load("en_core_web_sm")

    # Initialize app structure
    pxt.drop_dir("audio_search", force=True)
    pxt.create_dir("audio_search")

    # Create audio table
    audio_t = pxt.create_table(
        "audio_search.audio", 
        {"audio_file": pxt.Audio}
    )

    # Add transcription workflow
    audio_t.add_computed_column(
        transcription=whisper.transcribe(
            audio=audio_t.audio_file, 
            model="base.en"
        )
    )

    # Create sentence-level view
    sentences_view = pxt.create_view(
        "audio_search.audio_sentence_chunks",
        audio_t,
        iterator=StringSplitter.create(
            text=audio_t.transcription.text, 
            separators="sentence"
        )
    )

    # Configure embedding model
    embed_model = sentence_transformer.using(
        model_id="intfloat/e5-large-v2"
    )

    # Add search capability
    sentences_view.add_embedding_index(
        column="text", 
        string_embed=embed_model
    )

    # Define search query
    @pxt.query
    def top_k(query_text: str):
        sim = sentences_view.text.similarity(query_text)
        return (
            sentences_view.order_by(sim, asc=False)
            .select(sentences_view.text, sim=sim)
            .limit(10)
        )
    ```
  </Step>

  <Step title="Use Your Workflow" icon="play">
    Create `app.py`:
    ```python
    import pixeltable as pxt
    
    # Connect to your tables and views
    audio_t = pxt.get_table("audio_search.audio")
    sentences_view = pxt.get_view("audio_search.audio_sentence_chunks")

    # Add audio files to the knowledge base
    audio_t.insert([{
        "audio_file": "s3://pixeltable-public/audio/10-minute tour of Pixeltable.mp3"
    }])

    # Perform search
    @pxt.query
    def search_audio(query_text: str):
        sim = sentences_view.text.similarity(query_text)
        return (
            sentences_view.order_by(sim, asc=False)
            .select(sentences_view.text, sim=sim)
            .limit(10)
        )

    # Example search
    results = search_audio("What are the key features of Pixeltable?")
    
    # Print results
    for result in results.collect():
        print(f"Similarity: {result['sim']:.3f}")
        print(f"Text: {result['text']}\n")
    ```
  </Step>
</Steps>

## What Makes This Different?

<CardGroup cols={1}>
  <Card title="Automatic Processing" icon="gears">
    Workflow handles transcription and embedding automatically:
    ```python
    audio_t.add_computed_column(
        transcription=whisper.transcribe(
            audio=audio_t.audio_file
        )
    )
    ```
  </Card>

  <Card title="Smart Chunking" icon="scissors">
    Intelligent sentence splitting using spaCy:
    ```python
    iterator=StringSplitter.create(
        text=audio_t.transcription.text,
        separators="sentence"
    )
    ```
  </Card>

  <Card title="Vector Search" icon="magnifying-glass">
    Fast search using E5 embeddings:
    ```python
    sentences_view.add_embedding_index(
        column="text",
        string_embed=embed_model
    )
    ```
  </Card>
</CardGroup>

## Workflow Components

<AccordionGroup>
  <Accordion title="Audio Transcription" icon="waveform">
    Uses OpenAI's Whisper for audio transcription:
    - Supports multiple audio formats
    - Automatic language detection
    - High accuracy transcription
    - Configurable model sizes (base.en, small.en, etc.)
  </Accordion>

  <Accordion title="Text Processing" icon="text-size">
    Splits transcriptions into units:
    - Sentence-level segmentation using spaCy
    - Maintains context boundaries
    - Natural language processing
    - Configurable chunking strategies
  </Accordion>

  <Accordion title="Vector Search" icon="database">
    Implements search using E5 embeddings:
    - High-quality vector representations
    - Fast similarity search
    - Configurable top-k retrieval
    - Similarity scores for ranking
  </Accordion>
</AccordionGroup>

## Advanced Usage

### Custom Search Functions

You can create custom search functions with different parameters:

```python
@pxt.query
def search_with_threshold(query_text: str, min_similarity: float = 0.7):
    sim = sentences_view.text.similarity(query_text)
    return (
        sentences_view.where(sim >= min_similarity)
        .order_by(sim, asc=False)
        .select(sentences_view.text, sim=sim)
    )
```

### Batch Processing

Process multiple audio files in batch:

```python
audio_files = [
    "s3://your-bucket/audio1.mp3",
    "s3://your-bucket/audio2.mp3",
    "s3://your-bucket/audio3.mp3"
]

audio_t.insert([{"audio_file": f} for f in audio_files])
```

### Different Embedding Models

You can use different sentence transformer models:

```python
# Alternative embedding models
embed_model = sentence_transformer.using(
    model_id="sentence-transformers/all-mpnet-base-v2"
)
# or
embed_model = sentence_transformer.using(
    model_id="sentence-transformers/all-MiniLM-L6-v2"
)
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Custom Chunking" icon="puzzle-piece" href="/docs/audio/custom-chunking">
    Learn how to implement custom text chunking strategies
  </Card>
  <Card title="Performance Tuning" icon="gauge-high" href="/docs/audio/performance">
    Optimize your audio search workflow for speed and accuracy
  </Card>
</CardGroup>