---
title: 'Tables'
description: 'Learn the fundamentals of Pixeltable tables, types, and the development lifecycle'
icon: 'database'
---

# Development Lifecycle

Pixeltable applications work in two distinct phases:
1. **Definition Phase**: Define your data structure and processing pipeline (once)
2. **Usage Phase**: Connect to and use your application (anytime)

<Note>
This separation allows you to define your schema and pipeline in one file, then use it across multiple applications or scripts.
</Note>

## Phase 1: Definition

Create `schema.py` to define your application structure:

```python
import pixeltable as pxt
from pixeltable.functions import openai

# Create a directory to organize data (optional)
pxt.drop_dir('movies', force=True)
pxt.create_dir('movies')

# Define your table structure
movies = pxt.create_table(
    path_str="movies.collection",
    schema_or_df={
        "title": pxt.String,
        "year": pxt.Int,
        "plot": pxt.String,
        "budget": pxt.Float
    }
)

# Add computed columns for AI processing
movies.add_computed_column(
    messages=[{
        "role": "user", 
        "content": f"Summarize this plot: {movies.plot}"
    }]
)

movies.add_computed_column(
    summary=openai.chat_completions(
        messages=movies.messages,
        model="gpt-4o-mini"
    ).choices[0].message.content
)
```

## Phase 2: Usage

Create `app.py` to use your defined structure:

```python
import pixeltable as pxt

# Connect to your existing table
movies = pxt.get_table("movies.collection")

# Use it!
movies.insert([{
    "title": "Inception",
    "year": 2010,
    "plot": "A thief who steals corporate secrets...",
    "budget": 160.0
}])

# View results
print(movies.collect())
```

## Type System

<AccordionGroup>
  <Accordion title="Basic Types" icon="code">
    Import types from the `pixeltable` package:
    ```python
    import pixeltable as pxt
    
    # Available basic types
    pxt.String   # Text data
    pxt.Int      # Integer numbers
    pxt.Float    # Decimal numbers
    pxt.Bool     # True/False values
    pxt.DateTime # Date and time values
    ```
  </Accordion>

  <Accordion title="Complex Types" icon="layer-group">
    Special types for AI/ML workflows:
    ```python
    pxt.Array    # Numerical arrays (embeddings)
    pxt.Json     # Arbitrary JSON structures
    pxt.Image    # Image files and metadata
    pxt.Video    # Video files and metadata
    pxt.Audio    # Audio files and metadata
    pxt.Document # Text documents and PDFs
    ```
  </Accordion>
</AccordionGroup>

## Data Operations

<CardGroup cols={1}>
  <Card title="Query Operations" icon="magnifying-glass">
    Filter and retrieve data:
    ```python
    # Basic row count
    movies.count()  # Returns total number of rows
    
    # Basic filtering
    movies.where(movies.budget >= 200.0).collect()
    
    # Select specific columns
    movies.select(movies.title, movies.year).collect()
    
    # Limit results
    movies.limit(5).collect()  # First 5 rows (no specific order)
    movies.head(5)  # First 5 rows by insertion order
    movies.tail(5)  # Last 5 rows by insertion order
    
    # Order results
    movies.order_by(movies.budget, asc=False).limit(5).collect()
    ```
  </Card>

  <Card title="String Operations" icon="font">
    Manipulate text data:
    ```python
    # String contains
    movies.where(movies.title.contains('Inception')).collect()
    
    # String replacement
    movies.update({
        'plot': movies.plot.replace('corporate secrets', 'subconscious secrets')
    })
    
    # String functions
    movies.update({
        'title': movies.title.upper(),        # Convert to uppercase
        'length': movies.title.len()          # Get string length
    })
    ```
  </Card>

  <Card title="Insert Operations" icon="plus">
    Add new data:
    ```python
    # Insert single row
    movies.insert(
        title='Inside Out 2',
        year=2024,
        plot='Emotions navigate puberty',
        budget=200.0
    )
    
    # Insert multiple rows
    movies.insert([
        {
            'title': 'Jurassic Park', 
            'year': 1993, 
            'plot': 'Dinosaur theme park disaster',
            'budget': 63.0
        },
        {
            'title': 'Titanic', 
            'year': 1997, 
            'plot': 'Ill-fated ocean liner romance',
            'budget': 200.0
        }
    ])
    ```
  </Card>

  <Card title="Update Operations" icon="pen-to-square">
    Modify existing data:
    ```python
    # Update all rows
    movies.update({
        'budget': movies.budget * 1.1  # Increase all budgets by 10%
    })
    
    # Conditional updates
    movies.where(
        movies.year < 2000
    ).update({
        'plot': movies.plot + ' (Classic Film)'
    })
    
    # Batch updates for multiple rows
    updates = [
        {'id': 1, 'budget': 175.0},
        {'id': 2, 'budget': 185.0}
    ]
    movies.batch_update(updates)
    ```
  </Card>

  <Card title="Delete Operations" icon="trash">
    Remove data with conditions:
    ```python
    # Delete specific rows
    movies.where(
        movies.year < 1995
    ).delete()
    
    # Delete with complex conditions
    movies.where(
        (movies.budget < 100.0) & 
        (movies.year < 2000)
    ).delete()
    
    # WARNING: Delete all rows (use with caution!)
    # movies.delete()  # Without where clause deletes all rows
    ```
  </Card>

  <Card title="Column Operations" icon="table-columns">
    Manage table structure:
    ```python
    # Add new column
    movies.add_column(rating=pxt.String)
    
    # Drop column
    movies.drop_column('rating')
    
    # View schema
    movies.describe()
    ```
  </Card>

  <Card title="Versioning" icon="clock-rotate-left">
    Manage table versions:
    ```python
    # Revert the last operation
    movies.revert()  # Cannot be undone!
    
    # Revert multiple times to go back further
    movies.revert()
    movies.revert()  # Goes back two operations
    ```
  </Card>

  <Card title="Export Operations" icon="file-export">
    Extract data for analysis:
    ```python
    # Get results as Python objects
    result = movies.limit(5).collect()
    first_row = result[0]  # Get first row as dict
    timestamps = result['timestamp']  # Get list of values for one column
    
    # Convert to Pandas
    df = result.to_pandas()
    df['revenue'].describe()  # Get statistics for revenue column
    ```
  </Card>
</CardGroup>

<Warning>
Always use a `where()` clause with `delete()`. Without it, all rows in the table will be deleted! While you can use `revert()` to undo operations, it's better to be careful with destructive operations.
</Warning>


## Best Practices

<CardGroup cols={2}>
  <Card title="Schema Definition" icon="file-code">
    - Keep schema definition in separate files
    - Use clear naming for directories and tables
    - Document computed column dependencies
  </Card>
  
  <Card title="Application Code" icon="code">
    - Use `get_table()` to connect to existing tables
    - Handle errors when table doesn't exist
    - Use batch operations for multiple rows
  </Card>
</CardGroup>

## Common Patterns

<AccordionGroup>
  <Accordion title="Development Workflow" icon="code-branch">
    1. Create `schema.py` for structure
    2. Test schema and pipeline
    3. Create `app.py` for usage
    4. Deploy both files
  </Accordion>

  <Accordion title="Production Setup" icon="rocket">
    ```python
    # schema.py - Run once to set up
    pxt.create_table(..., if_exists="ignore")
    
    # app.py - Production code
    table = pxt.get_table("myapp.mytable")
    if table is None:
        raise RuntimeError("Run schema.py first!")
    ```
  </Accordion>
</AccordionGroup>

## Additional Resources

<CardGroup cols={3}>
  <Card title="API Documentation" icon="book" href="https://pixeltable.github.io/pixeltable/">
    Complete API reference
  </Card>
  <Card title="Examples" icon="lightbulb" href="/docs/examples">
    Sample workflows
  </Card>
  <Card title="Cheat Sheet" icon="file" href="https://pixeltable.github.io/pixeltable/api-cheat-sheet/">
    Quick reference
  </Card>
</CardGroup>