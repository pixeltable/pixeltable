---
title: 'Custom Functions'
description: 'Create and use custom functions (UDFs) in Pixeltable'
icon: 'function'
---

# Overview

User-Defined Functions (UDFs) in Pixeltable allow you to:
- Write custom Python functions for data processing
- Integrate them into computed columns and queries
- Optimize performance through batching
- Create reusable components for your data workflow

<Note>
All UDFs require type hints for parameters and return values. This enables Pixeltable to validate and optimize your data workflow before execution.
</Note>

## Basic UDF Creation

<CodeGroup>
```python Basic
@pxt.udf
def add_tax(price: float, rate: float = 0.1) -> float:
    return price * (1 + rate)

# Use in computed column
table.add_computed_column(
    price_with_tax=add_tax(table.price)
)
```

```python With Type Checking
from typing import List

@pxt.udf
def process_tags(tags: List[str]) -> str:
    return ", ".join(sorted(tags))

# Use in computed column
table.add_computed_column(
    formatted_tags=process_tags(table.tags)
)
```
</CodeGroup>

## UDF Types

<Tabs>
  <Tab title="Local UDFs">
    ```python
    # Defined directly in your code
    @pxt.udf
    def extract_year(date_str: str) -> int:
        return int(date_str.split('-')[0])
        
    # Used immediately
    table.add_computed_column(
        year=extract_year(table.date)
    )
    ```
    <Note>
    Local UDFs are serialized with their columns. Changes to the UDF only affect new columns.
    </Note>
  </Tab>

  <Tab title="Module UDFs">
    ```python
    # In my_functions.py
    @pxt.udf
    def clean_text(text: str) -> str:
        return text.strip().lower()
        
    # In your application
    from my_functions import clean_text
    table.add_computed_column(
        clean_content=clean_text(table.content)
    )
    ```
    <Note>
    Module UDFs are referenced by path. Changes to the UDF affect all uses after reload.
    </Note>
  </Tab>

  <Tab title="Batched UDFs">
    ```python
    from pixeltable.func import Batch
    
    @pxt.udf(batch_size=32)
    def process_batch(items: Batch[str]) -> Batch[str]:
        results = []
        for item in items:
            results.append(item.upper())
        return results
        
    # Used like a regular UDF
    table.add_computed_column(
        processed=process_batch(table.text)
    )
    ```
    <Note>
    Batched UDFs process multiple rows at once for better performance.
    </Note>
  </Tab>
</Tabs>

## Supported Types

<AccordionGroup>
  <Accordion title="Basic Types" icon="code">
    Native Python types supported in UDFs:
    ```python
    @pxt.udf
    def process_data(
        text: str,           # String data
        count: int,          # Integer numbers
        score: float,        # Floating point
        active: bool,        # Boolean
        items: list[str],    # Generic lists
        meta: dict[str,any]  # Dictionaries
    ) -> str:
        return "Processed"
    ```
  </Accordion>

  <Accordion title="Complex Types" icon="layer-group">
    Pixeltable-specific types:
    ```python
    @pxt.udf
    def process_media(
        img: PIL.Image.Image,    # Images
        embeddings: pxt.Array,   # Numerical arrays
        config: pxt.Json,        # JSON data
        doc: pxt.Document        # Documents
    ) -> str:
        return "Processed"
    ```
  </Accordion>
</AccordionGroup>

## Tables as UDFs

<Info>
**Tables as UDFs:** Turn entire tables into reusable functions that can be used in other tables
</Info>

Pixeltable lets you convert an entire table into a UDF, making complex workflows more modular and reusable.

### How It Works (In 3 Simple Steps)

1. **Create a specialized table** with computed columns for your workflow
2. **Convert the table to a UDF** by specifying which column to return as output
3. **Use this table UDF** in other tables like any regular function

### Simple Example

```python
import time
from typing import Optional

import yfinance as yf

import pixeltable as pxt
from pixeltable.functions.openai import chat_completions, invoke_tools

DIRECTORY = 'agent'
OPENAI_MODEL = 'gpt-4o-mini'

# Start timing
start_time = time.time()

# Create Fresh Directory
pxt.drop_dir(DIRECTORY, force=True)
pxt.create_dir(DIRECTORY, if_exists='ignore')


# yfinance tool
@pxt.udf
def stock_info(ticker: str) -> Optional[dict]:
    """Get stock info for a given ticker symbol."""
    stock = yf.Ticker(ticker)
    return stock.info

# Create prompt with tool outputs
@pxt.udf
def create_prompt(question: str, tool_outputs: list[dict]) -> str:
    return f"""
    QUESTION:

    {question}

    RESULTS:

    {tool_outputs}
    """


######### 1. Create Finance Analyst Table #########
finance_agent = pxt.create_table(f'{DIRECTORY}.financial_analyst', {'prompt': pxt.String}, if_exists='ignore')
messages = [{'role': 'user', 'content': finance_agent.prompt}]

tools = pxt.tools(stock_info)

# Add initial response from OpenAI
finance_agent.add_computed_column(
    initial_response=chat_completions(
        model=OPENAI_MODEL, messages=messages, tools=tools, tool_choice=tools.choice(required=True)
    )
)

# Invoke tools
finance_agent.add_computed_column(tool_output=invoke_tools(tools, finance_agent.initial_response))

# Create prompt with invoked response
finance_agent.add_computed_column(stock_response_prompt=create_prompt(finance_agent.prompt, finance_agent.tool_output))

# Send back to OpenAI for final response
messages = [
    {'role': 'system', 'content': "Answer the user's question based on the results."},
    {'role': 'user', 'content': finance_agent.stock_response_prompt},
]
finance_agent.add_computed_column(final_response=chat_completions(model=OPENAI_MODEL, messages=messages))
finance_agent.add_computed_column(answer=finance_agent.final_response.choices[0].message.content)
finance_agent_udf = pxt.udf(finance_agent, return_value=finance_agent.answer)


######### 2. Create Portfolio Manager Table #########
portfolio_manager = pxt.create_table(f'{DIRECTORY}.portfolio_manager', {'prompt': pxt.String}, if_exists='ignore')
messages = [{'role': 'user', 'content': portfolio_manager.prompt}]
portfolio_manager.add_computed_column(result=finance_agent_udf(portfolio_manager.prompt))


##### 3. Test agents #####
finance_agent = pxt.get_table(f'{DIRECTORY}.financial_analyst')
portfolio_manager = pxt.get_table(f'{DIRECTORY}.portfolio_manager')
portfolio_manager.insert([{'prompt': 'What is the price of NVDIA?'}])
print(portfolio_manager.select(portfolio_manager.result).collect())



# End timing and print execution time
end_time = time.time()
execution_time = end_time - start_time
print(f'\nTotal execution time: {execution_time:.2f} seconds')
```

### Key Benefits

- **Modularity**: Build complex systems from smaller, reusable parts
- **Encapsulation**: Hide implementation details behind a simple interface
- **Reusability**: Use specialized tables across multiple projects
- **Maintainability**: Update internal logic without changing dependent tables

## Performance Optimization

<CardGroup cols={1}>
  <Card title="Batching" icon="layer-group">
    ```python
    @pxt.udf(batch_size=16)
    def embed_texts(
        texts: Batch[str]
    ) -> Batch[pxt.Array]:
        # Process multiple texts at once
        return model.encode(texts)
    ```
  </Card>
  
  <Card title="Caching" icon="database">
    ```python
    @pxt.udf
    def expensive_operation(text: str) -> str:
        # Cache model instance
        if not hasattr(expensive_operation, 'model'):
            expensive_operation.model = load_model()
        return expensive_operation.model(text)
    ```
  </Card>
</CardGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Type Safety" icon="shield-check">
    - Always provide complete type hints
    - Use specific types over generic ones
    - Validate input ranges where appropriate
    ```python
    @pxt.udf
    def validate_score(score: float) -> float:
        if not 0 <= score <= 100:
            raise ValueError("Score must be between 0 and 100")
        return score
    ```
  </Accordion>

  <Accordion title="Performance" icon="gauge-high">
    - Use batching for GPU operations
    - Cache expensive resources
    - Process data in chunks when possible
    ```python
    @pxt.udf(batch_size=32)
    def process_chunk(items: Batch[str]) -> Batch[str]:
        if not hasattr(process_chunk, 'model'):
            process_chunk.model = load_expensive_model()
        return process_chunk.model.process_batch(items)
    ```
  </Accordion>

  <Accordion title="Organization" icon="folder-tree">
    - Keep related UDFs in modules
    - Use clear, descriptive names
    - Document complex operations
    ```python
    @pxt.udf
    def normalize_text(
        text: str,
        lowercase: bool = True,
        remove_punctuation: bool = True
    ) -> str:
        """Normalize text by optionally lowercasing and removing punctuation."""
        if lowercase:
            text = text.lower()
        if remove_punctuation:
            text = text.translate(str.maketrans("", "", string.punctuation))
        return text
    ```
  </Accordion>
  
  <Accordion title="Table UDFs" icon="table">
    - Define clear input and output columns for your table UDFs
    - Implement cleanup routines for tables that grow large
    - Balance between too many small tables and monolithic tables
    - Use clear naming conventions for tables and their UDFs
    - Document the purpose and expected inputs for each table UDF
  </Accordion>
</AccordionGroup>

## Error Handling

<Warning>
Always handle potential errors in UDFs to prevent workflow failures. Pixeltable tracks exceptions but cannot recover automatically.
</Warning>

```python
@pxt.udf
def safe_process(text: str) -> str:
    try:
        return complex_processing(text)
    except Exception as e:
        logger.error(f"Processing failed: {e}")
        return ""  # Return safe default
```

## Additional Resources

<CardGroup cols={3}>
  <Card title="API Documentation" icon="book" href="https://pixeltable.github.io/pixeltable/">
    Complete API reference
  </Card>
  <Card title="UDF Examples" icon="code" href="/docs/examples/udfs">
    Example implementations
  </Card>
  <Card title="Performance Guide" icon="gauge" href="/docs/optimization">
    Optimization tips
  </Card>
</CardGroup>