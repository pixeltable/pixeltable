---
title: 'Tables'
description: 'Learn the fundamentals of Pixeltable tables, types, and the development lifecycle'
icon: 'database'
---

## Core Concepts

<CardGroup cols={3}>
  <Card title="Tables" icon="table">
    Central data structure for organizing multimodal data and computations
  </Card>
  <Card title="Computed Columns" icon="calculator">
    Data transformations and model inferences
  </Card>
  <Card title="Versioning" icon="code-branch">
    Built-in tracking of data and schema changes
  </Card>
</CardGroup>

<Info>
Learn more about Pixeltable tables and the data operations with our [in-depth guide](https://github.com/pixeltable/pixeltable/blob/main/docs/notebooks/fundamentals/tables-and-data-operations.ipynb).
</Info>

## Type System

<Tabs>
  <Tab title="Basic Types">
    ```python
    # Import types
    import pixeltable as pxt
    
    # Schema definition
    table = pxt.create_table('example', {
        'text': pxt.String,     # Text data
        'count': pxt.Int,       # Integer numbers
        'score': pxt.Float,     # Decimal numbers
        'active': pxt.Bool,     # Boolean values
        'created': pxt.Timestamp # Date/time values
    })
    ```
  </Tab>
  
  <Tab title="Media Types">
    ```python
    # Media handling
    media = pxt.create_table('media', {
        'image': pxt.Image[(224, 224), 'RGB'],  # With size & mode
        'video': pxt.Video,                     # Video reference
        'audio': pxt.Audio,                     # Audio file
        'document': pxt.Document                # PDF/text doc
    })
    ```
  </Tab>
  
  <Tab title="ML Types">
    ```python
    # ML-specific types
    ml_data = pxt.create_table('ml_features', {
        'embedding': pxt.Array[(768,), pxt.Float], # Fixed-size array
        'features': pxt.Array[(None, 512)],        # Variable first dim
        'metadata': pxt.Json                       # Flexible JSON data
    })
    ```
  </Tab>
</Tabs>

## Data Operations

<CardGroup cols={1}>
  <Card title="Query Operations" icon="magnifying-glass">
    Filter and retrieve data:
    ```python
    # Basic row count
    movies.count()  # Returns total number of rows
    
    # Basic filtering
    movies.where(movies.budget >= 200.0).collect()
    
    # Select specific columns
    movies.select(movies.title, movies.year).collect()
    
    # Limit results
    movies.limit(5).collect()  # First 5 rows (no specific order)
    movies.head(5)  # First 5 rows by insertion order
    movies.tail(5)  # Last 5 rows by insertion order
    
    # Order results
    movies.order_by(movies.budget, asc=False).limit(5).collect()
    ```
  </Card>

  <Card title="String Operations" icon="font">
    Manipulate text data:
    ```python
    # String contains
    movies.where(movies.title.contains('Inception')).collect()
    
    # String replacement
    movies.update({
        'plot': movies.plot.replace('corporate secrets', 'subconscious secrets')
    })
    
    # String functions
    movies.update({
        'title': movies.title.upper(),        # Convert to uppercase
        'length': movies.title.len()          # Get string length
    })
    ```
  </Card>

  <Card title="Insert Operations" icon="plus">
    Add new data:
    ```python
    # Insert single row
    movies.insert(
        title='Inside Out 2',
        year=2024,
        plot='Emotions navigate puberty',
        budget=200.0
    )
    
    # Insert multiple rows
    movies.insert([
        {
            'title': 'Jurassic Park', 
            'year': 1993, 
            'plot': 'Dinosaur theme park disaster',
            'budget': 63.0
        },
        {
            'title': 'Titanic', 
            'year': 1997, 
            'plot': 'Ill-fated ocean liner romance',
            'budget': 200.0
        }
    ])
    ```
  </Card>

  <Card title="Update Operations" icon="pen-to-square">
    Modify existing data:
    ```python
    # Update all rows
    movies.update({
        'budget': movies.budget * 1.1  # Increase all budgets by 10%
    })
    
    # Conditional updates
    movies.where(
        movies.year < 2000
    ).update({
        'plot': movies.plot + ' (Classic Film)'
    })
    
    # Batch updates for multiple rows
    updates = [
        {'id': 1, 'budget': 175.0},
        {'id': 2, 'budget': 185.0}
    ]
    movies.batch_update(updates)
    ```
  </Card>

  <Card title="Delete Operations" icon="trash">
    Remove data with conditions:
    ```python
    # Delete specific rows
    movies.where(
        movies.year < 1995
    ).delete()
    
    # Delete with complex conditions
    movies.where(
        (movies.budget < 100.0) & 
        (movies.year < 2000)
    ).delete()
    
    # WARNING: Delete all rows (use with caution!)
    # movies.delete()  # Without where clause deletes all rows
    ```
  </Card>

  <Card title="Column Operations" icon="table-columns">
    Manage table structure:
    ```python
    # Add new column
    movies.add_column(rating=pxt.String)
    
    # Drop column
    movies.drop_column('rating')
    
    # View schema
    movies.describe()
    ```
  </Card>

  <Card title="Versioning" icon="clock-rotate-left">
    Manage table versions:
    ```python
    # Revert the last operation
    movies.revert()  # Cannot be undone!
    
    # Revert multiple times to go back further
    movies.revert()
    movies.revert()  # Goes back two operations
    ```
  </Card>

  <Card title="Export Operations" icon="file-export">
    Extract data for analysis:
    ```python
    # Get results as Python objects
    result = movies.limit(5).collect()
    first_row = result[0]  # Get first row as dict
    timestamps = result['timestamp']  # Get list of values for one column
    
    # Convert to Pandas
    df = result.to_pandas()
    df['revenue'].describe()  # Get statistics for revenue column
    ```
  </Card>
</CardGroup>

<Warning>
Always use a `where()` clause with `delete()`. Without it, all rows in the table will be deleted! While you can use `revert()` to undo operations, it's better to be careful with destructive operations.
</Warning>


## Best Practices

<CardGroup cols={2}>
  <Card title="Schema Definition" icon="file-code">
    - Keep schema definition in separate files
    - Use clear naming for directories and tables
    - Document computed column dependencies
  </Card>
  
  <Card title="Application Code" icon="code">
    - Use `get_table()` to connect to existing tables
    - Handle errors when table doesn't exist
    - Use batch operations for multiple rows
  </Card>
</CardGroup>

## Common Patterns

<AccordionGroup>
  <Accordion title="Development Workflow" icon="code-branch">
    1. Create `schema.py` for structure
    2. Test schema and pipeline
    3. Create `app.py` for usage
    4. Deploy both files
  </Accordion>

  <Accordion title="Production Setup" icon="rocket">
    ```python
    # schema.py - Run once to set up
    pxt.create_table(..., if_exists="ignore")
    
    # app.py - Production code
    table = pxt.get_table("myapp.mytable")
    if table is None:
        raise RuntimeError("Run schema.py first!")
    ```
  </Accordion>
</AccordionGroup>

## Additional Resources

<CardGroup cols={3}>
  <Card title="API Documentation" icon="book" href="https://pixeltable.github.io/pixeltable/">
    Complete API reference
  </Card>
  <Card title="Examples" icon="lightbulb" href="/docs/examples">
    Sample workflows
  </Card>
  <Card title="Cheat Sheet" icon="file" href="https://pixeltable.github.io/pixeltable/api-cheat-sheet/">
    Quick reference
  </Card>
</CardGroup>

---
title: 'Tables & Data Management'
description: 'Master Pixeltable data structures, computed columns, and multimodal pipelines'
icon: 'database'
---

# Pixeltable Tables

Pixeltable provides a unified interface for managing AI/ML data pipelines, with powerful features for handling multimodal data, automatic versioning, and seamless integration with modern AI workflows.


## Development Lifecycle

<Steps>
  <Step title="Schema Definition">
    Create a `schema.py` file to define your data structure and processing pipeline:
    ```python
    import pixeltable as pxt
    from pixeltable.functions import openai
    from pixeltable.functions.huggingface import clip_image
    
    # Create organization directory
    pxt.create_dir('ai_workflow')
    
    # Create multimodal table
    media = pxt.create_table(
        'ai_workflow.media',
        {
            'image': pxt.Image,          # Support for image data
            'video': pxt.Video,          # Video file reference 
            'description': pxt.String,    # Text description
            'embedding': pxt.Array[(512,)], # Image embedding
            'timestamp': pxt.Timestamp
        }
    )
    ```
  </Step>

  <Step title="Add Computed Columns">
    Define automatic transformations and AI processing:
    ```python
    # Generate image embeddings
    media['image_embedding'] = clip_image(
        media.image, 
        model_id='openai/clip-vit-base-patch32'
    )
    
    # Create prompt for LLM
    @pxt.udf
    def create_prompt(img_desc: str) -> list[dict]:
        return [{
            'role': 'user',
            'content': f'Analyze this image: {img_desc}'
        }]
    
    media['messages'] = create_prompt(media.description)
    
    # Add LLM analysis
    media['analysis'] = openai.chat_completions(
        messages=media.messages,
        model='gpt-4o-mini'
    ).choices[0].message.content
    ```
  </Step>

  <Step title="Usage & Application">
    Create `app.py` to use your defined structure:
    ```python
    import pixeltable as pxt
    
    # Connect to existing table
    media = pxt.get_table('ai_workflow.media')
    
    # Add new data - computed columns process automatically
    media.insert([{
        'image': 'path/to/image.jpg',
        'description': 'Sunset over mountains',
        'timestamp': datetime.now()
    }])
    
    # Query with similarity search
    similar = media.where(
        media.image_embedding.similarity('mountain lake') > 0.8
    ).collect()
    ```
  </Step>
</Steps>

## Type System

<AccordionGroup>
  <Accordion title="Basic Types" icon="code">
    Import types from the `pixeltable` package:
    ```python    
    # Available basic types
    pxt.String   # Text data
    pxt.Int      # Integer numbers
    pxt.Float    # Decimal numbers
    pxt.Bool     # True/False values
    pxt.DateTime # Date and time values
    ```
  </Accordion>

  <Accordion title="Complex Types" icon="layer-group">
    Special types for AI/ML workflows:
    ```python
    pxt.Array    # Numerical arrays (embeddings)
    pxt.Json     # Arbitrary JSON structures
    pxt.Image    # Image files and metadata
    pxt.Video    # Video files and metadata
    pxt.Audio    # Audio files and metadata
    pxt.Document # Text documents and PDFs
    ```
  </Accordion>
</AccordionGroup>

## Data Operations

### Querying Data

<AccordionGroup>
  <Accordion title="Basic Queries" icon="magnifying-glass">
    ```python
    # Count rows
    table.count()
    
    # Get rows
    table.collect()                  # All rows
    table.limit(5).collect()        # First 5 rows
    table.head()                    # First rows by insertion
    table.tail()                    # Last rows by insertion
    
    # Filter data
    table.where(table.score > 0.8).collect()
    table.where(
        (table.created >= start_date) & 
        (table.active == True)
    ).collect()
    ```
  </Accordion>

  <Accordion title="Advanced Queries" icon="wand-magic-sparkles">
    ```python
    # Complex conditions
    results = table.where(
        table.text.contains('AI') & 
        ~table.embedding.is_null()
    ).order_by(
        table.score, 
        asc=False
    ).select(
        table.text,
        table.score,
        confidence=table.score * 100
    ).collect()
    
    # Similarity search
    similar = table.where(
        table.embedding.similarity(query_vector) > 0.7
    ).collect()
    ```
  </Accordion>
</AccordionGroup>

### Modifying Data

<CodeGroup>
  ```python Insert
  # Single row
  table.insert(
      text="Example",
      count=1,
      score=0.95
  )
  
  # Multiple rows
  table.insert([
      {'text': 'First', 'count': 1},
      {'text': 'Second', 'count': 2}
  ])
  ```

  ```python Update
  # Update all matching rows
  table.where(
      table.score < 0.5
  ).update({
      'active': False,
      'score': table.score * 1.1
  })
  
  # Batch updates
  updates = [
      {'id': 1, 'score': 0.9},
      {'id': 2, 'score': 0.8}
  ]
  table.batch_update(updates)
  ```

  ```python Delete
  # Delete with condition
  table.where(
      table.score < 0.3
  ).delete()
  
  # Revert last operation
  table.revert()
  ```
</CodeGroup>

### Schema Changes

```python
# Add column
table.add_column(category=pxt.String)

# Add computed column
table.add_computed_column(
    length=table.text.len()
)

# Drop column
table.drop_column('category')

# Describe schema
table.describe()
```

## Best Practices

<CardGroup cols={2}>
  <Card title="Schema Design" icon="sitemap">
    - Keep schema definition in separate files
    - Use clear, descriptive column names
    - Document computed column dependencies
    - Consider data types and constraints carefully
  </Card>
  
  <Card title="Error Handling" icon="shield-check">
    - Always validate table existence
    - Handle missing data gracefully
    - Use transactions for critical operations
    - Implement proper error recovery
  </Card>
  
  <Card title="Performance" icon="bolt">
    - Use batch operations for multiple rows
    - Leverage computed columns for caching
    - Index columns used in frequent queries
    - Monitor memory usage with large datasets
  </Card>
  
  <Card title="Production" icon="rocket">
    - Separate development and production code
    - Version control your schema definitions
    - Monitor computed column performance
    - Implement proper logging and monitoring
  </Card>
</CardGroup>

## Common Patterns

### Production Setup

```python
# config.py
TABLE_PATH = 'production.data'

# schema.py
def init_schema():
    pxt.create_table(
        TABLE_PATH,
        schema,
        if_exists='ignore'  # Don't overwrite in production
    )

# app.py
table = pxt.get_table(TABLE_PATH)
if table is None:
    raise RuntimeError("Schema not initialized!")
```

### Data Pipeline

```python
# Define processing stages
@pxt.udf
def preprocess(data: str) -> dict:
    # Custom preprocessing logic
    return {'processed': data.lower()}

# Create pipeline
table.add_computed_column(
    stage1=preprocess(table.raw_data)
)

table.add_computed_column(
    stage2=openai.embeddings(
        table.stage1.processed
    )
)

table.add_computed_column(
    final=my_model(table.stage2)
)
```

## Advanced Features

<AccordionGroup>
  <Accordion title="Embedding Indexes" icon="database">
    Create and use similarity search indexes:
    ```python
    # Add embedding index
    table.add_embedding_index(
        'text_embedding',
        string_embed=sentence_transformer
    )
    
    # Similarity search
    similar = table.where(
        table.text_embedding.similarity('query') > 0.8
    ).collect()
    ```
  </Accordion>

  <Accordion title="Custom Functions" icon="function">
    Define reusable transformations:
    ```python
    @pxt.udf
    def custom_transform(data: str) -> dict:
        # Complex processing logic
        return processed_data
    
    # Use in computed column
    table.add_computed_column(
        transformed=custom_transform(table.raw_data)
    )
    ```
  </Accordion>

  <Accordion title="Media Processing" icon="photo-film">
    Handle images and videos:
    ```python
    from pixeltable.iterators import FrameIterator
    
    # Create frame view
    frames = pxt.create_view(
        'video_frames',
        videos_table,
        iterator=FrameIterator.create(
            video=videos_table.video,
            fps=1
        )
    )
    ```
  </Accordion>
</AccordionGroup>

## Additional Resources

<CardGroup cols={3}>
  <Card title="API Reference" icon="book" href="https://pixeltable.github.io/pixeltable/">
    Complete API documentation
  </Card>
  
  <Card title="Examples" icon="lightbulb" href="https://huggingface.co/Pixeltable">
    Sample applications on Hugging Face
  </Card>
  
  <Card title="GitHub" icon="github" href="https://github.com/pixeltable/pixeltable">
    Source code and contributions
  </Card>
</CardGroup>

<Note>
Remember that Pixeltable automatically handles versioning and lineage tracking. Every operation is recorded and can be reverted if needed.
</Note>

<Warning>
Always use `where()` clauses with `delete()` operations. Without a condition, all rows will be deleted! While operations can be reverted, it's better to be explicit with data modifications.
</Warning>