---
title: "table.add_index"
description: "table.add_index() - Creates a database index on a column to accelerate query performance"
---

<Badge text="Performance" color="blue" size="small" />

## Function Signature

```python
table.add_index(
    col: Column,
    idx_name: Optional[str] = None,
    idx: Optional[Any] = None
) -> UpdateStatus
```

## Description

Creates a database index on the specified column to dramatically improve query performance for filtering, sorting, and joining operations. Database indexes are essential for production applications that need fast query response times on large datasets.

Pixeltable automatically chooses the optimal index type based on the column's data type and usage patterns. This includes B-tree indexes for scalar data, specialized indexes for text search, and optimized structures for numerical ranges.

## Parameters

<ParamField path="col" type="Column" required>
  The column to create an index on. Can be any column in the table including computed columns and media metadata fields.
</ParamField>

<ParamField path="idx_name" type="str" default="None">
  Optional custom name for the index. If not provided, Pixeltable generates a descriptive name based on the column name and index type.
</ParamField>

<ParamField path="idx" type="Any" default="None">
  Advanced index configuration object for specialized index types. Used for custom index parameters and optimization hints.
</ParamField>

## Returns

<ResponseField name="status" type="UpdateStatus">
  Status object indicating successful index creation with details about the index type and performance characteristics.
</ResponseField>

## Examples

### Basic Column Index

```python
import pixeltable as pxt

# Create a table with customer data
customers = pxt.create_table('customers', {
    'customer_id': pxt.String,
    'email': pxt.String,
    'signup_date': pxt.Timestamp,
    'subscription_tier': pxt.String
})

# Add index on frequently queried email column
customers.add_index(customers.email)

# Now email lookups are lightning fast
result = customers.where(customers.email == 'user@example.com').collect()
```

### Named Index for Complex Queries

```python
# Add a named index on signup date for time-range queries
customers.add_index(
    customers.signup_date, 
    idx_name='customer_signup_timeline'
)

# Efficient date range queries
recent_signups = customers.where(
    customers.signup_date >= '2024-01-01'
).collect()

# Fast subscription tier filtering
premium_users = customers.where(
    customers.subscription_tier == 'premium'
).collect()
```

### Production Performance Optimization

```python
# Media processing table with performance-critical columns
media_files = pxt.create_table('media_analysis', {
    'file_path': pxt.String,
    'media_type': pxt.String,
    'file_size': pxt.Int,
    'created_at': pxt.Timestamp,
    'processed': pxt.Bool
})

# Strategic indexing for common query patterns
media_files.add_index(media_files.media_type, idx_name='media_type_lookup')
media_files.add_index(media_files.processed, idx_name='processing_status')
media_files.add_index(media_files.created_at, idx_name='creation_timeline')

# Now these production queries are optimized
unprocessed_videos = media_files.where(
    (media_files.media_type == 'video') & 
    (media_files.processed == False)
).collect()

large_files_today = media_files.where(
    (media_files.file_size > 100_000_000) &
    (media_files.created_at >= '2024-07-20')
).collect()
```

### Multi-Column Index Strategy

```python
# E-commerce orders table
orders = pxt.create_table('orders', {
    'order_id': pxt.String,
    'customer_id': pxt.String,
    'status': pxt.String,
    'order_date': pxt.Timestamp,
    'total_amount': pxt.Float
})

# Index high-cardinality columns first
orders.add_index(orders.customer_id, idx_name='customer_orders')
orders.add_index(orders.status, idx_name='order_status')
orders.add_index(orders.order_date, idx_name='order_timeline')

# Compound query optimization
customer_pending_orders = orders.where(
    (orders.customer_id == 'CUST_12345') &
    (orders.status == 'pending')
).collect()
```

### Index Management Best Practices

```python
import pixeltable as pxt
from datetime import datetime, timedelta

# Analytics table for query optimization
analytics = pxt.create_table('user_analytics', {
    'user_id': pxt.String,
    'event_type': pxt.String,
    'timestamp': pxt.Timestamp,
    'session_id': pxt.String,
    'page_url': pxt.String
})

# Index strategy based on query patterns
try:
    # High-frequency lookup columns
    analytics.add_index(analytics.user_id, idx_name='user_lookup')
    analytics.add_index(analytics.event_type, idx_name='event_filter')
    
    # Time-series optimization
    analytics.add_index(analytics.timestamp, idx_name='time_series')
    
    # Session analysis optimization
    analytics.add_index(analytics.session_id, idx_name='session_tracking')
    
    print("âœ… Performance optimization complete!")
    print("ðŸš€ Query speed increased by 10-100x on indexed columns")
    
    # Verify index performance with complex query
    recent_login_events = analytics.where(
        (analytics.event_type == 'login') &
        (analytics.timestamp >= datetime.now() - timedelta(days=7))
    ).collect()
    
    print(f"ðŸ“Š Found {len(recent_login_events)} recent login events")
    
except Exception as e:
    print(f"âŒ Index creation failed: {e}")
```

### Computed Column Indexing

```python
# Table with computed columns for AI analysis
documents = pxt.create_table('documents', {
    'doc_path': pxt.String,
    'content': pxt.String
})

# Add computed column for document length
@pxt.udf(return_type=pxt.Int)
def doc_length(content: str) -> int:
    return len(content.split())

documents.add_computed_column(word_count=doc_length(documents.content))

# Index the computed column for fast filtering
documents.add_index(documents.word_count, idx_name='document_length')

# Efficient queries on computed values
long_documents = documents.where(
    documents.word_count > 5000
).collect()

short_summaries = documents.where(
    documents.word_count < 500
).collect()
```

## Performance Impact

### Query Speed Improvements

| Query Type | Without Index | With Index | Speedup |
|------------|---------------|------------|---------|
| Exact match | O(n) scan | O(log n) lookup | 10-1000x |
| Range queries | O(n) scan | O(log n + k) | 50-500x |
| Sorting | O(n log n) | O(k) | 100-10000x |
| Group by | O(n log n) | O(k log k) | 10-100x |

### Index Overhead

- **Storage**: 10-30% additional disk space per index
- **Insert Speed**: 5-15% slower due to index maintenance
- **Memory**: Frequently accessed indexes cached in RAM

## Index Selection Strategy

### **Primary Candidates for Indexing:**
- **Foreign key columns** - Customer IDs, product IDs
- **Filter columns** - Status, category, type fields
- **Sort columns** - Timestamps, names, scores
- **Range query columns** - Dates, prices, quantities

### **Avoid Indexing:**
- **Low cardinality columns** - Boolean flags with 90%+ same value
- **Frequently updated columns** - Index maintenance overhead
- **Large text columns** - Use text search indexes instead
- **Temporary columns** - Short-lived computed columns

## Related Functions

- [`add_embedding_index`](./add_embedding_index) - Create vector similarity indexes for AI/ML workloads
- [`drop_index`](./drop_index) - Remove database indexes to save space
- [`list_tables`](../table_management/list_tables) - View table schemas and existing indexes

---

*Generated from Pixeltable semantic database. Enhanced with performance optimization best practices.*