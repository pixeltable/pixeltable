---
title: 'Building Queries'
description: 'Learn how to query and transform data in Pixeltable using where() and select()'
---

## What are Queries?

Queries in Pixeltable allow you to filter, transform, and extract data from tables and views. Using Pixeltable's expressive query interface, you can build powerful data pipelines without writing complex SQL or using external transformation tools.

Pixeltable queries use a fluent API design where operations can be chained together to:
- Filter rows based on specific conditions using `where()`
- Select and transform columns using `select()`
- Sort results with `order_by()`
- Limit result sets with `limit()`
- Perform aggregations and calculations

Queries don't execute until you call `collect()`, making them efficient for complex operations. You can build queries incrementally, adding conditions and transformations as needed.

```python
# A basic query that filters, transforms, and sorts data
result = movies.where(
    (movies.year >= 2000) & (movies.budget > 100.0)
).select(
    movies.title,
    roi=movies.revenue / movies.budget
).order_by(
    'roi', asc=False
).limit(5).collect()
```

## Basic Filtering

<Note>
This guide builds on tables created in previous sections. The `movies` table from [Tables](/docs/datastore/tables-and-operations)
</Note>

<Tabs>
  <Tab title="Simple Where">
    Use `where()` to filter rows based on basic conditions:
    ```python
    # Find movies with budget over $200M
    movies.where(
        movies.budget >= 200.0
    ).collect()
    ```

  | title | year | budget |
  |-----------|------|---------|
  | Titanic | 1997 | 200.0 |
  | Avengers: Endgame | 2019 | 356.0 |
  </Tab>

  <Tab title="Basic Select">
    Use `select()` to choose specific columns:
    ```python
    # Get titles and release years
    movies.select(
        movies.title,
        movies.year
    ).collect()
    ```


    | title | year |
    |-----------|------|
    | Jurassic Park | 1993 |
    | Titanic | 1997 |
    | Avengers: Endgame | 2019 |
    | Inside Out 2 | 2024 |

  </Tab>

  <Tab title="Column Naming">
    Rename columns in your results:
    ```python
    # Budget in hundreds of millions
    movies.select(
        movies.title,
        budget_hundreds=movies.budget / 100
    ).collect()
    ```


    | title | budget_hundreds |
    |-----------|----------|
    | Jurassic Park | 0.63 |
    | Titanic | 2.0 |
    | Avengers: Endgame | 3.56 |
    | Inside Out 2 | 2.0 |

  </Tab>
</Tabs>

## Column References

Pixeltable supports two syntaxes for column references:

```python
# Dot notation (preferred)
t.column_name

# Dictionary notation (useful for dynamic column names)
t['column_name']

# Both are equivalent
t.select(t.name, t.age).collect()
t.select(t['name'], t['age']).collect()
```

## Boolean Logic and Conditions

### Combining Conditions

Use `&` (AND), `|` (OR), and `~` (NOT) for complex conditions:

```python
# AND operation
movies.where((movies.year >= 2000) & (movies.budget >= 200.0)).collect()

# OR operation
movies.where((movies.year < 2000) | (movies.budget < 100.0)).collect()

# NOT operation
movies.where(~movies.title.contains('Park')).collect()

# Complex combinations
movies.where(
    ((movies.year > 2010) & (movies.budget > 100)) |
    (movies.title.contains('Classic'))
).collect()
```

<Warning>
Use `&`, `|`, `~` instead of Python's `and`, `or`, `not`. Always use parentheses around individual conditions.
</Warning>

### List-Based Filtering

Use `isin()` for multiple value matching:

```python
# Check if value is in list
genres = ['Action', 'Adventure', 'Sci-Fi']
movies.where(movies.genre.isin(genres)).collect()

# More efficient than multiple OR conditions
valid_ids = [123, 456, 789]
movies.where(movies.id.isin(valid_ids)).collect()
```

## Text Operations

Work with string data using built-in methods:

```python
# String contains
movies.where(movies.plot.contains('secret')).collect()

# Case conversion
movies.select(movies.title.upper(), movies.title.lower()).collect()

# String length
movies.where(movies.title.len() > 10).collect()

# Pattern matching
movies.where(movies.title.like('%: %')).collect()  # Find titles with subtitles
```

## Working with JSON Data

Extract and query JSON fields:

```python
# Dot notation for JSON fields
t.select(t.metadata.author, t.metadata.created_date).collect()

# Bracket notation for dynamic keys
t.select(t.config['api_key'], t.config['timeout']).collect()

# Nested JSON access
t.select(t.user.profile.name, t.user.preferences.theme).collect()

# Handle missing keys (returns None, no errors)
t.where(t.metadata.author != None).collect()
```

## Sorting and Limiting

### Order By

Sort results using `order_by()`:

```python
# Single column sorting
movies.order_by(movies.budget, asc=False).collect()  # Highest budget first

# Multiple column sorting
movies.order_by([movies.year, movies.budget], asc=[True, False]).collect()

# Expression-based sorting
movies.order_by(movies.revenue / movies.budget, asc=False).collect()
```

### Limiting Results

Control result set size with `limit()`:

```python
# Get top 10 results
movies.order_by(movies.score, asc=False).limit(10).collect()

# Pagination (skip first 20, get next 10)
movies.order_by(movies.id).limit(10, offset=20).collect()
```

## Expressions and Computed Values

### Arithmetic Operations

Perform calculations within queries:

```python
# Basic arithmetic
movies.select(
    movies.title,
    price_with_tax=movies.price * 1.08,
    profit_margin=(movies.revenue - movies.budget) / movies.revenue
).collect()

# Boolean expressions
movies.select(
    movies.title,
    is_blockbuster=movies.revenue > 1000.0,
    is_recent=movies.year >= 2020
).collect()
```

### Expression Variables

Store complex expressions for reuse:

```python
# Define reusable expressions
high_budget = movies.budget > 200.0
recent_release = movies.year >= 2020
blockbuster = (movies.revenue > 1000.0) & high_budget

# Use in multiple queries
big_movies = movies.where(blockbuster).collect()
recent_big_movies = movies.where(blockbuster & recent_release).collect()
```

## Aggregations

Compute aggregate values:

```python
# Count rows
total_movies = movies.count()

# Basic aggregations
movies.select(
    avg_budget=movies.budget.mean(),
    total_revenue=movies.revenue.sum(),
    max_year=movies.year.max(),
    min_budget=movies.budget.min()
).collect()

# Group by operations
movies.group_by(movies.genre).agg({
    'count': movies.id.count(),
    'avg_budget': movies.budget.mean(),
    'total_revenue': movies.revenue.sum()
}).collect()
```

## Working with Dates and Timestamps

Query temporal data effectively:

```python
from datetime import datetime, date

# Date range queries
events.where(events.created_date >= date(2024, 1, 1)).collect()
events.where(events.timestamp <= datetime.now()).collect()

# Date arithmetic
events.select(
    events.event_name,
    days_ago=(datetime.now() - events.event_date).days
).collect()

# Extract date parts
events.select(
    events.timestamp.year,
    events.timestamp.month,
    events.timestamp.day_of_week
).collect()
```

## Vector and Similarity Operations

Query by vector similarity (requires embedding index):

```python
# Similarity search
sim = t.embedding.similarity(query_vector)
results = t.order_by(sim, asc=False).limit(10).select(
    t.id, t.content, similarity=sim
).collect()

# Text-to-image search with CLIP
text_query = "a sunset over mountains"
sim = images.image.similarity(text_query)
results = images.order_by(sim, asc=False).limit(5).collect()
```

## Advanced Query Patterns

### Chaining Operations

Build complex queries step by step:

```python
# Multi-step query pipeline
result = (movies
    .where(movies.year >= 2000)
    .select(movies.title, movies.genre, movies.revenue)
    .order_by(movies.revenue, asc=False)
    .limit(50)
    .collect()
)
```

### Common Patterns

```python
# Data exploration - quick profiling
movies.select(
    count=movies.id.count(),
    min_budget=movies.budget.min(),
    max_budget=movies.budget.max(),
    avg_budget=movies.budget.mean()
).collect()

# Find unique values
movies.select(movies.genre).distinct().collect()

# Data validation - find invalid records
invalid = movies.where(
    (movies.budget <= 0) |
    (movies.revenue < 0) |
    (movies.title == None)
).collect()
```
