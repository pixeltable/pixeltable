---
title: "Query Syntax"
description: "Complete reference for Pixeltable's SQL-like query language and expression system"
---

# Query Syntax

Pixeltable provides a powerful, SQL-like query interface that works seamlessly with multimedia data, AI models, and traditional structured data. This guide covers everything from basic queries to advanced expressions.

## Core Query Operations

### Basic Selection

Select specific columns from a table:

```python
# Select specific columns
t.select(t.name, t.age).collect()

# Select all columns  
t.collect()

# Select with aliases
t.select(t.name, age_years=t.age).collect()
```

### Filtering with Where Clauses

Filter rows using comparison operations:

```python
# Basic comparisons
t.where(t.age > 25).collect()
t.where(t.name == 'John').collect()
t.where(t.status != 'inactive').collect()

# Range queries
t.where(t.score >= 0.8).collect()
t.where(t.created_date <= '2024-01-01').collect()
```

### Column References

Pixeltable supports two syntaxes for column references:

```python
# Dot notation (preferred)
t.column_name

# Dictionary notation (useful for dynamic column names)
t['column_name']

# Both are equivalent
t.select(t.name, t.age).collect()
t.select(t['name'], t['age']).collect()
```

## Boolean Logic and Compound Conditions

### Logical Operators

Combine conditions using `&` (AND), `|` (OR), and `~` (NOT):

```python
# AND operation
t.where((t.age > 25) & (t.score >= 0.8)).collect()

# OR operation  
t.where((t.department == 'engineering') | (t.department == 'data')).collect()

# NOT operation
t.where(~(t.status == 'inactive')).collect()

# Complex combinations
t.where(((t.age > 30) & (t.score > 0.9)) | (t.priority == 'high')).collect()
```

<Warning>
Use `&`, `|`, `~` instead of Python's `and`, `or`, `not`. Always use parentheses around individual conditions.
</Warning>

### List-Based Filtering

Use `isin()` for multiple value matching:

```python
# Check if value is in list
t.where(t.category.isin(['A', 'B', 'C'])).collect()

# More efficient than multiple OR conditions
t.where(t.id.isin([123, 456, 789])).collect()

# Works with any iterable
valid_ids = {100, 200, 300}
t.where(t.id.isin(valid_ids)).collect()
```

## String Operations

### String Methods in Queries

Apply string operations within queries:

```python
# String contains
t.where(t.description.contains('machine learning')).collect()

# Case conversion
t.select(t.name.upper(), t.name.lower()).collect()

# String length
t.where(t.name.len() > 5).collect()

# Pattern matching
t.where(t.email.contains('@company.com')).collect()
```

## Working with JSON Data

### JSON Field Access

Extract data from JSON columns using dot notation or bracket syntax:

```python
# Dot notation for JSON fields
t.select(t.metadata.author, t.metadata.created_date).collect()

# Bracket notation for dynamic keys
t.select(t.config['api_key'], t.config['timeout']).collect()

# Nested JSON access
t.select(t.user.profile.name, t.user.preferences.theme).collect()

# Mixed syntax
t.select(t.data.results[0].score).collect()
```

### Handling Missing Keys

Pixeltable gracefully handles missing JSON keys:

```python
# Returns None for missing keys (no errors)
t.select(t.metadata.nonexistent_field).collect()

# Filter for rows where JSON field exists
t.where(t.metadata.author != None).collect()
```

## Expressions and Computed Values

### Arithmetic Operations

Perform calculations within queries:

```python
# Basic arithmetic
t.select(t.price * 1.08).collect()  # Add 8% tax
t.select(t.total_revenue / t.total_orders).collect()  # Average order value

# Named expressions
t.select(
    t.product_name,
    price_with_tax=t.price * 1.08,
    profit_margin=(t.selling_price - t.cost_price) / t.selling_price
).collect()
```

### Boolean Expressions

Create boolean columns based on conditions:

```python
# Boolean columns
t.select(
    t.name,
    is_premium=t.price > 100,
    is_recent=t.created_date > '2024-01-01',
    meets_criteria=(t.score >= 0.8) & (t.status == 'active')
).collect()
```

### Expression Variables

Store complex expressions for reuse:

```python
# Define reusable expressions
high_value_customer = (t.total_spent > 1000) & (t.orders > 10)
recent_activity = t.last_login > '2024-08-01'

# Use in multiple queries
premium_customers = t.where(high_value_customer).collect()
active_premium = t.where(high_value_customer & recent_activity).collect()
```

## Sorting and Limiting

### Order By

Sort results using `order_by()`:

```python
# Single column sorting
t.order_by(t.created_date).collect()         # Ascending (default)
t.order_by(t.score, asc=False).collect()     # Descending

# Multiple column sorting  
t.order_by(t.department, t.salary, asc=False).collect()

# Expression-based sorting
t.order_by(t.first_name + ' ' + t.last_name).collect()
```

### Limiting Results

Control result set size with `limit()`:

```python
# Get top 10 results
t.order_by(t.score, asc=False).limit(10).collect()

# Pagination (skip first 20, get next 10)
t.order_by(t.id).limit(10, offset=20).collect()
```

## Working with Dates and Timestamps

### Date Comparisons

Query temporal data effectively:

```python
from datetime import datetime, date

# Date range queries
t.where(t.created_date >= date(2024, 1, 1)).collect()
t.where(t.timestamp <= datetime.now()).collect()

# Date arithmetic
t.select(
    t.event_name,
    days_ago=(datetime.now() - t.event_date).days
).collect()
```

### Timezone Handling

Work with timezone-aware timestamps:

```python
# Timezone conversion
t.select(
    t.event_name,
    utc_time=t.timestamp,
    local_time=t.timestamp.astimezone('America/New_York')
).collect()

# Extract date parts
t.select(
    t.timestamp.year,
    t.timestamp.month,
    t.timestamp.day_of_week
).collect()
```

## Aggregations

### Basic Aggregation Functions

Compute aggregate values:

```python
# Count rows
t.count()

# Aggregate functions
t.agg({
    'total_revenue': t.revenue.sum(),
    'avg_score': t.score.mean(),
    'max_date': t.created_date.max(),
    'min_age': t.age.min()
}).collect()
```

### Group By Operations

Group data for analysis:

```python
# Group by single column
t.group_by(t.department).agg({
    'employee_count': t.id.count(),
    'avg_salary': t.salary.mean()
}).collect()

# Group by multiple columns
t.group_by(t.department, t.location).agg({
    'headcount': t.id.count(),
    'total_budget': t.budget.sum()
}).collect()
```

## Advanced Query Patterns

### Chaining Operations

Combine multiple operations in a pipeline:

```python
# Multi-step query pipeline
result = (t
    .where(t.status == 'active')
    .select(t.name, t.department, t.salary)
    .order_by(t.salary, asc=False)
    .limit(50)
    .collect()
)
```

### Conditional Logic

Use conditional expressions within queries:

```python
# Case-when logic (using Python conditional expressions)
t.select(
    t.name,
    category='high' if t.score > 0.8 else ('medium' if t.score > 0.5 else 'low')
).collect()

# Multiple conditions
t.select(
    t.employee_name,
    bonus=t.base_salary * (0.15 if t.performance == 'excellent' else 
                          0.10 if t.performance == 'good' else 0.05)
).collect()
```

## Vector and Similarity Operations

### Embedding Similarity

Query by vector similarity (requires embedding index):

```python
# Similarity search
sim = t.embedding.similarity(query_vector)
results = (t
    .order_by(sim, asc=False)  # Higher similarity first
    .limit(10)
    .select(t.id, t.content, sim)
    .collect()
)

# Combined with filtering
results = (t
    .where(t.category == 'articles')
    .order_by(sim, asc=False)
    .limit(5)
    .collect()
)
```

### Image and Text Similarity

Search across modalities with CLIP embeddings:

```python
# Text-to-image search
text_query = "a cat in a garden"
sim = t.image.similarity(text_query)  # Assumes CLIP index
results = t.order_by(sim, asc=False).limit(10).collect()

# Image-to-image search  
reference_image = pxt.Image('reference.jpg')
sim = t.image.similarity(reference_image)
results = t.order_by(sim, asc=False).limit(5).collect()
```

## Best Practices

### Performance Optimization

```python
# Use limit() to avoid loading large result sets
large_table.select(t.id, t.name).limit(1000).collect()

# Prefer specific column selection over full table queries
t.select(t.needed_col1, t.needed_col2).collect()  # Good
t.collect()  # Avoid for large tables

# Use expression variables for complex reusable logic
complex_filter = (t.score > 0.8) & (t.active == True) & (t.verified == True)
results = t.where(complex_filter).collect()
```

### Error Handling

```python
# Handle potential null values in JSON
t.select(
    t.id,
    author=t.metadata.author if t.metadata.author != None else 'Unknown'
).collect()

# Robust string operations
t.where(t.description.contains('keyword')).collect()  # Safe - handles None
```

### Type Considerations

```python
# Explicit type handling for UDF results
@pxt.udf
def extract_number(text: str) -> int:
    return int(re.search(r'\d+', text).group())

# Use with proper error handling
t.select(
    t.text,
    number=extract_number(t.text)
).collect()
```

## Common Patterns

### Data Exploration

```python
# Quick data profiling
t.select(
    t.column.count(),
    t.column.min(),
    t.column.max(),
    t.column.mean()
).collect()

# Find unique values
t.select(t.category).distinct().collect()

# Sample data
t.limit(10).collect()
```

### Data Validation

```python
# Find null or invalid records
invalid_records = t.where(
    (t.required_field == None) |
    (t.score < 0) |
    (t.score > 1)
).collect()

# Check data quality
quality_report = t.agg({
    'total_rows': t.id.count(),
    'valid_emails': t.email.contains('@').sum(),
    'null_values': (t.important_field == None).sum()
}).collect()
```

This comprehensive query reference should serve as your "Pixeltable SQL guide" that covers everything from basic operations to advanced multimodal queries. The examples are all based on the patterns from your JSON-LD knowledge base.
