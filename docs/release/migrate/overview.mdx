---
title: 'Migrating to Pixeltable'
description: 'How concepts you already know map to Pixeltable'
---

Whether you've hand-rolled a pipeline with S3 + Lambda + direct API calls, or you're using frameworks like LangChain or LangGraph, Pixeltable unifies what you currently spread across multiple tools into a single Python library with declarative, incremental data infrastructure.

These guides show how the concepts you already know map to Pixeltable, and walk you through building the same pipelines with less code and fewer dependencies.

---

## Pick Your Starting Point

<CardGroup cols={2}>
  <Card title="Coming from a DIY Pipeline" icon="screwdriver-wrench" href="/migrate/from-diy-pipeline">
    **S3 + Lambda + SQS + direct API calls**

    Replace hand-rolled scripts, manual retries, embedding dumps, and glue code with declarative tables and computed columns.
  </Card>
  <Card title="Coming from LangChain + Pinecone" icon="link" href="/migrate/from-langchain-pinecone">
    **RAG pipelines and AI app backends**

    Document loaders, text splitters, vector stores, and retrieval chains become tables, iterators, embedding indexes, and computed columns.
  </Card>
  <Card title="Coming from LanceDB" icon="database" href="/migrate/from-lancedb">
    **Multimodal ML data wrangling**

    Lance tables, custom embedding scripts, and manual processing pipelines become typed tables with native media columns and declarative transforms.
  </Card>
  <Card title="Coming from LangGraph / CrewAI" icon="diagram-project" href="/migrate/from-langgraph">
    **AI agents with tools and memory**

    Graph nodes, state management, and separate memory stores become computed columns, persistent tables, and embedding indexes.
  </Card>
</CardGroup>

---

## What Changes

Across all three use cases, the shift is the same:

| What you manage today | With Pixeltable |
|---|---|
| Multiple packages (orchestration + vector DB + processing + glue) | One package: `pip install pixeltable` |
| Imperative pipelines you re-run manually | Declarative computed columns that run automatically on new data |
| Separate vector database (Pinecone, Weaviate, Chroma) | Built-in embedding indexes with `.similarity()` |
| No versioning or lineage | Automatic versioning, snapshots, and history |
| Raw bytes for media files | Native `Image`, `Video`, `Audio`, `Document` column types |
| Reprocess everything on changes | Incremental: only new or changed rows are recomputed |

---

## How It Works

Pixeltable replaces the multi-tool stack with a small set of composable primitives:

```python
import pixeltable as pxt

# 1. Store: typed tables with multimodal columns
docs = pxt.create_table('app.docs', {'pdf': pxt.Document, 'metadata': pxt.Json})

# 2. Iterate: split documents into chunks (view with iterator)
chunks = pxt.create_view('app.chunks', docs,
    iterator=DocumentSplitter.create(document=docs.pdf, separators='sentence,token_limit', limit=300))

# 3. Index: add embedding index (auto-maintained on insert)
chunks.add_embedding_index('text', string_embed=embeddings.using(model='text-embedding-3-small'))

# 4. Retrieve: semantic search
sim = chunks.text.similarity(string='How do I reset my password?')
results = chunks.order_by(sim, asc=False).limit(5).collect()

# 5. Orchestrate: computed columns chain transforms automatically
qa = pxt.create_table('app.qa', {'question': pxt.String})
qa.add_computed_column(context=retrieve_context(qa.question))
qa.add_computed_column(answer=generate_answer(qa.question, qa.context))

# Insert a question â€” context retrieval and answer generation happen automatically
qa.insert([{'question': 'How do I reset my password?'}])
```

Every intermediate result is stored, versioned, and queryable. Nothing is recomputed unless the source data changes.

---

## Next Steps

<CardGroup cols={2}>
  <Card title="Quick Start" icon="bolt" href="/overview/quick-start">
    Install Pixeltable and run your first pipeline in 5 minutes
  </Card>
  <Card title="10-Minute Tour" icon="play" href="/overview/ten-minute-tour">
    Hands-on walkthrough of tables, computed columns, and views
  </Card>
</CardGroup>
